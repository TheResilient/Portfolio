!function (e) { var t = {}; function i(n) { if (t[n]) return t[n].exports; var r = t[n] = { i: n, l: !1, exports: {} }; return e[n].call(r.exports, r, r.exports, i), r.l = !0, r.exports } i.m = e, i.c = t, i.d = function (e, t, n) { i.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: n }) }, i.r = function (e) { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e, "__esModule", { value: !0 }) }, i.t = function (e, t) { if (1 & t && (e = i(e)), 8 & t) return e; if (4 & t && "object" == typeof e && e && e.__esModule) return e; var n = Object.create(null); if (i.r(n), Object.defineProperty(n, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e) for (var r in e) i.d(n, r, function (t) { return e[t] }.bind(null, r)); return n }, i.n = function (e) { var t = e && e.__esModule ? function () { return e.default } : function () { return e }; return i.d(t, "a", t), t }, i.o = function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) }, i.p = "", i(i.s = 10) }([function (e, t, i) {
    "use strict"; (function (e, n) {
        i.d(t, "k", (function () { return r })), i.d(t, "m", (function () { return s })), i.d(t, "l", (function () { return a })), i.d(t, "i", (function () { return l })), i.d(t, "a", (function () { return c })), i.d(t, "b", (function () { return h })), i.d(t, "c", (function () { return u })), i.d(t, "d", (function () { return d })), i.d(t, "e", (function () { return p })), i.d(t, "f", (function () { return f })), i.d(t, "g", (function () { return m })), i.d(t, "h", (function () { return g })), i.d(t, "j", (function () { return v }));
        /*!
         * VERSION: 2.1.3
         * DATE: 2019-05-17
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         *
         * @author: Jack Doyle, jack@greensock.com
         */
        var r = "undefined" != typeof window ? window : e.exports && void 0 !== n ? n : {}, a = function (e) { var t = {}, i = e.document, n = e.GreenSockGlobals = e.GreenSockGlobals || e; if (n.TweenLite) return n.TweenLite; var r, a, s, o, l, c, h, u = function (e) { var t, i = e.split("."), r = n; for (t = 0; t < i.length; t++)r[i[t]] = r = r[i[t]] || {}; return r }, d = u("com.greensock"), p = function (e) { var t, i = [], n = e.length; for (t = 0; t !== n; i.push(e[t++])); return i }, f = function () { }, m = (c = Object.prototype.toString, h = c.call([]), function (e) { return null != e && (e instanceof Array || "object" == typeof e && !!e.push && c.call(e) === h) }), g = {}, v = function (e, i, r, a) { this.sc = g[e] ? g[e].sc : [], g[e] = this, this.gsClass = null, this.func = r; var s = []; this.check = function (o) { for (var l, c, h, d, p = i.length, f = p; --p > -1;)(l = g[i[p]] || new v(i[p], [])).gsClass ? (s[p] = l.gsClass, f--) : o && l.sc.push(this); if (0 === f && r) for (h = (c = ("com.greensock." + e).split(".")).pop(), d = u(c.join("."))[h] = this.gsClass = r.apply(r, s), a && (n[h] = t[h] = d), p = 0; p < this.sc.length; p++)this.sc[p].check() }, this.check(!0) }, y = e._gsDefine = function (e, t, i, n) { return new v(e, t, i, n) }, _ = d._class = function (e, t, i) { return t = t || function () { }, y(e, [], (function () { return t }), i), t }; y.globals = n; var x = [0, 0, 1, 1], b = _("easing.Ease", (function (e, t, i, n) { this._func = e, this._type = i || 0, this._power = n || 0, this._params = t ? x.concat(t) : x }), !0), w = b.map = {}, T = b.register = function (e, t, i, n) { for (var r, a, s, o, l = t.split(","), c = l.length, h = (i || "easeIn,easeOut,easeInOut").split(","); --c > -1;)for (a = l[c], r = n ? _("easing." + a, null, !0) : d.easing[a] || {}, s = h.length; --s > -1;)o = h[s], w[a + "." + o] = w[o + a] = r[o] = e.getRatio ? e : e[o] || new e }; for ((s = b.prototype)._calcEnd = !1, s.getRatio = function (e) { if (this._func) return this._params[0] = e, this._func.apply(null, this._params); var t = this._type, i = this._power, n = 1 === t ? 1 - e : 2 === t ? e : e < .5 ? 2 * e : 2 * (1 - e); return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === t ? 1 - n : 2 === t ? n : e < .5 ? n / 2 : 1 - n / 2 }, a = (r = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --a > -1;)s = r[a] + ",Power" + a, T(new b(null, null, 1, a), s, "easeOut", !0), T(new b(null, null, 2, a), s, "easeIn" + (0 === a ? ",easeNone" : "")), T(new b(null, null, 3, a), s, "easeInOut"); w.linear = d.easing.Linear.easeIn, w.swing = d.easing.Quad.easeInOut; var M = _("events.EventDispatcher", (function (e) { this._listeners = {}, this._eventTarget = e || this })); (s = M.prototype).addEventListener = function (e, t, i, n, r) { r = r || 0; var a, s, c = this._listeners[e], h = 0; for (this !== o || l || o.wake(), null == c && (this._listeners[e] = c = []), s = c.length; --s > -1;)(a = c[s]).c === t && a.s === i ? c.splice(s, 1) : 0 === h && a.pr < r && (h = s + 1); c.splice(h, 0, { c: t, s: i, up: n, pr: r }) }, s.removeEventListener = function (e, t) { var i, n = this._listeners[e]; if (n) for (i = n.length; --i > -1;)if (n[i].c === t) return void n.splice(i, 1) }, s.dispatchEvent = function (e) { var t, i, n, r = this._listeners[e]; if (r) for ((t = r.length) > 1 && (r = r.slice(0)), i = this._eventTarget; --t > -1;)(n = r[t]) && (n.up ? n.c.call(n.s || i, { type: e, target: i }) : n.c.call(n.s || i)) }; var S = e.requestAnimationFrame, E = e.cancelAnimationFrame, C = Date.now || function () { return (new Date).getTime() }, A = C(); for (a = (r = ["ms", "moz", "webkit", "o"]).length; --a > -1 && !S;)S = e[r[a] + "RequestAnimationFrame"], E = e[r[a] + "CancelAnimationFrame"] || e[r[a] + "CancelRequestAnimationFrame"]; _("Ticker", (function (e, t) { var n, r, a, s, c, h = this, u = C(), d = !(!1 === t || !S) && "auto", p = 500, m = 33, g = function (e) { var t, i, o = C() - A; o > p && (u += o - m), A += o, h.time = (A - u) / 1e3, t = h.time - c, (!n || t > 0 || !0 === e) && (h.frame++, c += t + (t >= s ? .004 : s - t), i = !0), !0 !== e && (a = r(g)), i && h.dispatchEvent("tick") }; M.call(h), h.time = h.frame = 0, h.tick = function () { g(!0) }, h.lagSmoothing = function (e, t) { if (!arguments.length) return p < 1 / 1e-8; p = e || 1 / 1e-8, m = Math.min(t, p, 0) }, h.sleep = function () { null != a && (d && E ? E(a) : clearTimeout(a), r = f, a = null, h === o && (l = !1)) }, h.wake = function (e) { null !== a ? h.sleep() : e ? u += -A + (A = C()) : h.frame > 10 && (A = C() - p + 5), r = 0 === n ? f : d && S ? S : function (e) { return setTimeout(e, 1e3 * (c - h.time) + 1 | 0) }, h === o && (l = !0), g(2) }, h.fps = function (e) { if (!arguments.length) return n; s = 1 / ((n = e) || 60), c = this.time + s, h.wake() }, h.useRAF = function (e) { if (!arguments.length) return d; h.sleep(), d = e, h.fps(n) }, h.fps(e), setTimeout((function () { "auto" === d && h.frame < 5 && "hidden" !== (i || {}).visibilityState && h.useRAF(!1) }), 1500) })), (s = d.Ticker.prototype = new d.events.EventDispatcher).constructor = d.Ticker; var P = _("core.Animation", (function (e, t) { if (this.vars = t = t || {}, this._duration = this._totalDuration = e || 0, this._delay = Number(t.delay) || 0, this._timeScale = 1, this._active = !!t.immediateRender, this.data = t.data, this._reversed = !!t.reversed, q) { l || o.wake(); var i = this.vars.useFrames ? Y : q; i.add(this, i._time), this.vars.paused && this.paused(!0) } })); o = P.ticker = new d.Ticker, (s = P.prototype)._dirty = s._gc = s._initted = s._paused = !1, s._totalTime = s._time = 0, s._rawPrevTime = -1, s._next = s._last = s._onUpdate = s._timeline = s.timeline = null, s._paused = !1; var L = function () { l && C() - A > 2e3 && ("hidden" !== (i || {}).visibilityState || !o.lagSmoothing()) && o.wake(); var e = setTimeout(L, 2e3); e.unref && e.unref() }; L(), s.play = function (e, t) { return null != e && this.seek(e, t), this.reversed(!1).paused(!1) }, s.pause = function (e, t) { return null != e && this.seek(e, t), this.paused(!0) }, s.resume = function (e, t) { return null != e && this.seek(e, t), this.paused(!1) }, s.seek = function (e, t) { return this.totalTime(Number(e), !1 !== t) }, s.restart = function (e, t) { return this.reversed(!1).paused(!1).totalTime(e ? -this._delay : 0, !1 !== t, !0) }, s.reverse = function (e, t) { return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1) }, s.render = function (e, t, i) { }, s.invalidate = function () { return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this }, s.isActive = function () { var e, t = this._timeline, i = this._startTime; return !t || !this._gc && !this._paused && t.isActive() && (e = t.rawTime(!0)) >= i && e < i + this.totalDuration() / this._timeScale - 1e-8 }, s._enabled = function (e, t) { return l || o.wake(), this._gc = !e, this._active = this.isActive(), !0 !== t && (e && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !e && this.timeline && this._timeline._remove(this, !0)), !1 }, s._kill = function (e, t) { return this._enabled(!1, !1) }, s.kill = function (e, t) { return this._kill(e, t), this }, s._uncache = function (e) { for (var t = e ? this : this.timeline; t;)t._dirty = !0, t = t.timeline; return this }, s._swapSelfInParams = function (e) { for (var t = e.length, i = e.concat(); --t > -1;)"{self}" === e[t] && (i[t] = this); return i }, s._callback = function (e) { var t = this.vars, i = t[e], n = t[e + "Params"], r = t[e + "Scope"] || t.callbackScope || this; switch (n ? n.length : 0) { case 0: i.call(r); break; case 1: i.call(r, n[0]); break; case 2: i.call(r, n[0], n[1]); break; default: i.apply(r, n) } }, s.eventCallback = function (e, t, i, n) { if ("on" === (e || "").substr(0, 2)) { var r = this.vars; if (1 === arguments.length) return r[e]; null == t ? delete r[e] : (r[e] = t, r[e + "Params"] = m(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[e + "Scope"] = n), "onUpdate" === e && (this._onUpdate = t) } return this }, s.delay = function (e) { return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + e - this._delay), this._delay = e, this) : this._delay }, s.duration = function (e) { return arguments.length ? (this._duration = this._totalDuration = e, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== e && this.totalTime(this._totalTime * (e / this._duration), !0), this) : (this._dirty = !1, this._duration) }, s.totalDuration = function (e) { return this._dirty = !1, arguments.length ? this.duration(e) : this._totalDuration }, s.time = function (e, t) { return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(e > this._duration ? this._duration : e, t)) : this._time }, s.totalTime = function (e, t, i) { if (l || o.wake(), !arguments.length) return this._totalTime; if (this._timeline) { if (e < 0 && !i && (e += this.totalDuration()), this._timeline.smoothChildTiming) { this._dirty && this.totalDuration(); var n = this._totalDuration, r = this._timeline; if (e > n && !i && (e = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - e : e) / this._timeScale, r._dirty || this._uncache(!1), r._timeline) for (; r._timeline;)r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline } this._gc && this._enabled(!0, !1), this._totalTime === e && 0 !== this._duration || (k.length && Z(), this.render(e, t, !1), k.length && Z()) } return this }, s.progress = s.totalProgress = function (e, t) { var i = this.duration(); return arguments.length ? this.totalTime(i * e, t) : i ? this._time / i : this.ratio }, s.startTime = function (e) { return arguments.length ? (e !== this._startTime && (this._startTime = e, this.timeline && this.timeline._sortChildren && this.timeline.add(this, e - this._delay)), this) : this._startTime }, s.endTime = function (e) { return this._startTime + (0 != e ? this.totalDuration() : this.duration()) / this._timeScale }, s.timeScale = function (e) { if (!arguments.length) return this._timeScale; var t, i; for (e = e || 1e-8, this._timeline && this._timeline.smoothChildTiming && (i = (t = this._pauseTime) || 0 === t ? t : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / e), this._timeScale = e, i = this.timeline; i && i.timeline;)i._dirty = !0, i.totalDuration(), i = i.timeline; return this }, s.reversed = function (e) { return arguments.length ? (e != this._reversed && (this._reversed = e, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed }, s.paused = function (e) { if (!arguments.length) return this._paused; var t, i, n = this._timeline; return e != this._paused && n && (l || e || o.wake(), i = (t = n.rawTime()) - this._pauseTime, !e && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = e ? t : null, this._paused = e, this._active = this.isActive(), !e && 0 !== i && this._initted && this.duration() && (t = n.smoothChildTiming ? this._totalTime : (t - this._startTime) / this._timeScale, this.render(t, t === this._totalTime, !0))), this._gc && !e && this._enabled(!0, !1), this }; var R = _("core.SimpleTimeline", (function (e) { P.call(this, 0, e), this.autoRemoveChildren = this.smoothChildTiming = !0 })); (s = R.prototype = new P).constructor = R, s.kill()._gc = !1, s._first = s._last = s._recent = null, s._sortChildren = !1, s.add = s.insert = function (e, t, i, n) { var r, a; if (e._startTime = Number(t || 0) + e._delay, e._paused && this !== e._timeline && (e._pauseTime = this.rawTime() - (e._timeline.rawTime() - e._pauseTime)), e.timeline && e.timeline._remove(e, !0), e.timeline = e._timeline = this, e._gc && e._enabled(!0, !0), r = this._last, this._sortChildren) for (a = e._startTime; r && r._startTime > a;)r = r._prev; return r ? (e._next = r._next, r._next = e) : (e._next = this._first, this._first = e), e._next ? e._next._prev = e : this._last = e, e._prev = r, this._recent = e, this._timeline && this._uncache(!0), this }, s._remove = function (e, t) { return e.timeline === this && (t || e._enabled(!1, !0), e._prev ? e._prev._next = e._next : this._first === e && (this._first = e._next), e._next ? e._next._prev = e._prev : this._last === e && (this._last = e._prev), e._next = e._prev = e.timeline = null, e === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this }, s.render = function (e, t, i) { var n, r = this._first; for (this._totalTime = this._time = this._rawPrevTime = e; r;)n = r._next, (r._active || e >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, i) : r.render((e - r._startTime) * r._timeScale, t, i)), r = n }, s.rawTime = function () { return l || o.wake(), this._totalTime }; var O = _("TweenLite", (function (t, i, n) { if (P.call(this, i, n), this.render = O.prototype.render, null == t) throw "Cannot tween a null target."; this.target = t = "string" != typeof t ? t : O.selector(t) || t; var r, a, s, o = t.jquery || t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType), l = this.vars.overwrite; if (this._overwrite = l = null == l ? X[O.defaultOverwrite] : "number" == typeof l ? l >> 0 : X[l], (o || t instanceof Array || t.push && m(t)) && "number" != typeof t[0]) for (this._targets = s = p(t), this._propLookup = [], this._siblings = [], r = 0; r < s.length; r++)(a = s[r]) ? "string" != typeof a ? a.length && a !== e && a[0] && (a[0] === e || a[0].nodeType && a[0].style && !a.nodeType) ? (s.splice(r--, 1), this._targets = s = s.concat(p(a))) : (this._siblings[r] = K(a, this, !1), 1 === l && this._siblings[r].length > 1 && ee(a, this, null, 1, this._siblings[r])) : "string" == typeof (a = s[r--] = O.selector(a)) && s.splice(r + 1, 1) : s.splice(r--, 1); else this._propLookup = {}, this._siblings = K(t, this, !1), 1 === l && this._siblings.length > 1 && ee(t, this, null, 1, this._siblings); (this.vars.immediateRender || 0 === i && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-8, this.render(Math.min(0, -this._delay))) }), !0), I = function (t) { return t && t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType) }; (s = O.prototype = new P).constructor = O, s.kill()._gc = !1, s.ratio = 0, s._firstPT = s._targets = s._overwrittenProps = s._startAt = null, s._notifyPluginsOfEnabled = s._lazy = !1, O.version = "2.1.3", O.defaultEase = s._ease = new b(null, null, 1, 1), O.defaultOverwrite = "auto", O.ticker = o, O.autoSleep = 120, O.lagSmoothing = function (e, t) { o.lagSmoothing(e, t) }, O.selector = e.$ || e.jQuery || function (t) { var n = e.$ || e.jQuery; return n ? (O.selector = n, n(t)) : (i || (i = e.document), i ? i.querySelectorAll ? i.querySelectorAll(t) : i.getElementById("#" === t.charAt(0) ? t.substr(1) : t) : t) }; var k = [], D = {}, z = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, N = /[\+-]=-?[\.\d]/, B = function (e) { for (var t, i = this._firstPT; i;)t = i.blob ? 1 === e && null != this.end ? this.end : e ? this.join("") : this.start : i.c * e + i.s, i.m ? t = i.m.call(this._tween, t, this._target || i.t, this._tween) : t < 1e-6 && t > -1e-6 && !i.blob && (t = 0), i.f ? i.fp ? i.t[i.p](i.fp, t) : i.t[i.p](t) : i.t[i.p] = t, i = i._next }, F = function (e) { return (1e3 * e | 0) / 1e3 + "" }, G = function (e, t, i, n) { var r, a, s, o, l, c, h, u = [], d = 0, p = "", f = 0; for (u.start = e, u.end = t, e = u[0] = e + "", t = u[1] = t + "", i && (i(u), e = u[0], t = u[1]), u.length = 0, r = e.match(z) || [], a = t.match(z) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), l = a.length, o = 0; o < l; o++)h = a[o], p += (c = t.substr(d, t.indexOf(h, d) - d)) || !o ? c : ",", d += c.length, f ? f = (f + 1) % 5 : "rgba(" === c.substr(-5) && (f = 1), h === r[o] || r.length <= o ? p += h : (p && (u.push(p), p = ""), s = parseFloat(r[o]), u.push(s), u._firstPT = { _next: u._firstPT, t: u, p: u.length - 1, s: s, c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - s) || 0, f: 0, m: f && f < 4 ? Math.round : F }), d += h.length; return (p += t.substr(d)) && u.push(p), u.setRatio = B, N.test(t) && (u.end = null), u }, U = function (e, t, i, n, r, a, s, o, l) { "function" == typeof n && (n = n(l || 0, e)); var c = typeof e[t], h = "function" !== c ? "" : t.indexOf("set") || "function" != typeof e["get" + t.substr(3)] ? t : "get" + t.substr(3), u = "get" !== i ? i : h ? s ? e[h](s) : e[h]() : e[t], d = "string" == typeof n && "=" === n.charAt(1), p = { t: e, p: t, s: u, f: "function" === c, pg: 0, n: r || t, m: a ? "function" == typeof a ? a : Math.round : 0, pr: 0, c: d ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - u || 0 }; if (("number" != typeof u || "number" != typeof n && !d) && (s || isNaN(u) || !d && isNaN(n) || "boolean" == typeof u || "boolean" == typeof n ? (p.fp = s, p = { t: G(u, d ? parseFloat(p.s) + p.c + (p.s + "").replace(/[0-9\-\.]/g, "") : n, o || O.defaultStringFilter, p), p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: r || t, pr: 0, m: 0 }) : (p.s = parseFloat(u), d || (p.c = parseFloat(n) - p.s || 0))), p.c) return (p._next = this._firstPT) && (p._next._prev = p), this._firstPT = p, p }, H = O._internals = { isArray: m, isSelector: I, lazyTweens: k, blobDif: G }, V = O._plugins = {}, j = H.tweenLookup = {}, W = 0, $ = H.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1, onOverwrite: 1, callbackScope: 1, stringFilter: 1, id: 1, yoyoEase: 1, stagger: 1 }, X = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, true: 1, false: 0 }, Y = P._rootFramesTimeline = new R, q = P._rootTimeline = new R, J = 30, Z = H.lazyRender = function () { var e, t, i = k.length; for (D = {}, e = 0; e < i; e++)(t = k[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1); k.length = 0 }; q._startTime = o.time, Y._startTime = o.frame, q._active = Y._active = !0, setTimeout(Z, 1), P._updateRoot = O.render = function () { var e, t, i; if (k.length && Z(), q.render((o.time - q._startTime) * q._timeScale, !1, !1), Y.render((o.frame - Y._startTime) * Y._timeScale, !1, !1), k.length && Z(), o.frame >= J) { for (i in J = o.frame + (parseInt(O.autoSleep, 10) || 120), j) { for (e = (t = j[i].tweens).length; --e > -1;)t[e]._gc && t.splice(e, 1); 0 === t.length && delete j[i] } if ((!(i = q._first) || i._paused) && O.autoSleep && !Y._first && 1 === o._listeners.tick.length) { for (; i && i._paused;)i = i._next; i || o.sleep() } } }, o.addEventListener("tick", P._updateRoot); var K = function (e, t, i) { var n, r, a = e._gsTweenID; if (j[a || (e._gsTweenID = a = "t" + W++)] || (j[a] = { target: e, tweens: [] }), t && ((n = j[a].tweens)[r = n.length] = t, i)) for (; --r > -1;)n[r] === t && n.splice(r, 1); return j[a].tweens }, Q = function (e, t, i, n) { var r, a, s = e.vars.onOverwrite; return s && (r = s(e, t, i, n)), (s = O.onOverwrite) && (a = s(e, t, i, n)), !1 !== r && !1 !== a }, ee = function (e, t, i, n, r) { var a, s, o, l; if (1 === n || n >= 4) { for (l = r.length, a = 0; a < l; a++)if ((o = r[a]) !== t) o._gc || o._kill(null, e, t) && (s = !0); else if (5 === n) break; return s } var c, h = t._startTime + 1e-8, u = [], d = 0, p = 0 === t._duration; for (a = r.length; --a > -1;)(o = r[a]) === t || o._gc || o._paused || (o._timeline !== t._timeline ? (c = c || te(t, 0, p), 0 === te(o, c, p) && (u[d++] = o)) : o._startTime <= h && o._startTime + o.totalDuration() / o._timeScale > h && ((p || !o._initted) && h - o._startTime <= 2e-8 || (u[d++] = o))); for (a = d; --a > -1;)if (l = (o = u[a])._firstPT, 2 === n && o._kill(i, e, t) && (s = !0), 2 !== n || !o._firstPT && o._initted && l) { if (2 !== n && !Q(o, t)) continue; o._enabled(!1, !1) && (s = !0) } return s }, te = function (e, t, i) { for (var n = e._timeline, r = n._timeScale, a = e._startTime; n._timeline;) { if (a += n._startTime, r *= n._timeScale, n._paused) return -100; n = n._timeline } return (a /= r) > t ? a - t : i && a === t || !e._initted && a - t < 2e-8 ? 1e-8 : (a += e.totalDuration() / e._timeScale / r) > t + 1e-8 ? 0 : a - t - 1e-8 }; s._init = function () { var e, t, i, n, r, a, s = this.vars, o = this._overwrittenProps, l = this._duration, c = !!s.immediateRender, h = s.ease, u = this._startAt; if (s.startAt) { for (n in u && (u.render(-1, !0), u.kill()), r = {}, s.startAt) r[n] = s.startAt[n]; if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = c && !1 !== s.lazy, r.startAt = r.delay = null, r.onUpdate = s.onUpdate, r.onUpdateParams = s.onUpdateParams, r.onUpdateScope = s.onUpdateScope || s.callbackScope || this, this._startAt = O.to(this.target || {}, 0, r), c) if (this._time > 0) this._startAt = null; else if (0 !== l) return } else if (s.runBackwards && 0 !== l) if (u) u.render(-1, !0), u.kill(), this._startAt = null; else { for (n in 0 !== this._time && (c = !1), i = {}, s) $[n] && "autoCSS" !== n || (i[n] = s[n]); if (i.overwrite = 0, i.data = "isFromStart", i.lazy = c && !1 !== s.lazy, i.immediateRender = c, this._startAt = O.to(this.target, 0, i), c) { if (0 === this._time) return } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null) } if (this._ease = h = h ? h instanceof b ? h : "function" == typeof h ? new b(h, s.easeParams) : w[h] || O.defaultEase : O.defaultEase, s.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, s.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (a = this._targets.length, e = 0; e < a; e++)this._initProps(this._targets[e], this._propLookup[e] = {}, this._siblings[e], o ? o[e] : null, e) && (t = !0); else t = this._initProps(this.target, this._propLookup, this._siblings, o, 0); if (t && O._onPluginEvent("_onInitAllProps", this), o && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), s.runBackwards) for (i = this._firstPT; i;)i.s += i.c, i.c = -i.c, i = i._next; this._onUpdate = s.onUpdate, this._initted = !0 }, s._initProps = function (t, i, n, r, a) { var s, o, l, c, h, u; if (null == t) return !1; for (s in D[t._gsTweenID] && Z(), this.vars.css || t.style && t !== e && t.nodeType && V.css && !1 !== this.vars.autoCSS && function (e, t) { var i, n = {}; for (i in e) $[i] || i in t && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!V[i] || V[i] && V[i]._autoCSS) || (n[i] = e[i], delete e[i]); e.css = n }(this.vars, t), this.vars) if (u = this.vars[s], $[s]) u && (u instanceof Array || u.push && m(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[s] = u = this._swapSelfInParams(u, this)); else if (V[s] && (c = new V[s])._onInitTween(t, this.vars[s], this, a)) { for (this._firstPT = h = { _next: this._firstPT, t: c, p: "setRatio", s: 0, c: 1, f: 1, n: s, pg: 1, pr: c._priority, m: 0 }, o = c._overwriteProps.length; --o > -1;)i[c._overwriteProps[o]] = this._firstPT; (c._priority || c._onInitAllProps) && (l = !0), (c._onDisable || c._onEnable) && (this._notifyPluginsOfEnabled = !0), h._next && (h._next._prev = h) } else i[s] = U.call(this, t, s, "get", u, s, 0, null, this.vars.stringFilter, a); return r && this._kill(r, t) ? this._initProps(t, i, n, r, a) : this._overwrite > 1 && this._firstPT && n.length > 1 && ee(t, this, i, this._overwrite, n) ? (this._kill(i, t), this._initProps(t, i, n, r, a)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (D[t._gsTweenID] = !0), l) }, s.render = function (e, t, i) { var n, r, a, s, o = this._time, l = this._duration, c = this._rawPrevTime; if (e >= l - 1e-8 && e >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (n = !0, r = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (e = 0), (c < 0 || e <= 0 && e >= -1e-8 || 1e-8 === c && "isPause" !== this.data) && c !== e && (i = !0, c > 1e-8 && (r = "onReverseComplete")), this._rawPrevTime = s = !t || e || c === e ? e : 1e-8); else if (e < 1e-8) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== o || 0 === l && c > 0) && (r = "onReverseComplete", n = this._reversed), e > -1e-8 ? e = 0 : e < 0 && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (c >= 0 && (1e-8 !== c || "isPause" !== this.data) && (i = !0), this._rawPrevTime = s = !t || e || c === e ? e : 1e-8)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0); else if (this._totalTime = this._time = e, this._easeType) { var h = e / l, u = this._easeType, d = this._easePower; (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === d ? h *= h : 2 === d ? h *= h * h : 3 === d ? h *= h * h * h : 4 === d && (h *= h * h * h * h), this.ratio = 1 === u ? 1 - h : 2 === u ? h : e / l < .5 ? h / 2 : 1 - h / 2 } else this.ratio = this._ease.getRatio(e / l); if (this._time !== o || i) { if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = o, this._rawPrevTime = c, k.push(this), void (this._lazy = [e, t]); this._time && !n ? this.ratio = this._ease.getRatio(this._time / l) : n && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) } for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== o && e >= 0 && (this._active = !0), 0 === o && (this._startAt && (e >= 0 ? this._startAt.render(e, !0, i) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== l || t || this._callback("onStart"))), a = this._firstPT; a;)a.f ? a.t[a.p](a.c * this.ratio + a.s) : a.t[a.p] = a.c * this.ratio + a.s, a = a._next; this._onUpdate && (e < 0 && this._startAt && -1e-4 !== e && this._startAt.render(e, !0, i), t || (this._time !== o || n || i) && this._callback("onUpdate")), r && (this._gc && !i || (e < 0 && this._startAt && !this._onUpdate && -1e-4 !== e && this._startAt.render(e, !0, i), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[r] && this._callback(r), 0 === l && 1e-8 === this._rawPrevTime && 1e-8 !== s && (this._rawPrevTime = 0))) } }, s._kill = function (e, t, i) { if ("all" === e && (e = null), null == e && (null == t || t === this.target)) return this._lazy = !1, this._enabled(!1, !1); t = "string" != typeof t ? t || this._targets || this.target : O.selector(t) || t; var n, r, a, s, o, l, c, h, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline, p = this._firstPT; if ((m(t) || I(t)) && "number" != typeof t[0]) for (n = t.length; --n > -1;)this._kill(e, t[n], i) && (l = !0); else { if (this._targets) { for (n = this._targets.length; --n > -1;)if (t === this._targets[n]) { o = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = e ? this._overwrittenProps[n] || {} : "all"; break } } else { if (t !== this.target) return !1; o = this._propLookup, r = this._overwrittenProps = e ? this._overwrittenProps || {} : "all" } if (o) { if (c = e || o, h = e !== r && "all" !== r && e !== o && ("object" != typeof e || !e._tempKill), i && (O.onOverwrite || this.vars.onOverwrite)) { for (a in c) o[a] && (u || (u = []), u.push(a)); if ((u || !e) && !Q(this, i, t, u)) return !1 } for (a in c) (s = o[a]) && (d && (s.f ? s.t[s.p](s.s) : s.t[s.p] = s.s, l = !0), s.pg && s.t._kill(c) && (l = !0), s.pg && 0 !== s.t._overwriteProps.length || (s._prev ? s._prev._next = s._next : s === this._firstPT && (this._firstPT = s._next), s._next && (s._next._prev = s._prev), s._next = s._prev = null), delete o[a]), h && (r[a] = 1); !this._firstPT && this._initted && p && this._enabled(!1, !1) } } return l }, s.invalidate = function () { this._notifyPluginsOfEnabled && O._onPluginEvent("_onDisable", this); var e = this._time; return this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], P.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-8, this.render(e, !1, !1 !== this.vars.lazy)), this }, s._enabled = function (e, t) { if (l || o.wake(), e && this._gc) { var i, n = this._targets; if (n) for (i = n.length; --i > -1;)this._siblings[i] = K(n[i], this, !0); else this._siblings = K(this.target, this, !0) } return P.prototype._enabled.call(this, e, t), !(!this._notifyPluginsOfEnabled || !this._firstPT) && O._onPluginEvent(e ? "_onEnable" : "_onDisable", this) }, O.to = function (e, t, i) { return new O(e, t, i) }, O.from = function (e, t, i) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new O(e, t, i) }, O.fromTo = function (e, t, i, n) { return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new O(e, t, n) }, O.delayedCall = function (e, t, i, n, r) { return new O(t, 0, { delay: e, onComplete: t, onCompleteParams: i, callbackScope: n, onReverseComplete: t, onReverseCompleteParams: i, immediateRender: !1, lazy: !1, useFrames: r, overwrite: 0 }) }, O.set = function (e, t) { return new O(e, 0, t) }, O.getTweensOf = function (e, t) { if (null == e) return []; var i, n, r, a; if (e = "string" != typeof e ? e : O.selector(e) || e, (m(e) || I(e)) && "number" != typeof e[0]) { for (i = e.length, n = []; --i > -1;)n = n.concat(O.getTweensOf(e[i], t)); for (i = n.length; --i > -1;)for (a = n[i], r = i; --r > -1;)a === n[r] && n.splice(i, 1) } else if (e._gsTweenID) for (i = (n = K(e).concat()).length; --i > -1;)(n[i]._gc || t && !n[i].isActive()) && n.splice(i, 1); return n || [] }, O.killTweensOf = O.killDelayedCallsTo = function (e, t, i) { "object" == typeof t && (i = t, t = !1); for (var n = O.getTweensOf(e, t), r = n.length; --r > -1;)n[r]._kill(i, e) }; var ie = _("plugins.TweenPlugin", (function (e, t) { this._overwriteProps = (e || "").split(","), this._propName = this._overwriteProps[0], this._priority = t || 0, this._super = ie.prototype }), !0); if (s = ie.prototype, ie.version = "1.19.0", ie.API = 2, s._firstPT = null, s._addTween = U, s.setRatio = B, s._kill = function (e) { var t, i = this._overwriteProps, n = this._firstPT; if (null != e[this._propName]) this._overwriteProps = []; else for (t = i.length; --t > -1;)null != e[i[t]] && i.splice(t, 1); for (; n;)null != e[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next; return !1 }, s._mod = s._roundProps = function (e) { for (var t, i = this._firstPT; i;)(t = e[this._propName] || null != i.n && e[i.n.split(this._propName + "_").join("")]) && "function" == typeof t && (2 === i.f ? i.t._applyPT.m = t : i.m = t), i = i._next }, O._onPluginEvent = function (e, t) { var i, n, r, a, s, o = t._firstPT; if ("_onInitAllProps" === e) { for (; o;) { for (s = o._next, n = r; n && n.pr > o.pr;)n = n._next; (o._prev = n ? n._prev : a) ? o._prev._next = o : r = o, (o._next = n) ? n._prev = o : a = o, o = s } o = t._firstPT = r } for (; o;)o.pg && "function" == typeof o.t[e] && o.t[e]() && (i = !0), o = o._next; return i }, ie.activate = function (e) { for (var t = e.length; --t > -1;)e[t].API === ie.API && (V[(new e[t])._propName] = e[t]); return !0 }, y.plugin = function (e) { if (!(e && e.propName && e.init && e.API)) throw "illegal plugin definition."; var t, i = e.propName, n = e.priority || 0, r = e.overwriteProps, a = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_mod", mod: "_mod", initAll: "_onInitAllProps" }, s = _("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", (function () { ie.call(this, i, n), this._overwriteProps = r || [] }), !0 === e.global), o = s.prototype = new ie(i); for (t in o.constructor = s, s.API = e.API, a) "function" == typeof e[t] && (o[a[t]] = e[t]); return s.version = e.version, ie.activate([s]), s }, r = e._gsQueue) { for (a = 0; a < r.length; a++)r[a](); for (s in g) g[s].func || e.console.log("GSAP encountered missing dependency: " + s) } return l = !1, O }(r), s = r.GreenSockGlobals, o = s.com.greensock, l = o.core.SimpleTimeline, c = o.core.Animation, h = s.Ease, u = s.Linear, d = u, p = s.Power1, f = s.Power2, m = s.Power3, g = s.Power4, v = s.TweenPlugin; o.events.EventDispatcher
    }).call(this, i(8)(e), i(9))
}, function (e, t, i) {
    var n, r;
/*!
 * ScrollMagic v2.0.7 (2019-05-07)
 * The javascript library for magical scroll interactions.
 * (c) 2019 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.7
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic main library.
 */void 0 === (r = "function" == typeof (n = function () { "use strict"; var e = function () { n.log(2, "(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use 'new ScrollMagic.Controller()' to create a new controller instance. Use 'new ScrollMagic.Scene()' to instance a scene.") }; e.version = "2.0.7", window.addEventListener("mousewheel", (function () { })), e.Controller = function (i) { var r, a, s = "ScrollMagic.Controller", o = t.defaults, l = this, c = n.extend({}, o, i), h = [], u = !1, d = 0, p = "PAUSED", f = !0, m = 0, g = !0, v = function () { c.refreshInterval > 0 && (a = window.setTimeout(M, c.refreshInterval)) }, y = function () { return c.vertical ? n.get.scrollTop(c.container) : n.get.scrollLeft(c.container) }, _ = function () { return c.vertical ? n.get.height(c.container) : n.get.width(c.container) }, x = this._setScrollPos = function (e) { c.vertical ? f ? window.scrollTo(n.get.scrollLeft(), e) : c.container.scrollTop = e : f ? window.scrollTo(e, n.get.scrollTop()) : c.container.scrollLeft = e }, b = function () { if (g && u) { var e = n.type.Array(u) ? u : h.slice(0); u = !1; var t = d, i = (d = l.scrollPos()) - t; 0 !== i && (p = i > 0 ? "FORWARD" : "REVERSE"), "REVERSE" === p && e.reverse(), e.forEach((function (t, i) { S(3, "updating Scene " + (i + 1) + "/" + e.length + " (" + h.length + " total)"), t.update(!0) })), 0 === e.length && c.loglevel >= 3 && S(3, "updating 0 Scenes (nothing added to controller)") } }, w = function () { r = n.rAF(b) }, T = function (e) { S(3, "event fired causing an update:", e.type), "resize" == e.type && (m = _(), p = "PAUSED"), !0 !== u && (u = !0, w()) }, M = function () { if (!f && m != _()) { var e; try { e = new Event("resize", { bubbles: !1, cancelable: !1 }) } catch (t) { (e = document.createEvent("Event")).initEvent("resize", !1, !1) } c.container.dispatchEvent(e) } h.forEach((function (e, t) { e.refresh() })), v() }, S = this._log = function (e, t) { c.loglevel >= e && (Array.prototype.splice.call(arguments, 1, 0, "(" + s + ") ->"), n.log.apply(window, arguments)) }; this._options = c; var E = function (e) { if (e.length <= 1) return e; var t = e.slice(0); return t.sort((function (e, t) { return e.scrollOffset() > t.scrollOffset() ? 1 : -1 })), t }; return this.addScene = function (t) { if (n.type.Array(t)) t.forEach((function (e, t) { l.addScene(e) })); else if (t instanceof e.Scene) { if (t.controller() !== l) t.addTo(l); else if (h.indexOf(t) < 0) { for (var i in h.push(t), h = E(h), t.on("shift.controller_sort", (function () { h = E(h) })), c.globalSceneOptions) t[i] && t[i].call(t, c.globalSceneOptions[i]); S(3, "adding Scene (now " + h.length + " total)") } } else S(1, "ERROR: invalid argument supplied for '.addScene()'"); return l }, this.removeScene = function (e) { if (n.type.Array(e)) e.forEach((function (e, t) { l.removeScene(e) })); else { var t = h.indexOf(e); t > -1 && (e.off("shift.controller_sort"), h.splice(t, 1), S(3, "removing Scene (now " + h.length + " left)"), e.remove()) } return l }, this.updateScene = function (t, i) { return n.type.Array(t) ? t.forEach((function (e, t) { l.updateScene(e, i) })) : i ? t.update(!0) : !0 !== u && t instanceof e.Scene && (-1 == (u = u || []).indexOf(t) && u.push(t), u = E(u), w()), l }, this.update = function (e) { return T({ type: "resize" }), e && b(), l }, this.scrollTo = function (t, i) { if (n.type.Number(t)) x.call(c.container, t, i); else if (t instanceof e.Scene) t.controller() === l ? l.scrollTo(t.scrollOffset(), i) : S(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", t); else if (n.type.Function(t)) x = t; else { var r = n.get.elements(t)[0]; if (r) { for (; r.parentNode.hasAttribute("data-scrollmagic-pin-spacer");)r = r.parentNode; var a = c.vertical ? "top" : "left", s = n.get.offset(c.container), o = n.get.offset(r); f || (s[a] -= l.scrollPos()), l.scrollTo(o[a] - s[a], i) } else S(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", t) } return l }, this.scrollPos = function (e) { return arguments.length ? (n.type.Function(e) ? y = e : S(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'."), l) : y.call(l) }, this.info = function (e) { var t = { size: m, vertical: c.vertical, scrollPos: d, scrollDirection: p, container: c.container, isDocument: f }; return arguments.length ? void 0 !== t[e] ? t[e] : void S(1, 'ERROR: option "' + e + '" is not available') : t }, this.loglevel = function (e) { return arguments.length ? (c.loglevel != e && (c.loglevel = e), l) : c.loglevel }, this.enabled = function (e) { return arguments.length ? (g != e && (g = !!e, l.updateScene(h, !0)), l) : g }, this.destroy = function (e) { window.clearTimeout(a); for (var t = h.length; t--;)h[t].destroy(e); return c.container.removeEventListener("resize", T), c.container.removeEventListener("scroll", T), n.cAF(r), S(3, "destroyed " + s + " (reset: " + (e ? "true" : "false") + ")"), null }, function () { for (var t in c) o.hasOwnProperty(t) || (S(2, 'WARNING: Unknown option "' + t + '"'), delete c[t]); if (c.container = n.get.elements(c.container)[0], !c.container) throw S(1, "ERROR creating object " + s + ": No valid scroll container supplied"), s + " init failed."; (f = c.container === window || c.container === document.body || !document.body.contains(c.container)) && (c.container = window), m = _(), c.container.addEventListener("resize", T), c.container.addEventListener("scroll", T); var i = parseInt(c.refreshInterval, 10); c.refreshInterval = n.type.Number(i) ? i : o.refreshInterval, v(), S(3, "added new " + s + " controller (v" + e.version + ")") }(), l }; var t = { defaults: { container: window, vertical: !0, globalSceneOptions: {}, loglevel: 2, refreshInterval: 100 } }; e.Controller.addOption = function (e, i) { t.defaults[e] = i }, e.Controller.extend = function (t) { var i = this; e.Controller = function () { return i.apply(this, arguments), this.$super = n.extend({}, this), t.apply(this, arguments) || this }, n.extend(e.Controller, i), e.Controller.prototype = i.prototype, e.Controller.prototype.constructor = e.Controller }, e.Scene = function (t) { var r, a, s = "ScrollMagic.Scene", o = i.defaults, l = this, c = n.extend({}, o, t), h = "BEFORE", u = 0, d = { start: 0, end: 0 }, p = 0, f = !0, m = {}; this.on = function (e, t) { return n.type.Function(t) ? (e = e.trim().split(" ")).forEach((function (e) { var i = e.split("."), n = i[0], r = i[1]; "*" != n && (m[n] || (m[n] = []), m[n].push({ namespace: r || "", callback: t })) })) : g(1, "ERROR when calling '.on()': Supplied callback for '" + e + "' is not a valid function!"), l }, this.off = function (e, t) { return e ? ((e = e.trim().split(" ")).forEach((function (e, i) { var n = e.split("."), r = n[0], a = n[1] || ""; ("*" === r ? Object.keys(m) : [r]).forEach((function (e) { for (var i = m[e] || [], n = i.length; n--;) { var r = i[n]; !r || a !== r.namespace && "*" !== a || t && t != r.callback || i.splice(n, 1) } i.length || delete m[e] })) })), l) : (g(1, "ERROR: Invalid event name supplied."), l) }, this.trigger = function (t, i) { if (t) { var n = t.trim().split("."), r = n[0], a = n[1], s = m[r]; g(3, "event fired:", r, i ? "->" : "", i || ""), s && s.forEach((function (t, n) { a && a !== t.namespace || t.callback.call(l, new e.Event(r, t.namespace, l, i)) })) } else g(1, "ERROR: Invalid event name supplied."); return l }, l.on("change.internal", (function (e) { "loglevel" !== e.what && "tweenChanges" !== e.what && ("triggerElement" === e.what ? b() : "reverse" === e.what && l.update()) })).on("shift.internal", (function (e) { _(), l.update() })); var g = this._log = function (e, t) { c.loglevel >= e && (Array.prototype.splice.call(arguments, 1, 0, "(" + s + ") ->"), n.log.apply(window, arguments)) }; this.addTo = function (t) { return t instanceof e.Controller ? a != t && (a && a.removeScene(l), a = t, M(), x(!0), b(!0), _(), a.info("container").addEventListener("resize", w), t.addScene(l), l.trigger("add", { controller: a }), g(3, "added " + s + " to controller"), l.update()) : g(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller"), l }, this.enabled = function (e) { return arguments.length ? (f != e && (f = !!e, l.update(!0)), l) : f }, this.remove = function () { if (a) { a.info("container").removeEventListener("resize", w); var e = a; a = void 0, e.removeScene(l), l.trigger("remove"), g(3, "removed " + s + " from controller") } return l }, this.destroy = function (e) { return l.trigger("destroy", { reset: e }), l.remove(), l.off("*.*"), g(3, "destroyed " + s + " (reset: " + (e ? "true" : "false") + ")"), null }, this.update = function (e) { if (a) if (e) if (a.enabled() && f) { var t, i = a.info("scrollPos"); t = c.duration > 0 ? (i - d.start) / (d.end - d.start) : i >= d.start ? 1 : 0, l.trigger("update", { startPos: d.start, endPos: d.end, scrollPos: i }), l.progress(t) } else v && "DURING" === h && C(!0); else a.updateScene(l, !1); return l }, this.refresh = function () { return x(), b(), l }, this.progress = function (e) { if (arguments.length) { var t = !1, i = h, n = a ? a.info("scrollDirection") : "PAUSED", r = c.reverse || e >= u; if (0 === c.duration ? (t = u != e, h = 0 == (u = e < 1 && r ? 0 : 1) ? "BEFORE" : "DURING") : e < 0 && "BEFORE" !== h && r ? (u = 0, h = "BEFORE", t = !0) : e >= 0 && e < 1 && r ? (u = e, h = "DURING", t = !0) : e >= 1 && "AFTER" !== h ? (u = 1, h = "AFTER", t = !0) : "DURING" !== h || r || C(), t) { var s = { progress: u, state: h, scrollDirection: n }, o = h != i, d = function (e) { l.trigger(e, s) }; o && "DURING" !== i && (d("enter"), d("BEFORE" === i ? "start" : "end")), d("progress"), o && "DURING" !== h && (d("BEFORE" === h ? "start" : "end"), d("leave")) } return l } return u }; var v, y, _ = function () { d = { start: p + c.offset }, a && c.triggerElement && (d.start -= a.info("size") * c.triggerHook), d.end = d.start + c.duration }, x = function (e) { r && S("duration", r.call(l)) && !e && (l.trigger("change", { what: "duration", newval: c.duration }), l.trigger("shift", { reason: "duration" })) }, b = function (e) { var t = 0, i = c.triggerElement; if (a && (i || p > 0)) { if (i) if (i.parentNode) { for (var r = a.info(), s = n.get.offset(r.container), o = r.vertical ? "top" : "left"; i.parentNode.hasAttribute("data-scrollmagic-pin-spacer");)i = i.parentNode; var h = n.get.offset(i); r.isDocument || (s[o] -= a.scrollPos()), t = h[o] - s[o] } else g(2, "WARNING: triggerElement was removed from DOM and will be reset to", void 0), l.triggerElement(void 0); var u = t != p; p = t, u && !e && l.trigger("shift", { reason: "triggerElementPosition" }) } }, w = function (e) { c.triggerHook > 0 && l.trigger("shift", { reason: "containerResize" }) }, T = n.extend(i.validate, { duration: function (e) { if (n.type.String(e) && e.match(/^(\.|\d)*\d+%$/)) { var t = parseFloat(e) / 100; e = function () { return a ? a.info("size") * t : 0 } } if (n.type.Function(e)) { r = e; try { e = parseFloat(r.call(l)) } catch (t) { e = -1 } } if (e = parseFloat(e), !n.type.Number(e) || e < 0) throw r ? (r = void 0, ['Invalid return value of supplied function for option "duration":', e]) : ['Invalid value for option "duration":', e]; return e } }), M = function (e) { (e = arguments.length ? [e] : Object.keys(T)).forEach((function (e, t) { var i; if (T[e]) try { i = T[e](c[e]) } catch (t) { i = o[e]; var r = n.type.String(t) ? [t] : t; n.type.Array(r) ? (r[0] = "ERROR: " + r[0], r.unshift(1), g.apply(this, r)) : g(1, "ERROR: Problem executing validation callback for option '" + e + "':", t.message) } finally { c[e] = i } })) }, S = function (e, t) { var i = !1, n = c[e]; return c[e] != t && (c[e] = t, M(e), i = n != c[e]), i }, E = function (e) { l[e] || (l[e] = function (t) { return arguments.length ? ("duration" === e && (r = void 0), S(e, t) && (l.trigger("change", { what: e, newval: c[e] }), i.shifts.indexOf(e) > -1 && l.trigger("shift", { reason: e })), l) : c[e] }) }; this.controller = function () { return a }, this.state = function () { return h }, this.scrollOffset = function () { return d.start }, this.triggerPosition = function () { var e = c.offset; return a && (c.triggerElement ? e += p : e += a.info("size") * l.triggerHook()), e }, l.on("shift.internal", (function (e) { var t = "duration" === e.reason; ("AFTER" === h && t || "DURING" === h && 0 === c.duration) && C(), t && A() })).on("progress.internal", (function (e) { C() })).on("add.internal", (function (e) { A() })).on("destroy.internal", (function (e) { l.removePin(e.reset) })); var C = function (e) { if (v && a) { var t = a.info(), i = y.spacer.firstChild; if (e || "DURING" !== h) { var r = { position: y.inFlow ? "relative" : "absolute", top: 0, left: 0 }, s = n.css(i, "position") != r.position; y.pushFollowers ? c.duration > 0 && ("AFTER" === h && 0 === parseFloat(n.css(y.spacer, "padding-top")) || "BEFORE" === h && 0 === parseFloat(n.css(y.spacer, "padding-bottom"))) && (s = !0) : r[t.vertical ? "top" : "left"] = c.duration * u, n.css(i, r), s && A() } else { "fixed" != n.css(i, "position") && (n.css(i, { position: "fixed" }), A()); var o = n.get.offset(y.spacer, !0), l = c.reverse || 0 === c.duration ? t.scrollPos - d.start : Math.round(u * c.duration * 10) / 10; o[t.vertical ? "top" : "left"] += l, n.css(y.spacer.firstChild, { top: o.top, left: o.left }) } } }, A = function () { if (v && a && y.inFlow) { var e = "DURING" === h, t = a.info("vertical"), i = y.spacer.firstChild, r = n.isMarginCollapseType(n.css(y.spacer, "display")), s = {}; y.relSize.width || y.relSize.autoFullWidth ? e ? n.css(v, { width: n.get.width(y.spacer) }) : n.css(v, { width: "100%" }) : (s["min-width"] = n.get.width(t ? v : i, !0, !0), s.width = e ? s["min-width"] : "auto"), y.relSize.height ? e ? n.css(v, { height: n.get.height(y.spacer) - (y.pushFollowers ? c.duration : 0) }) : n.css(v, { height: "100%" }) : (s["min-height"] = n.get.height(t ? i : v, !0, !r), s.height = e ? s["min-height"] : "auto"), y.pushFollowers && (s["padding" + (t ? "Top" : "Left")] = c.duration * u, s["padding" + (t ? "Bottom" : "Right")] = c.duration * (1 - u)), n.css(y.spacer, s) } }, P = function () { a && v && "DURING" === h && !a.info("isDocument") && C() }, L = function () { a && v && "DURING" === h && ((y.relSize.width || y.relSize.autoFullWidth) && n.get.width(window) != n.get.width(y.spacer.parentNode) || y.relSize.height && n.get.height(window) != n.get.height(y.spacer.parentNode)) && A() }, R = function (e) { a && v && "DURING" === h && !a.info("isDocument") && (e.preventDefault(), a._setScrollPos(a.info("scrollPos") - ((e.wheelDelta || e[a.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || 30 * -e.detail))) }; this.setPin = function (e, t) { var i = t && t.hasOwnProperty("pushFollowers"); if (t = n.extend({}, { pushFollowers: !0, spacerClass: "scrollmagic-pin-spacer" }, t), !(e = n.get.elements(e)[0])) return g(1, "ERROR calling method 'setPin()': Invalid pin element supplied."), l; if ("fixed" === n.css(e, "position")) return g(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'."), l; if (v) { if (v === e) return l; l.removePin() } var r = (v = e).parentNode.style.display, a = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"]; v.parentNode.style.display = "none"; var s = "absolute" != n.css(v, "position"), o = n.css(v, a.concat(["display"])), h = n.css(v, ["width", "height"]); v.parentNode.style.display = r, !s && t.pushFollowers && (g(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled."), t.pushFollowers = !1), window.setTimeout((function () { v && 0 === c.duration && i && t.pushFollowers && g(2, "WARNING: pushFollowers =", !0, "has no effect, when scene duration is 0.") }), 0); var u = v.parentNode.insertBefore(document.createElement("div"), v), d = n.extend(o, { position: s ? "relative" : "absolute", boxSizing: "content-box", mozBoxSizing: "content-box", webkitBoxSizing: "content-box" }); if (s || n.extend(d, n.css(v, ["width", "height"])), n.css(u, d), u.setAttribute("data-scrollmagic-pin-spacer", ""), n.addClass(u, t.spacerClass), y = { spacer: u, relSize: { width: "%" === h.width.slice(-1), height: "%" === h.height.slice(-1), autoFullWidth: "auto" === h.width && s && n.isMarginCollapseType(o.display) }, pushFollowers: t.pushFollowers, inFlow: s }, !v.___origStyle) { v.___origStyle = {}; var p = v.style; a.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]).forEach((function (e) { v.___origStyle[e] = p[e] || "" })) } return y.relSize.width && n.css(u, { width: h.width }), y.relSize.height && n.css(u, { height: h.height }), u.appendChild(v), n.css(v, { position: s ? "relative" : "absolute", margin: "auto", top: "auto", left: "auto", bottom: "auto", right: "auto" }), (y.relSize.width || y.relSize.autoFullWidth) && n.css(v, { boxSizing: "border-box", mozBoxSizing: "border-box", webkitBoxSizing: "border-box" }), window.addEventListener("scroll", P), window.addEventListener("resize", P), window.addEventListener("resize", L), v.addEventListener("mousewheel", R), v.addEventListener("DOMMouseScroll", R), g(3, "added pin"), C(), l }, this.removePin = function (e) { if (v) { if ("DURING" === h && C(!0), e || !a) { var t = y.spacer.firstChild; if (t.hasAttribute("data-scrollmagic-pin-spacer")) { var i = y.spacer.style, r = {};["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"].forEach((function (e) { r[e] = i[e] || "" })), n.css(t, r) } y.spacer.parentNode.insertBefore(t, y.spacer), y.spacer.parentNode.removeChild(y.spacer), v.parentNode.hasAttribute("data-scrollmagic-pin-spacer") || (n.css(v, v.___origStyle), delete v.___origStyle) } window.removeEventListener("scroll", P), window.removeEventListener("resize", P), window.removeEventListener("resize", L), v.removeEventListener("mousewheel", R), v.removeEventListener("DOMMouseScroll", R), v = void 0, g(3, "removed pin (reset: " + (e ? "true" : "false") + ")") } return l }; var O, I = []; return l.on("destroy.internal", (function (e) { l.removeClassToggle(e.reset) })), this.setClassToggle = function (e, t) { var i = n.get.elements(e); return 0 !== i.length && n.type.String(t) ? (I.length > 0 && l.removeClassToggle(), O = t, I = i, l.on("enter.internal_class leave.internal_class", (function (e) { var t = "enter" === e.type ? n.addClass : n.removeClass; I.forEach((function (e, i) { t(e, O) })) })), l) : (g(1, "ERROR calling method 'setClassToggle()': Invalid " + (0 === i.length ? "element" : "classes") + " supplied."), l) }, this.removeClassToggle = function (e) { return e && I.forEach((function (e, t) { n.removeClass(e, O) })), l.off("start.internal_class end.internal_class"), O = void 0, I = [], l }, function () { for (var e in c) o.hasOwnProperty(e) || (g(2, 'WARNING: Unknown option "' + e + '"'), delete c[e]); for (var t in o) E(t); M() }(), l }; var i = { defaults: { duration: 0, offset: 0, triggerElement: void 0, triggerHook: .5, reverse: !0, loglevel: 2 }, validate: { offset: function (e) { if (e = parseFloat(e), !n.type.Number(e)) throw ['Invalid value for option "offset":', e]; return e }, triggerElement: function (e) { if (e = e || void 0) { var t = n.get.elements(e)[0]; if (!t || !t.parentNode) throw ['Element defined in option "triggerElement" was not found:', e]; e = t } return e }, triggerHook: function (e) { var t = { onCenter: .5, onEnter: 1, onLeave: 0 }; if (n.type.Number(e)) e = Math.max(0, Math.min(parseFloat(e), 1)); else { if (!(e in t)) throw ['Invalid value for option "triggerHook": ', e]; e = t[e] } return e }, reverse: function (e) { return !!e }, loglevel: function (e) { if (e = parseInt(e), !n.type.Number(e) || e < 0 || e > 3) throw ['Invalid value for option "loglevel":', e]; return e } }, shifts: ["duration", "offset", "triggerHook"] }; e.Scene.addOption = function (t, n, r, a) { t in i.defaults ? e._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + t + "', because it already exists.") : (i.defaults[t] = n, i.validate[t] = r, a && i.shifts.push(t)) }, e.Scene.extend = function (t) { var i = this; e.Scene = function () { return i.apply(this, arguments), this.$super = n.extend({}, this), t.apply(this, arguments) || this }, n.extend(e.Scene, i), e.Scene.prototype = i.prototype, e.Scene.prototype.constructor = e.Scene }, e.Event = function (e, t, i, n) { for (var r in n = n || {}) this[r] = n[r]; return this.type = e, this.target = this.currentTarget = i, this.namespace = t || "", this.timeStamp = this.timestamp = Date.now(), this }; var n = e._util = function (e) { var t, i = {}, n = function (e) { return parseFloat(e) || 0 }, r = function (t) { return t.currentStyle ? t.currentStyle : e.getComputedStyle(t) }, a = function (t, i, a, s) { if ((i = i === document ? e : i) === e) s = !1; else if (!f.DomElement(i)) return 0; t = t.charAt(0).toUpperCase() + t.substr(1).toLowerCase(); var o = (a ? i["offset" + t] || i["outer" + t] : i["client" + t] || i["inner" + t]) || 0; if (a && s) { var l = r(i); o += "Height" === t ? n(l.marginTop) + n(l.marginBottom) : n(l.marginLeft) + n(l.marginRight) } return o }, s = function (e) { return e.replace(/^[^a-z]+([a-z])/g, "$1").replace(/-([a-z])/g, (function (e) { return e[1].toUpperCase() })) }; i.extend = function (e) { for (e = e || {}, t = 1; t < arguments.length; t++)if (arguments[t]) for (var i in arguments[t]) arguments[t].hasOwnProperty(i) && (e[i] = arguments[t][i]); return e }, i.isMarginCollapseType = function (e) { return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(e) > -1 }; var o = 0, l = ["ms", "moz", "webkit", "o"], c = e.requestAnimationFrame, h = e.cancelAnimationFrame; for (t = 0; !c && t < l.length; ++t)c = e[l[t] + "RequestAnimationFrame"], h = e[l[t] + "CancelAnimationFrame"] || e[l[t] + "CancelRequestAnimationFrame"]; c || (c = function (t) { var i = (new Date).getTime(), n = Math.max(0, 16 - (i - o)), r = e.setTimeout((function () { t(i + n) }), n); return o = i + n, r }), h || (h = function (t) { e.clearTimeout(t) }), i.rAF = c.bind(e), i.cAF = h.bind(e); var u = ["error", "warn", "log"], d = e.console || {}; for (d.log = d.log || function () { }, t = 0; t < u.length; t++) { var p = u[t]; d[p] || (d[p] = d.log) } i.log = function (e) { (e > u.length || e <= 0) && (e = u.length); var t = new Date, i = ("0" + t.getHours()).slice(-2) + ":" + ("0" + t.getMinutes()).slice(-2) + ":" + ("0" + t.getSeconds()).slice(-2) + ":" + ("00" + t.getMilliseconds()).slice(-3), n = u[e - 1], r = Array.prototype.splice.call(arguments, 1), a = Function.prototype.bind.call(d[n], d); r.unshift(i), a.apply(d, r) }; var f = i.type = function (e) { return Object.prototype.toString.call(e).replace(/^\[object (.+)\]$/, "$1").toLowerCase() }; f.String = function (e) { return "string" === f(e) }, f.Function = function (e) { return "function" === f(e) }, f.Array = function (e) { return Array.isArray(e) }, f.Number = function (e) { return !f.Array(e) && e - parseFloat(e) + 1 >= 0 }, f.DomElement = function (e) { return "object" == typeof HTMLElement || "function" == typeof HTMLElement ? e instanceof HTMLElement || e instanceof SVGElement : e && "object" == typeof e && null !== e && 1 === e.nodeType && "string" == typeof e.nodeName }; var m = i.get = {}; return m.elements = function (t) { var i = []; if (f.String(t)) try { t = document.querySelectorAll(t) } catch (e) { return i } if ("nodelist" === f(t) || f.Array(t) || t instanceof NodeList) for (var n = 0, r = i.length = t.length; n < r; n++) { var a = t[n]; i[n] = f.DomElement(a) ? a : m.elements(a) } else (f.DomElement(t) || t === document || t === e) && (i = [t]); return i }, m.scrollTop = function (t) { return t && "number" == typeof t.scrollTop ? t.scrollTop : e.pageYOffset || 0 }, m.scrollLeft = function (t) { return t && "number" == typeof t.scrollLeft ? t.scrollLeft : e.pageXOffset || 0 }, m.width = function (e, t, i) { return a("width", e, t, i) }, m.height = function (e, t, i) { return a("height", e, t, i) }, m.offset = function (e, t) { var i = { top: 0, left: 0 }; if (e && e.getBoundingClientRect) { var n = e.getBoundingClientRect(); i.top = n.top, i.left = n.left, t || (i.top += m.scrollTop(), i.left += m.scrollLeft()) } return i }, i.addClass = function (e, t) { t && (e.classList ? e.classList.add(t) : e.className += " " + t) }, i.removeClass = function (e, t) { t && (e.classList ? e.classList.remove(t) : e.className = e.className.replace(new RegExp("(^|\\b)" + t.split(" ").join("|") + "(\\b|$)", "gi"), " ")) }, i.css = function (e, t) { if (f.String(t)) return r(e)[s(t)]; if (f.Array(t)) { var i = {}, n = r(e); return t.forEach((function (e, t) { i[e] = n[s(e)] })), i } for (var a in t) { var o = t[a]; o == parseFloat(o) && (o += "px"), e.style[s(a)] = o } }, i }(window || {}); return e.Scene.prototype.addIndicators = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin 'debug.addIndicators'. Please make sure to include plugins/debug.addIndicators.js"), this }, e.Scene.prototype.removeIndicators = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin 'debug.addIndicators'. Please make sure to include plugins/debug.addIndicators.js"), this }, e.Scene.prototype.setTween = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin 'animation.gsap'. Please make sure to include plugins/animation.gsap.js"), this }, e.Scene.prototype.removeTween = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin 'animation.gsap'. Please make sure to include plugins/animation.gsap.js"), this }, e.Scene.prototype.setVelocity = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin 'animation.velocity'. Please make sure to include plugins/animation.velocity.js"), this }, e.Scene.prototype.removeVelocity = function () { return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin 'animation.velocity'. Please make sure to include plugins/animation.velocity.js"), this }, e }) ? n.call(t, i, t, e) : n) || (e.exports = r)
}, function (e, t, i) {
    "use strict"; i.d(t, "a", (function () { return r })); var n = i(0);
/*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */n.k._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], (function () { var e = function (e) { n.i.call(this, e); var t, i, r = this.vars; for (i in this._labels = {}, this.autoRemoveChildren = !!r.autoRemoveChildren, this.smoothChildTiming = !!r.smoothChildTiming, this._sortChildren = !0, this._onUpdate = r.onUpdate, r) t = r[i], a(t) && -1 !== t.join("").indexOf("{self}") && (r[i] = this._swapSelfInParams(t)); a(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger) }, t = n.l._internals, i = e._internals = {}, r = t.isSelector, a = t.isArray, s = t.lazyTweens, o = t.lazyRender, l = n.k._gsDefine.globals, c = function (e) { var t, i = {}; for (t in e) i[t] = e[t]; return i }, h = function (e, t, i) { var n, r, a = e.cycle; for (n in a) r = a[n], e[n] = "function" == typeof r ? r(i, t[i], t) : r[i % r.length]; delete e.cycle }, u = i.pauseCallback = function () { }, d = function (e, t, i, n) { var r = "immediateRender"; return r in t || (t[r] = !(i && !1 === i[r] || n)), t }, p = function (e) { if ("function" == typeof e) return e; var t = "object" == typeof e ? e : { each: e }, i = t.ease, n = t.from || 0, r = t.base || 0, a = {}, s = isNaN(n), o = t.axis, l = { center: .5, end: 1 }[n] || 0; return function (e, c, h) { var u, d, p, f, m, g, v, y, _, x = (h || t).length, b = a[x]; if (!b) { if (!(_ = "auto" === t.grid ? 0 : (t.grid || [1 / 0])[0])) { for (v = -1 / 0; v < (v = h[_++].getBoundingClientRect().left) && _ < x;); _-- } for (b = a[x] = [], u = s ? Math.min(_, x) * l - .5 : n % _, d = s ? x * l / _ - .5 : n / _ | 0, v = 0, y = 1 / 0, g = 0; g < x; g++)p = g % _ - u, f = d - (g / _ | 0), b[g] = m = o ? Math.abs("y" === o ? f : p) : Math.sqrt(p * p + f * f), m > v && (v = m), m < y && (y = m); b.max = v - y, b.min = y, b.v = x = t.amount || t.each * (_ > x ? x - 1 : o ? "y" === o ? x / _ : _ : Math.max(_, x / _)) || 0, b.b = x < 0 ? r - x : r } return x = (b[e] - b.min) / b.max, b.b + (i ? i.getRatio(x) : x) * b.v } }, f = e.prototype = new n.i; return e.version = "2.1.3", e.distribute = p, f.constructor = e, f.kill()._gc = f._forcingPlayhead = f._hasPause = !1, f.to = function (e, t, i, r) { var a = i.repeat && l.TweenMax || n.l; return t ? this.add(new a(e, t, i), r) : this.set(e, i, r) }, f.from = function (e, t, i, r) { return this.add((i.repeat && l.TweenMax || n.l).from(e, t, d(0, i)), r) }, f.fromTo = function (e, t, i, r, a) { var s = r.repeat && l.TweenMax || n.l; return r = d(0, r, i), t ? this.add(s.fromTo(e, t, i, r), a) : this.set(e, r, a) }, f.staggerTo = function (t, i, a, s, o, l, u, d) { var f, m, g = new e({ onComplete: l, onCompleteParams: u, callbackScope: d, smoothChildTiming: this.smoothChildTiming }), v = p(a.stagger || s), y = a.startAt, _ = a.cycle; for ("string" == typeof t && (t = n.l.selector(t) || t), r(t = t || []) && (t = function (e) { var t, i = [], n = e.length; for (t = 0; t !== n; i.push(e[t++])); return i }(t)), m = 0; m < t.length; m++)f = c(a), y && (f.startAt = c(y), y.cycle && h(f.startAt, t, m)), _ && (h(f, t, m), null != f.duration && (i = f.duration, delete f.duration)), g.to(t[m], i, f, v(m, t[m], t)); return this.add(g, o) }, f.staggerFrom = function (e, t, i, n, r, a, s, o) { return i.runBackwards = !0, this.staggerTo(e, t, d(0, i), n, r, a, s, o) }, f.staggerFromTo = function (e, t, i, n, r, a, s, o, l) { return n.startAt = i, this.staggerTo(e, t, d(0, n, i), r, a, s, o, l) }, f.call = function (e, t, i, r) { return this.add(n.l.delayedCall(0, e, t, i), r) }, f.set = function (e, t, i) { return this.add(new n.l(e, 0, d(0, t, null, !0)), i) }, e.exportRoot = function (t, i) { null == (t = t || {}).smoothChildTiming && (t.smoothChildTiming = !0); var r, a, s, o, l = new e(t), c = l._timeline; for (null == i && (i = !0), c._remove(l, !0), l._startTime = 0, l._rawPrevTime = l._time = l._totalTime = c._time, s = c._first; s;)o = s._next, i && s instanceof n.l && s.target === s.vars.onComplete || ((a = s._startTime - s._delay) < 0 && (r = 1), l.add(s, a)), s = o; return c.add(l, 0), r && l.totalDuration(), l }, f.add = function (t, i, r, s) { var o, l, c, h, u, d; if ("number" != typeof i && (i = this._parseTimeOrLabel(i, 0, !0, t)), !(t instanceof n.a)) { if (t instanceof Array || t && t.push && a(t)) { for (r = r || "normal", s = s || 0, o = i, l = t.length, c = 0; c < l; c++)a(h = t[c]) && (h = new e({ tweens: h })), this.add(h, o), "string" != typeof h && "function" != typeof h && ("sequence" === r ? o = h._startTime + h.totalDuration() / h._timeScale : "start" === r && (h._startTime -= h.delay())), o += s; return this._uncache(!0) } if ("string" == typeof t) return this.addLabel(t, i); if ("function" != typeof t) throw "Cannot add " + t + " into the timeline; it is not a tween, timeline, function, or string."; t = n.l.delayedCall(0, t) } if (n.i.prototype.add.call(this, t, i), (t._time || !t._duration && t._initted) && (o = (this.rawTime() - t._startTime) * t._timeScale, (!t._duration || Math.abs(Math.max(0, Math.min(t.totalDuration(), o))) - t._totalTime > 1e-5) && t.render(o, !1, !1)), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()) for (d = (u = this).rawTime() > t._startTime; u._timeline;)d && u._timeline.smoothChildTiming ? u.totalTime(u._totalTime, !0) : u._gc && u._enabled(!0, !1), u = u._timeline; return this }, f.remove = function (e) { if (e instanceof n.a) { this._remove(e, !1); var t = e._timeline = e.vars.useFrames ? n.a._rootFramesTimeline : n.a._rootTimeline; return e._startTime = (e._paused ? e._pauseTime : t._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this } if (e instanceof Array || e && e.push && a(e)) { for (var i = e.length; --i > -1;)this.remove(e[i]); return this } return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e) }, f._remove = function (e, t) { return n.i.prototype._remove.call(this, e, t), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this }, f.append = function (e, t) { return this.add(e, this._parseTimeOrLabel(null, t, !0, e)) }, f.insert = f.insertMultiple = function (e, t, i, n) { return this.add(e, t || 0, i, n) }, f.appendMultiple = function (e, t, i, n) { return this.add(e, this._parseTimeOrLabel(null, t, !0, e), i, n) }, f.addLabel = function (e, t) { return this._labels[e] = this._parseTimeOrLabel(t), this }, f.addPause = function (e, t, i, r) { var a = n.l.delayedCall(0, u, i, r || this); return a.vars.onComplete = a.vars.onReverseComplete = t, a.data = "isPause", this._hasPause = !0, this.add(a, e) }, f.removeLabel = function (e) { return delete this._labels[e], this }, f.getLabelTime = function (e) { return null != this._labels[e] ? this._labels[e] : -1 }, f._parseTimeOrLabel = function (e, t, i, r) { var s, o; if (r instanceof n.a && r.timeline === this) this.remove(r); else if (r && (r instanceof Array || r.push && a(r))) for (o = r.length; --o > -1;)r[o] instanceof n.a && r[o].timeline === this && this.remove(r[o]); if (s = "number" != typeof e || t ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof t) return this._parseTimeOrLabel(t, i && "number" == typeof e && null == this._labels[t] ? e - s : 0, i); if (t = t || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = s); else { if (-1 === (o = e.indexOf("="))) return null == this._labels[e] ? i ? this._labels[e] = s + t : t : this._labels[e] + t; t = parseInt(e.charAt(o - 1) + "1", 10) * Number(e.substr(o + 1)), e = o > 1 ? this._parseTimeOrLabel(e.substr(0, o - 1), 0, i) : s } return Number(e) + t }, f.seek = function (e, t) { return this.totalTime("number" == typeof e ? e : this._parseTimeOrLabel(e), !1 !== t) }, f.stop = function () { return this.paused(!0) }, f.gotoAndPlay = function (e, t) { return this.play(e, t) }, f.gotoAndStop = function (e, t) { return this.pause(e, t) }, f.render = function (e, t, i) { this._gc && this._enabled(!0, !1); var n, r, a, l, c, h, u, d, p = this._time, f = this._dirty ? this.totalDuration() : this._totalDuration, m = this._startTime, g = this._timeScale, v = this._paused; if (p !== this._time && (e += this._time - p), this._hasPause && !this._forcingPlayhead && !t) { if (e > p) for (n = this._first; n && n._startTime <= e && !h;)n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === this._rawPrevTime || (h = n), n = n._next; else for (n = this._last; n && n._startTime >= e && !h;)n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (h = n), n = n._prev; h && (this._time = this._totalTime = e = h._startTime, d = this._startTime + (this._reversed ? this._duration - e : e) / this._timeScale) } if (e >= f - 1e-8 && e >= 0) this._totalTime = this._time = f, this._reversed || this._hasPausedChild() || (r = !0, l = "onComplete", c = !!this._timeline.autoRemoveChildren, 0 === this._duration && (e <= 0 && e >= -1e-8 || this._rawPrevTime < 0 || 1e-8 === this._rawPrevTime) && this._rawPrevTime !== e && this._first && (c = !0, this._rawPrevTime > 1e-8 && (l = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : 1e-8, e = f + 1e-4; else if (e < 1e-8) if (this._totalTime = this._time = 0, e > -1e-8 && (e = 0), (0 !== p || 0 === this._duration && 1e-8 !== this._rawPrevTime && (this._rawPrevTime > 0 || e < 0 && this._rawPrevTime >= 0)) && (l = "onReverseComplete", r = this._reversed), e < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (c = r = !0, l = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (c = !0), this._rawPrevTime = e; else { if (this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : 1e-8, 0 === e && r) for (n = this._first; n && 0 === n._startTime;)n._duration || (r = !1), n = n._next; e = 0, this._initted || (c = !0) } else this._totalTime = this._time = this._rawPrevTime = e; if (this._time !== p && this._first || i || c || h) { if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== p && e > 0 && (this._active = !0), 0 === p && this.vars.onStart && (0 === this._time && this._duration || t || this._callback("onStart")), (u = this._time) >= p) for (n = this._first; n && (a = n._next, u === this._time && (!this._paused || v));)(n._active || n._startTime <= u && !n._paused && !n._gc) && (h === n && (this.pause(), this._pauseTime = d), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (e - n._startTime) * n._timeScale, t, i) : n.render((e - n._startTime) * n._timeScale, t, i)), n = a; else for (n = this._last; n && (a = n._prev, u === this._time && (!this._paused || v));) { if (n._active || n._startTime <= p && !n._paused && !n._gc) { if (h === n) { for (h = n._prev; h && h.endTime() > this._time;)h.render(h._reversed ? h.totalDuration() - (e - h._startTime) * h._timeScale : (e - h._startTime) * h._timeScale, t, i), h = h._prev; h = null, this.pause(), this._pauseTime = d } n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (e - n._startTime) * n._timeScale, t, i) : n.render((e - n._startTime) * n._timeScale, t, i) } n = a } this._onUpdate && (t || (s.length && o(), this._callback("onUpdate"))), l && (this._gc || m !== this._startTime && g === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (r && (s.length && o(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[l] && this._callback(l))) } }, f._hasPausedChild = function () { for (var t = this._first; t;) { if (t._paused || t instanceof e && t._hasPausedChild()) return !0; t = t._next } return !1 }, f.getChildren = function (e, t, i, r) { r = r || -9999999999; for (var a = [], s = this._first, o = 0; s;)s._startTime < r || (s instanceof n.l ? !1 !== t && (a[o++] = s) : (!1 !== i && (a[o++] = s), !1 !== e && (o = (a = a.concat(s.getChildren(!0, t, i))).length))), s = s._next; return a }, f.getTweensOf = function (e, t) { var i, r, a = this._gc, s = [], o = 0; for (a && this._enabled(!0, !0), r = (i = n.l.getTweensOf(e)).length; --r > -1;)(i[r].timeline === this || t && this._contains(i[r])) && (s[o++] = i[r]); return a && this._enabled(!1, !0), s }, f.recent = function () { return this._recent }, f._contains = function (e) { for (var t = e.timeline; t;) { if (t === this) return !0; t = t.timeline } return !1 }, f.shiftChildren = function (e, t, i) { i = i || 0; for (var n, r = this._first, a = this._labels; r;)r._startTime >= i && (r._startTime += e), r = r._next; if (t) for (n in a) a[n] >= i && (a[n] += e); return this._uncache(!0) }, f._kill = function (e, t) { if (!e && !t) return this._enabled(!1, !1); for (var i = t ? this.getTweensOf(t) : this.getChildren(!0, !0, !1), n = i.length, r = !1; --n > -1;)i[n]._kill(e, t) && (r = !0); return r }, f.clear = function (e) { var t = this.getChildren(!1, !0, !0), i = t.length; for (this._time = this._totalTime = 0; --i > -1;)t[i]._enabled(!1, !1); return !1 !== e && (this._labels = {}), this._uncache(!0) }, f.invalidate = function () { for (var e = this._first; e;)e.invalidate(), e = e._next; return n.a.prototype.invalidate.call(this) }, f._enabled = function (e, t) { if (e === this._gc) for (var i = this._first; i;)i._enabled(e, !0), i = i._next; return n.i.prototype._enabled.call(this, e, t) }, f.totalTime = function (e, t, i) { this._forcingPlayhead = !0; var r = n.a.prototype.totalTime.apply(this, arguments); return this._forcingPlayhead = !1, r }, f.duration = function (e) { return arguments.length ? (0 !== this.duration() && 0 !== e && this.timeScale(this._duration / e), this) : (this._dirty && this.totalDuration(), this._duration) }, f.totalDuration = function (e) { if (!arguments.length) { if (this._dirty) { for (var t, i, n = 0, r = this, a = r._last, s = 999999999999; a;)t = a._prev, a._dirty && a.totalDuration(), a._startTime > s && r._sortChildren && !a._paused && !r._calculatingDuration ? (r._calculatingDuration = 1, r.add(a, a._startTime - a._delay), r._calculatingDuration = 0) : s = a._startTime, a._startTime < 0 && !a._paused && (n -= a._startTime, r._timeline.smoothChildTiming && (r._startTime += a._startTime / r._timeScale, r._time -= a._startTime, r._totalTime -= a._startTime, r._rawPrevTime -= a._startTime), r.shiftChildren(-a._startTime, !1, -9999999999), s = 0), (i = a._startTime + a._totalDuration / a._timeScale) > n && (n = i), a = t; r._duration = r._totalDuration = n, r._dirty = !1 } return this._totalDuration } return e && this.totalDuration() ? this.timeScale(this._totalDuration / e) : this }, f.paused = function (e) { if (!1 === e && this._paused) for (var t = this._first; t;)t._startTime === this._time && "isPause" === t.data && (t._rawPrevTime = 0), t = t._next; return n.a.prototype.paused.apply(this, arguments) }, f.usesFrames = function () { for (var e = this._timeline; e._timeline;)e = e._timeline; return e === n.a._rootFramesTimeline }, f.rawTime = function (e) { return e && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(e) - this._startTime) * this._timeScale }, e }), !0); var r = n.m.TimelineLite
}, function (e, t, i) {
    "use strict"; i.d(t, "a", (function () { return a })); var n = i(0), r = i(2);
    /*!
     * VERSION: 2.1.3
     * DATE: 2019-05-17
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     */
    n.k._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], (function () { var e = function (e) { r.a.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !!this.vars.yoyo, this._dirty = !0 }, t = n.l._internals, i = t.lazyTweens, a = t.lazyRender, s = n.k._gsDefine.globals, o = new n.b(null, null, 1, 0), l = e.prototype = new r.a; return l.constructor = e, l.kill()._gc = !1, e.version = "2.1.3", l.invalidate = function () { return this._yoyo = !!this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), r.a.prototype.invalidate.call(this) }, l.addCallback = function (e, t, i, r) { return this.add(n.l.delayedCall(0, e, i, r), t) }, l.removeCallback = function (e, t) { if (e) if (null == t) this._kill(null, e); else for (var i = this.getTweensOf(e, !1), n = i.length, r = this._parseTimeOrLabel(t); --n > -1;)i[n]._startTime === r && i[n]._enabled(!1, !1); return this }, l.removePause = function (e) { return this.removeCallback(r.a._internals.pauseCallback, e) }, l.tweenTo = function (e, t) { t = t || {}; var i, r, a, l = { ease: o, useFrames: this.usesFrames(), immediateRender: !1, lazy: !1 }, c = t.repeat && s.TweenMax || n.l; for (r in t) l[r] = t[r]; return l.time = this._parseTimeOrLabel(e), i = Math.abs(Number(l.time) - this._time) / this._timeScale || .001, a = new c(this, i, l), l.onStart = function () { a.target.paused(!0), a.vars.time === a.target.time() || i !== a.duration() || a.isFromTo || a.duration(Math.abs(a.vars.time - a.target.time()) / a.target._timeScale).render(a.time(), !0, !0), t.onStart && t.onStart.apply(t.onStartScope || t.callbackScope || a, t.onStartParams || []) }, a }, l.tweenFromTo = function (e, t, i) { i = i || {}, e = this._parseTimeOrLabel(e), i.startAt = { onComplete: this.seek, onCompleteParams: [e], callbackScope: this }, i.immediateRender = !1 !== i.immediateRender; var n = this.tweenTo(t, i); return n.isFromTo = 1, n.duration(Math.abs(n.vars.time - e) / this._timeScale || .001) }, l.render = function (e, t, n) { this._gc && this._enabled(!0, !1); var r, s, o, l, c, h, u, d, p, f = this._time, m = this._dirty ? this.totalDuration() : this._totalDuration, g = this._duration, v = this._totalTime, y = this._startTime, _ = this._timeScale, x = this._rawPrevTime, b = this._paused, w = this._cycle; if (f !== this._time && (e += this._time - f), e >= m - 1e-8 && e >= 0) this._locked || (this._totalTime = m, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (s = !0, l = "onComplete", c = !!this._timeline.autoRemoveChildren, 0 === this._duration && (e <= 0 && e >= -1e-8 || x < 0 || 1e-8 === x) && x !== e && this._first && (c = !0, x > 1e-8 && (l = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : 1e-8, this._yoyo && 1 & this._cycle ? this._time = e = 0 : (this._time = g, e = g + 1e-4); else if (e < 1e-8) if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, e > -1e-8 && (e = 0), (0 !== f || 0 === g && 1e-8 !== x && (x > 0 || e < 0 && x >= 0) && !this._locked) && (l = "onReverseComplete", s = this._reversed), e < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (c = s = !0, l = "onReverseComplete") : x >= 0 && this._first && (c = !0), this._rawPrevTime = e; else { if (this._rawPrevTime = g || !t || e || this._rawPrevTime === e ? e : 1e-8, 0 === e && s) for (r = this._first; r && 0 === r._startTime;)r._duration || (s = !1), r = r._next; e = 0, this._initted || (c = !0) } else 0 === g && x < 0 && (c = !0), this._time = this._rawPrevTime = e, this._locked || (this._totalTime = e, 0 !== this._repeat && (h = g + this._repeatDelay, this._cycle = this._totalTime / h >> 0, this._cycle && this._cycle === this._totalTime / h && v <= e && this._cycle--, this._time = this._totalTime - this._cycle * h, this._yoyo && 1 & this._cycle && (this._time = g - this._time), this._time > g ? (this._time = g, e = g + 1e-4) : this._time < 0 ? this._time = e = 0 : e = this._time)); if (this._hasPause && !this._forcingPlayhead && !t) { if ((e = this._time) > f || this._repeat && w !== this._cycle) for (r = this._first; r && r._startTime <= e && !u;)r._duration || "isPause" !== r.data || r.ratio || 0 === r._startTime && 0 === this._rawPrevTime || (u = r), r = r._next; else for (r = this._last; r && r._startTime >= e && !u;)r._duration || "isPause" === r.data && r._rawPrevTime > 0 && (u = r), r = r._prev; u && (p = this._startTime + (this._reversed ? this._duration - u._startTime : u._startTime) / this._timeScale, u._startTime < g && (this._time = this._rawPrevTime = e = u._startTime, this._totalTime = e + this._cycle * (this._totalDuration + this._repeatDelay))) } if (this._cycle !== w && !this._locked) { var T = this._yoyo && 0 != (1 & w), M = T === (this._yoyo && 0 != (1 & this._cycle)), S = this._totalTime, E = this._cycle, C = this._rawPrevTime, A = this._time; if (this._totalTime = w * g, this._cycle < w ? T = !T : this._totalTime += g, this._time = f, this._rawPrevTime = 0 === g ? x - 1e-4 : x, this._cycle = w, this._locked = !0, f = T ? 0 : g, this.render(f, t, 0 === g), t || this._gc || this.vars.onRepeat && (this._cycle = E, this._locked = !1, this._callback("onRepeat")), f !== this._time) return; if (M && (this._cycle = w, this._locked = !0, f = T ? g + 1e-4 : -1e-4, this.render(f, !0, !1)), this._locked = !1, this._paused && !b) return; this._time = A, this._totalTime = S, this._cycle = E, this._rawPrevTime = C } if (this._time !== f && this._first || n || c || u) { if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== v && e > 0 && (this._active = !0), 0 === v && this.vars.onStart && (0 === this._totalTime && this._totalDuration || t || this._callback("onStart")), (d = this._time) >= f) for (r = this._first; r && (o = r._next, d === this._time && (!this._paused || b));)(r._active || r._startTime <= this._time && !r._paused && !r._gc) && (u === r && (this.pause(), this._pauseTime = p), r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)), r = o; else for (r = this._last; r && (o = r._prev, d === this._time && (!this._paused || b));) { if (r._active || r._startTime <= f && !r._paused && !r._gc) { if (u === r) { for (u = r._prev; u && u.endTime() > this._time;)u.render(u._reversed ? u.totalDuration() - (e - u._startTime) * u._timeScale : (e - u._startTime) * u._timeScale, t, n), u = u._prev; u = null, this.pause(), this._pauseTime = p } r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n) } r = o } this._onUpdate && (t || (i.length && a(), this._callback("onUpdate"))), l && (this._locked || this._gc || y !== this._startTime && _ === this._timeScale || (0 === this._time || m >= this.totalDuration()) && (s && (i.length && a(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[l] && this._callback(l))) } else v !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate")) }, l.getActive = function (e, t, i) { var n, r, a = [], s = this.getChildren(e || null == e, t || null == e, !!i), o = 0, l = s.length; for (n = 0; n < l; n++)(r = s[n]).isActive() && (a[o++] = r); return a }, l.getLabelAfter = function (e) { e || 0 !== e && (e = this._time); var t, i = this.getLabelsArray(), n = i.length; for (t = 0; t < n; t++)if (i[t].time > e) return i[t].name; return null }, l.getLabelBefore = function (e) { null == e && (e = this._time); for (var t = this.getLabelsArray(), i = t.length; --i > -1;)if (t[i].time < e) return t[i].name; return null }, l.getLabelsArray = function () { var e, t = [], i = 0; for (e in this._labels) t[i++] = { time: this._labels[e], name: e }; return t.sort((function (e, t) { return e.time - t.time })), t }, l.invalidate = function () { return this._locked = !1, r.a.prototype.invalidate.call(this) }, l.progress = function (e, t) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), t) : this._time / this.duration() || 0 }, l.totalProgress = function (e, t) { return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._totalTime / this.totalDuration() || 0 }, l.totalDuration = function (e) { return arguments.length ? -1 !== this._repeat && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (r.a.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration) }, l.time = function (e, t) { if (!arguments.length) return this._time; this._dirty && this.totalDuration(); var i = this._duration, n = this._cycle, r = n * (i + this._repeatDelay); return e > i && (e = i), this.totalTime(this._yoyo && 1 & n ? i - e + r : this._repeat ? e + r : e, t) }, l.repeat = function (e) { return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat }, l.repeatDelay = function (e) { return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay }, l.yoyo = function (e) { return arguments.length ? (this._yoyo = e, this) : this._yoyo }, l.currentLabel = function (e) { return arguments.length ? this.seek(e, !0) : this.getLabelBefore(this._time + 1e-8) }, e }), !0); var a = n.m.TimelineMax
}, function (e, t, i) {
    "use strict"; i.d(t, "a", (function () { return r })); var n = i(0);
/*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/n.k._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], (function () { var e = function (e) { var t, i = [], n = e.length; for (t = 0; t !== n; i.push(e[t++])); return i }, t = function (e, t, i) { var n, r, a = e.cycle; for (n in a) r = a[n], e[n] = "function" == typeof r ? r(i, t[i], t) : r[i % r.length]; delete e.cycle }, i = function (e) { if ("function" == typeof e) return e; var t = "object" == typeof e ? e : { each: e }, i = t.ease, n = t.from || 0, r = t.base || 0, a = {}, s = isNaN(n), o = t.axis, l = { center: .5, end: 1 }[n] || 0; return function (e, c, h) { var u, d, p, f, m, g, v, y, _, x = (h || t).length, b = a[x]; if (!b) { if (!(_ = "auto" === t.grid ? 0 : (t.grid || [1 / 0])[0])) { for (v = -1 / 0; v < (v = h[_++].getBoundingClientRect().left) && _ < x;); _-- } for (b = a[x] = [], u = s ? Math.min(_, x) * l - .5 : n % _, d = s ? x * l / _ - .5 : n / _ | 0, v = 0, y = 1 / 0, g = 0; g < x; g++)p = g % _ - u, f = d - (g / _ | 0), b[g] = m = o ? Math.abs("y" === o ? f : p) : Math.sqrt(p * p + f * f), m > v && (v = m), m < y && (y = m); b.max = v - y, b.min = y, b.v = x = t.amount || t.each * (_ > x ? x - 1 : o ? "y" === o ? x / _ : _ : Math.max(_, x / _)) || 0, b.b = x < 0 ? r - x : r } return x = (b[e] - b.min) / b.max, b.b + (i ? i.getRatio(x) : x) * b.v } }, r = function (e, t, i) { n.l.call(this, e, t, i), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = r.prototype.render }, a = n.l._internals, s = a.isSelector, o = a.isArray, l = r.prototype = n.l.to({}, .1, {}), c = []; r.version = "2.1.3", l.constructor = r, l.kill()._gc = !1, r.killTweensOf = r.killDelayedCallsTo = n.l.killTweensOf, r.getTweensOf = n.l.getTweensOf, r.lagSmoothing = n.l.lagSmoothing, r.ticker = n.l.ticker, r.render = n.l.render, r.distribute = i, l.invalidate = function () { return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), n.l.prototype.invalidate.call(this) }, l.updateTo = function (e, t) { var i, r = this.ratio, a = this.vars.immediateRender || e.immediateRender; for (i in t && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)), e) this.vars[i] = e[i]; if (this._initted || a) if (t) this._initted = !1, a && this.render(0, !0, !0); else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && n.l._onPluginEvent("_onDisable", this), this._time / this._duration > .998) { var s = this._totalTime; this.render(0, !0, !1), this._initted = !1, this.render(s, !0, !1) } else if (this._initted = !1, this._init(), this._time > 0 || a) for (var o, l = 1 / (1 - r), c = this._firstPT; c;)o = c.s + c.c, c.c *= l, c.s = o - c.c, c = c._next; return this }, l.render = function (e, t, i) { this._initted || 0 === this._duration && this.vars.repeat && this.invalidate(); var r, s, o, l, c, h, u, d, p, f = this._dirty ? this.totalDuration() : this._totalDuration, m = this._time, g = this._totalTime, v = this._cycle, y = this._duration, _ = this._rawPrevTime; if (e >= f - 1e-8 && e >= 0 ? (this._totalTime = f, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, s = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === y && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (e = 0), (_ < 0 || e <= 0 && e >= -1e-8 || 1e-8 === _ && "isPause" !== this.data) && _ !== e && (i = !0, _ > 1e-8 && (s = "onReverseComplete")), this._rawPrevTime = d = !t || e || _ === e ? e : 1e-8)) : e < 1e-8 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== g || 0 === y && _ > 0) && (s = "onReverseComplete", r = this._reversed), e > -1e-8 ? e = 0 : e < 0 && (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || i) && (_ >= 0 && (i = !0), this._rawPrevTime = d = !t || e || _ === e ? e : 1e-8)), this._initted || (i = !0)) : (this._totalTime = this._time = e, 0 !== this._repeat && (l = y + this._repeatDelay, this._cycle = this._totalTime / l >> 0, 0 !== this._cycle && this._cycle === this._totalTime / l && g <= e && this._cycle--, this._time = this._totalTime - this._cycle * l, this._yoyo && 0 != (1 & this._cycle) && (this._time = y - this._time, (p = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== p || this._initted ? this._yoyoEase = p = !0 === p ? this._ease : p instanceof n.b ? p : n.b.map[p] : (p = this.vars.ease, this._yoyoEase = p = p ? p instanceof n.b ? p : "function" == typeof p ? new n.b(p, this.vars.easeParams) : n.b.map[p] || n.l.defaultEase : n.l.defaultEase)), this.ratio = p ? 1 - p.getRatio((y - this._time) / y) : 0)), this._time > y ? this._time = y : this._time < 0 && (this._time = 0)), this._easeType && !p ? (c = this._time / y, (1 === (h = this._easeType) || 3 === h && c >= .5) && (c = 1 - c), 3 === h && (c *= 2), 1 === (u = this._easePower) ? c *= c : 2 === u ? c *= c * c : 3 === u ? c *= c * c * c : 4 === u && (c *= c * c * c * c), this.ratio = 1 === h ? 1 - c : 2 === h ? c : this._time / y < .5 ? c / 2 : 1 - c / 2) : p || (this.ratio = this._ease.getRatio(this._time / y))), m !== this._time || i || v !== this._cycle) { if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = m, this._totalTime = g, this._rawPrevTime = _, this._cycle = v, a.lazyTweens.push(this), void (this._lazy = [e, t]); !this._time || r || p ? r && this._ease._calcEnd && !p && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / y) } for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== m && e >= 0 && (this._active = !0), 0 === g && (2 === this._initted && e > 0 && this._init(), this._startAt && (e >= 0 ? this._startAt.render(e, !0, i) : s || (s = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== y || t || this._callback("onStart"))), o = this._firstPT; o;)o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next; this._onUpdate && (e < 0 && this._startAt && this._startTime && this._startAt.render(e, !0, i), t || (this._totalTime !== g || s) && this._callback("onUpdate")), this._cycle !== v && (t || this._gc || this.vars.onRepeat && this._callback("onRepeat")), s && (this._gc && !i || (e < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(e, !0, i), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[s] && this._callback(s), 0 === y && 1e-8 === this._rawPrevTime && 1e-8 !== d && (this._rawPrevTime = 0))) } else g !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate")) }, r.to = function (e, t, i) { return new r(e, t, i) }, r.from = function (e, t, i) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new r(e, t, i) }, r.fromTo = function (e, t, i, n) { return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new r(e, t, n) }, r.staggerTo = r.allTo = function (a, l, h, u, d, p, f) { var m, g, v, y, _ = [], x = i(h.stagger || u), b = h.cycle, w = (h.startAt || c).cycle; for (o(a) || ("string" == typeof a && (a = n.l.selector(a) || a), s(a) && (a = e(a))), m = (a = a || []).length - 1, v = 0; v <= m; v++) { for (y in g = {}, h) g[y] = h[y]; if (b && (t(g, a, v), null != g.duration && (l = g.duration, delete g.duration)), w) { for (y in w = g.startAt = {}, h.startAt) w[y] = h.startAt[y]; t(g.startAt, a, v) } g.delay = x(v, a[v], a) + (g.delay || 0), v === m && d && (g.onComplete = function () { h.onComplete && h.onComplete.apply(h.onCompleteScope || this, arguments), d.apply(f || h.callbackScope || this, p || c) }), _[v] = new r(a[v], l, g) } return _ }, r.staggerFrom = r.allFrom = function (e, t, i, n, a, s, o) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, r.staggerTo(e, t, i, n, a, s, o) }, r.staggerFromTo = r.allFromTo = function (e, t, i, n, a, s, o, l) { return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, r.staggerTo(e, t, n, a, s, o, l) }, r.delayedCall = function (e, t, i, n, a) { return new r(t, 0, { delay: e, onComplete: t, onCompleteParams: i, callbackScope: n, onReverseComplete: t, onReverseCompleteParams: i, immediateRender: !1, useFrames: a, overwrite: 0 }) }, r.set = function (e, t) { return new r(e, 0, t) }, r.isTweening = function (e) { return n.l.getTweensOf(e, !0).length > 0 }; var h = function (e, t) { for (var i = [], r = 0, a = e._first; a;)a instanceof n.l ? i[r++] = a : (t && (i[r++] = a), r = (i = i.concat(h(a, t))).length), a = a._next; return i }, u = r.getAllTweens = function (e) { return h(n.a._rootTimeline, e).concat(h(n.a._rootFramesTimeline, e)) }; r.killAll = function (e, t, i, r) { null == t && (t = !0), null == i && (i = !0); var a, s, o, l = u(0 != r), c = l.length, h = t && i && r; for (o = 0; o < c; o++)s = l[o], (h || s instanceof n.i || (a = s.target === s.vars.onComplete) && i || t && !a) && (e ? s.totalTime(s._reversed ? 0 : s.totalDuration()) : s._enabled(!1, !1)) }, r.killChildTweensOf = function (t, i) { if (null != t) { var l, c, h, u, d, p = a.tweenLookup; if ("string" == typeof t && (t = n.l.selector(t) || t), s(t) && (t = e(t)), o(t)) for (u = t.length; --u > -1;)r.killChildTweensOf(t[u], i); else { for (h in l = [], p) for (c = p[h].target.parentNode; c;)c === t && (l = l.concat(p[h].tweens)), c = c.parentNode; for (d = l.length, u = 0; u < d; u++)i && l[u].totalTime(l[u].totalDuration()), l[u]._enabled(!1, !1) } } }; var d = function (e, t, i, r) { t = !1 !== t, i = !1 !== i; for (var a, s, o = u(r = !1 !== r), l = t && i && r, c = o.length; --c > -1;)s = o[c], (l || s instanceof n.i || (a = s.target === s.vars.onComplete) && i || t && !a) && s.paused(e) }; return r.pauseAll = function (e, t, i) { d(!0, e, t, i) }, r.resumeAll = function (e, t, i) { d(!1, e, t, i) }, r.globalTimeScale = function (e) { var t = n.a._rootTimeline, i = n.l.ticker.time; return arguments.length ? (e = e || 1e-8, t._startTime = i - (i - t._startTime) * t._timeScale / e, t = n.a._rootFramesTimeline, i = n.l.ticker.frame, t._startTime = i - (i - t._startTime) * t._timeScale / e, t._timeScale = n.a._rootTimeline._timeScale = e, e) : t._timeScale }, l.progress = function (e, t) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), t) : this.duration() ? this._time / this._duration : this.ratio }, l.totalProgress = function (e, t) { return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._totalTime / this.totalDuration() }, l.time = function (e, t) { if (!arguments.length) return this._time; this._dirty && this.totalDuration(); var i = this._duration, n = this._cycle, r = n * (i + this._repeatDelay); return e > i && (e = i), this.totalTime(this._yoyo && 1 & n ? i - e + r : this._repeat ? e + r : e, t) }, l.duration = function (e) { return arguments.length ? n.a.prototype.duration.call(this, e) : this._duration }, l.totalDuration = function (e) { return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration) }, l.repeat = function (e) { return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat }, l.repeatDelay = function (e) { return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay }, l.yoyo = function (e) { return arguments.length ? (this._yoyo = e, this) : this._yoyo }, r }), !0); var r = n.m.TweenMax
}, function (e, t, i) { }, function (e, t, i) { (function (e) { "use strict"; var t = "debug.addIndicators", i = window.console || {}, n = Function.prototype.bind.call(i.error || i.log || function () { }, i); e || n("(" + t + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs."); var r = e._util, a = 0; e.Scene.extend((function () { var e, t = this; t.addIndicators = function (i) { if (!e) { var n = { name: "", indent: 0, parent: void 0, colorStart: "green", colorEnd: "red", colorTrigger: "blue" }; i = r.extend({}, n, i), a++, e = new s(t, i), t.on("add.plugin_addIndicators", e.add), t.on("remove.plugin_addIndicators", e.remove), t.on("destroy.plugin_addIndicators", t.removeIndicators), t.controller() && e.add() } return t }, t.removeIndicators = function () { return e && (e.remove(), this.off("*.plugin_addIndicators"), e = void 0), t } })), e.Controller.addOption("addIndicators", !1), e.Controller.extend((function () { var i = this, n = i.info(), a = n.container, s = n.isDocument, o = n.vertical, l = { groups: [] }; i._indicators && function () { i._log && (Array.prototype.splice.call(arguments, 1, 0, "(" + t + ")", "->"), i._log.apply(this, arguments)) }(2, "WARNING: Scene already has a property '_indicators', which will be overwritten by plugin."), this._indicators = l; var c = function () { l.updateBoundsPositions() }, h = function () { l.updateTriggerGroupPositions() }; return a.addEventListener("resize", h), s || (window.addEventListener("resize", h), window.addEventListener("scroll", h)), a.addEventListener("resize", c), a.addEventListener("scroll", c), this._indicators.updateBoundsPositions = function (e) { for (var t, i, n, s = e ? [r.extend({}, e.triggerGroup, { members: [e] })] : l.groups, c = s.length, h = {}, u = o ? "left" : "top", d = o ? "width" : "height", p = o ? r.get.scrollLeft(a) + r.get.width(a) - 15 : r.get.scrollTop(a) + r.get.height(a) - 15; c--;)for (t = (n = s[c]).members.length, i = r.get[d](n.element.firstChild); t--;)h[u] = p - i, r.css(n.members[t].bounds, h) }, this._indicators.updateTriggerGroupPositions = function (e) { for (var t, n, c, h, u = e ? [e] : l.groups, d = u.length, p = s ? document.body : a, f = s ? { top: 0, left: 0 } : r.get.offset(p, !0), m = o ? r.get.width(a) - 15 : r.get.height(a) - 15, g = o ? "width" : "height", v = o ? "Y" : "X"; d--;)n = (t = u[d]).element, h = (c = t.triggerHook * i.info("size")) > r.get[g](n.firstChild.firstChild) ? "translate" + v + "(-100%)" : "", r.css(n, { top: f.top + (o ? c : m - t.members[0].options.indent), left: f.left + (o ? m - t.members[0].options.indent : c) }), r.css(n.firstChild.firstChild, { "-ms-transform": h, "-webkit-transform": h, transform: h }) }, this._indicators.updateTriggerGroupLabel = function (e) { var t = "trigger" + (e.members.length > 1 ? "" : " " + e.members[0].options.name), i = e.element.firstChild.firstChild; i.textContent !== t && (i.textContent = t, o && l.updateBoundsPositions()) }, this.addScene = function (t) { this._options.addIndicators && t instanceof e.Scene && t.controller() === i && t.addIndicators(), this.$super.addScene.apply(this, arguments) }, this.destroy = function () { a.removeEventListener("resize", h), s || (window.removeEventListener("resize", h), window.removeEventListener("scroll", h)), a.removeEventListener("resize", c), a.removeEventListener("scroll", c), this.$super.destroy.apply(this, arguments) }, i })); var s = function (e, i) { var n, s, l = this, c = o.bounds(), h = o.start(i.colorStart), u = o.end(i.colorEnd), d = i.parent && r.get.elements(i.parent)[0], p = function () { e._log && (Array.prototype.splice.call(arguments, 1, 0, "(" + t + ")", "->"), e._log.apply(this, arguments)) }; i.name = i.name || a, h.firstChild.textContent += " " + i.name, u.textContent += " " + i.name, c.appendChild(h), c.appendChild(u), l.options = i, l.bounds = c, l.triggerGroup = void 0, this.add = function () { s = e.controller(), n = s.info("vertical"); var t = s.info("isDocument"); d || (d = t ? document.body : s.info("container")), t || "static" !== r.css(d, "position") || r.css(d, { position: "relative" }), e.on("change.plugin_addIndicators", m), e.on("shift.plugin_addIndicators", f), _(), v(), setTimeout((function () { s._indicators.updateBoundsPositions(l) }), 0), p(3, "added indicators") }, this.remove = function () { if (l.triggerGroup) { if (e.off("change.plugin_addIndicators", m), e.off("shift.plugin_addIndicators", f), l.triggerGroup.members.length > 1) { var t = l.triggerGroup; t.members.splice(t.members.indexOf(l), 1), s._indicators.updateTriggerGroupLabel(t), s._indicators.updateTriggerGroupPositions(t), l.triggerGroup = void 0 } else y(); g(), p(3, "removed indicators") } }; var f = function () { v() }, m = function (e) { "triggerHook" === e.what && _() }, g = function () { c.parentNode.removeChild(c) }, v = function () { var t; c.parentNode !== d && (t = s.info("vertical"), r.css(h.firstChild, { "border-bottom-width": t ? 1 : 0, "border-right-width": t ? 0 : 1, bottom: t ? -1 : i.indent, right: t ? i.indent : -1, padding: t ? "0 8px" : "2px 4px" }), r.css(u, { "border-top-width": t ? 1 : 0, "border-left-width": t ? 0 : 1, top: t ? "100%" : "", right: t ? i.indent : "", bottom: t ? "" : i.indent, left: t ? "" : "100%", padding: t ? "0 8px" : "2px 4px" }), d.appendChild(c)); var a = {}; a[n ? "top" : "left"] = e.triggerPosition(), a[n ? "height" : "width"] = e.duration(), r.css(c, a), r.css(u, { display: e.duration() > 0 ? "" : "none" }) }, y = function () { s._indicators.groups.splice(s._indicators.groups.indexOf(l.triggerGroup), 1), l.triggerGroup.element.parentNode.removeChild(l.triggerGroup.element), l.triggerGroup = void 0 }, _ = function () { var t = e.triggerHook(); if (!(l.triggerGroup && Math.abs(l.triggerGroup.triggerHook - t) < 1e-4)) { for (var a, c = s._indicators.groups, h = c.length; h--;)if (a = c[h], Math.abs(a.triggerHook - t) < 1e-4) return l.triggerGroup && (1 === l.triggerGroup.members.length ? y() : (l.triggerGroup.members.splice(l.triggerGroup.members.indexOf(l), 1), s._indicators.updateTriggerGroupLabel(l.triggerGroup), s._indicators.updateTriggerGroupPositions(l.triggerGroup))), a.members.push(l), l.triggerGroup = a, void s._indicators.updateTriggerGroupLabel(a); if (l.triggerGroup) { if (1 === l.triggerGroup.members.length) return l.triggerGroup.triggerHook = t, void s._indicators.updateTriggerGroupPositions(l.triggerGroup); l.triggerGroup.members.splice(l.triggerGroup.members.indexOf(l), 1), s._indicators.updateTriggerGroupLabel(l.triggerGroup), s._indicators.updateTriggerGroupPositions(l.triggerGroup), l.triggerGroup = void 0 } !function () { var t = o.trigger(i.colorTrigger), a = {}; a[n ? "right" : "bottom"] = 0, a[n ? "border-top-width" : "border-left-width"] = 1, r.css(t.firstChild, a), r.css(t.firstChild.firstChild, { padding: n ? "0 8px 3px 8px" : "3px 4px" }), document.body.appendChild(t); var c = { triggerHook: e.triggerHook(), element: t, members: [l] }; s._indicators.groups.push(c), l.triggerGroup = c, s._indicators.updateTriggerGroupLabel(c), s._indicators.updateTriggerGroupPositions(c) }() } } }, o = { start: function (e) { var t = document.createElement("div"); t.textContent = "start", r.css(t, { position: "absolute", overflow: "visible", "border-width": 0, "border-style": "solid", color: e, "border-color": e }); var i = document.createElement("div"); return r.css(i, { position: "absolute", overflow: "visible", width: 0, height: 0 }), i.appendChild(t), i }, end: function (e) { var t = document.createElement("div"); return t.textContent = "end", r.css(t, { position: "absolute", overflow: "visible", "border-width": 0, "border-style": "solid", color: e, "border-color": e }), t }, bounds: function () { var e = document.createElement("div"); return r.css(e, { position: "absolute", overflow: "visible", "white-space": "nowrap", "pointer-events": "none", "font-size": "0.85em" }), e.style.zIndex = "9999", e }, trigger: function (e) { var t = document.createElement("div"); t.textContent = "trigger", r.css(t, { position: "relative" }); var i = document.createElement("div"); r.css(i, { position: "absolute", overflow: "visible", "border-width": 0, "border-style": "solid", color: e, "border-color": e }), i.appendChild(t); var n = document.createElement("div"); return r.css(n, { position: "fixed", overflow: "visible", "white-space": "nowrap", "pointer-events": "none", "font-size": "0.85em" }), n.style.zIndex = "9999", n.appendChild(i), n } } })(i(1)) }, function (e, t, i) {
    var n;
/*!
 * ScrollMagic v2.0.7 (2019-05-07)
 * The javascript library for magical scroll interactions.
 * (c) 2019 Jan Paepke (@janpaepke)
 * Project Website: http://scrollmagic.io
 * 
 * @version 2.0.7
 * @license Dual licensed under MIT license and GPL.
 * @author Jan Paepke - e-mail@janpaepke.de
 *
 * @file ScrollMagic GSAP Animation Plugin.
 *
 * requires: GSAP ~1.14
 * Powered by the Greensock Animation Platform (GSAP): http://www.greensock.com/js
 * Greensock License info at http://www.greensock.com/licensing/
 */n = function (e, t, i) { "use strict"; var n = "animation.gsap", r = window.console || {}, a = Function.prototype.bind.call(r.error || r.log || function () { }, r); e || a("(" + n + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs."), t || a("(" + n + ") -> ERROR: TweenLite or TweenMax could not be found. Please make sure GSAP is loaded before ScrollMagic or use an asynchronous loader like requirejs."), e.Scene.addOption("tweenChanges", !1, (function (e) { return !!e })), e.Scene.extend((function () { var e, r = this, a = function () { r._log && (Array.prototype.splice.call(arguments, 1, 0, "(" + n + ")", "->"), r._log.apply(this, arguments)) }; r.on("progress.plugin_gsap", (function () { s() })), r.on("destroy.plugin_gsap", (function (e) { r.removeTween(e.reset) })); var s = function () { if (e) { var t = r.progress(), i = r.state(); e.repeat && -1 === e.repeat() ? "DURING" === i && e.paused() ? e.play() : "DURING" === i || e.paused() || e.pause() : t != e.progress() && (0 === r.duration() ? t > 0 ? e.play() : e.reverse() : r.tweenChanges() && e.tweenTo ? e.tweenTo(t * e.duration()) : e.progress(t).pause()) } }; r.setTween = function (n, o, l) { var c; arguments.length > 1 && (arguments.length < 3 && (l = o, o = 1), n = t.to(n, o, l)); try { (c = i ? new i({ smoothChildTiming: !0 }).add(n) : n).pause() } catch (e) { return a(1, "ERROR calling method 'setTween()': Supplied argument is not a valid TweenObject"), r } if (e && r.removeTween(), e = c, n.repeat && -1 === n.repeat() && (e.repeat(-1), e.yoyo(n.yoyo())), r.tweenChanges() && !e.tweenTo && a(2, "WARNING: tweenChanges will only work if the TimelineMax object is available for ScrollMagic."), e && r.controller() && r.triggerElement() && r.loglevel() >= 2) { var h = t.getTweensOf(r.triggerElement()), u = r.controller().info("vertical"); h.forEach((function (e, t) { var i = e.vars.css || e.vars; if (u ? void 0 !== i.top || void 0 !== i.bottom : void 0 !== i.left || void 0 !== i.right) return a(2, "WARNING: Tweening the position of the trigger element affects the scene timing and should be avoided!"), !1 })) } if (parseFloat(TweenLite.version) >= 1.14) for (var d, p, f = e.getChildren ? e.getChildren(!0, !0, !1) : [e], m = function () { a(2, "WARNING: tween was overwritten by another. To learn how to avoid this issue see here: https://github.com/janpaepke/ScrollMagic/wiki/WARNING:-tween-was-overwritten-by-another") }, g = 0; g < f.length; g++)d = f[g], p !== m && (p = d.vars.onOverwrite, d.vars.onOverwrite = function () { p && p.apply(this, arguments), m.apply(this, arguments) }); return a(3, "added tween"), s(), r }, r.removeTween = function (t) { return e && (t && e.progress(0).pause(), e.kill(), e = void 0, a(3, "removed tween (reset: " + (t ? "true" : "false") + ")")), r } })) }, i(11), n(i(1), TweenMax, TimelineMax)
}, function (e, t) { e.exports = function (e) { if (!e.webpackPolyfill) { var t = Object.create(e); t.children || (t.children = []), Object.defineProperty(t, "loaded", { enumerable: !0, get: function () { return t.l } }), Object.defineProperty(t, "id", { enumerable: !0, get: function () { return t.i } }), Object.defineProperty(t, "exports", { enumerable: !0 }), t.webpackPolyfill = 1 } return t } }, function (e, t) { var i; i = function () { return this }(); try { i = i || new Function("return this")() } catch (e) { "object" == typeof window && (i = window) } e.exports = i }, function (e, t, i) {
    "use strict"; i.r(t); i(5); function n() { } void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (e) { return "number" == typeof e && isFinite(e) && Math.floor(e) === e }), void 0 === Math.sign && (Math.sign = function (e) { return e < 0 ? -1 : e > 0 ? 1 : +e }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", { get: function () { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && (Object.assign = function (e) { if (null == e) throw new TypeError("Cannot convert undefined or null to object"); for (var t = Object(e), i = 1; i < arguments.length; i++) { var n = arguments[i]; if (null != n) for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }), Object.assign(n.prototype, { addEventListener: function (e, t) { void 0 === this._listeners && (this._listeners = {}); var i = this._listeners; void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t) }, hasEventListener: function (e, t) { if (void 0 === this._listeners) return !1; var i = this._listeners; return void 0 !== i[e] && -1 !== i[e].indexOf(t) }, removeEventListener: function (e, t) { if (void 0 !== this._listeners) { var i = this._listeners[e]; if (void 0 !== i) { var n = i.indexOf(t); -1 !== n && i.splice(n, 1) } } }, dispatchEvent: function (e) { if (void 0 !== this._listeners) { var t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; for (var i = t.slice(0), n = 0, r = i.length; n < r; n++)i[n].call(this, e) } } } }); var r, a, s, o = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { for (var e = [], t = 0; t < 256; t++)e[t] = (t < 16 ? "0" : "") + t.toString(16); return function () { var t = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return (e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & i] + e[i >> 8 & 255] + "-" + e[i >> 16 & 15 | 64] + e[i >> 24 & 255] + "-" + e[63 & n | 128] + e[n >> 8 & 255] + "-" + e[n >> 16 & 255] + e[n >> 24 & 255] + e[255 & r] + e[r >> 8 & 255] + e[r >> 16 & 255] + e[r >> 24 & 255]).toUpperCase() } }(), clamp: function (e, t, i) { return Math.max(t, Math.min(i, e)) }, euclideanModulo: function (e, t) { return (e % t + t) % t }, mapLinear: function (e, t, i, n, r) { return n + (e - t) * (r - n) / (i - t) }, lerp: function (e, t, i) { return (1 - i) * e + i * t }, smoothstep: function (e, t, i) { return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e) }, smootherstep: function (e, t, i) { return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function (e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function (e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function (e) { return e * (.5 - Math.random()) }, degToRad: function (e) { return e * o.DEG2RAD }, radToDeg: function (e) { return e * o.RAD2DEG }, isPowerOfTwo: function (e) { return 0 == (e & e - 1) && 0 !== e }, ceilPowerOfTwo: function (e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) }, floorPowerOfTwo: function (e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) } }; function l(e, t) { this.x = e || 0, this.y = t || 0 } function c(e, t, i, n) { this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1 } function h(e, t, i) { this.x = e || 0, this.y = t || 0, this.z = i || 0 } function u() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } Object.defineProperties(l.prototype, { width: { get: function () { return this.x }, set: function (e) { this.x = e } }, height: { get: function () { return this.y }, set: function (e) { this.y = e } } }), Object.assign(l.prototype, { isVector2: !0, set: function (e, t) { return this.x = e, this.y = t, this }, setScalar: function (e) { return this.x = e, this.y = e, this }, setX: function (e) { return this.x = e, this }, setY: function (e) { return this.y = e, this }, setComponent: function (e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; default: throw new Error("index is out of range: " + e) }return this }, getComponent: function (e) { switch (e) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + e) } }, clone: function () { return new this.constructor(this.x, this.y) }, copy: function (e) { return this.x = e.x, this.y = e.y, this }, add: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this) }, addScalar: function (e) { return this.x += e, this.y += e, this }, addVectors: function (e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this }, addScaledVector: function (e, t) { return this.x += e.x * t, this.y += e.y * t, this }, sub: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this) }, subScalar: function (e) { return this.x -= e, this.y -= e, this }, subVectors: function (e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this }, multiply: function (e) { return this.x *= e.x, this.y *= e.y, this }, multiplyScalar: function (e) { return this.x *= e, this.y *= e, this }, divide: function (e) { return this.x /= e.x, this.y /= e.y, this }, divideScalar: function (e) { return this.multiplyScalar(1 / e) }, applyMatrix3: function (e) { var t = this.x, i = this.y, n = e.elements; return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this }, min: function (e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this }, max: function (e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this }, clamp: function (e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this }, clampScalar: function (e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this }, clampLength: function (e, t) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this }, dot: function (e) { return this.x * e.x + this.y * e.y }, cross: function (e) { return this.x * e.y - this.y * e.x }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) }, normalize: function () { return this.divideScalar(this.length() || 1) }, angle: function () { var e = Math.atan2(this.y, this.x); return e < 0 && (e += 2 * Math.PI), e }, distanceTo: function (e) { return Math.sqrt(this.distanceToSquared(e)) }, distanceToSquared: function (e) { var t = this.x - e.x, i = this.y - e.y; return t * t + i * i }, manhattanDistanceTo: function (e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) }, setLength: function (e) { return this.normalize().multiplyScalar(e) }, lerp: function (e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this }, lerpVectors: function (e, t, i) { return this.subVectors(t, e).multiplyScalar(i).add(e) }, equals: function (e) { return e.x === this.x && e.y === this.y }, fromArray: function (e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this }, toArray: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e }, fromBufferAttribute: function (e, t, i) { return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this }, rotateAround: function (e, t) { var i = Math.cos(t), n = Math.sin(t), r = this.x - e.x, a = this.y - e.y; return this.x = r * i - a * n + e.x, this.y = r * n + a * i + e.y, this } }), Object.assign(c, { slerp: function (e, t, i, n) { return i.copy(e).slerp(t, n) }, slerpFlat: function (e, t, i, n, r, a, s) { var o = i[n + 0], l = i[n + 1], c = i[n + 2], h = i[n + 3], u = r[a + 0], d = r[a + 1], p = r[a + 2], f = r[a + 3]; if (h !== f || o !== u || l !== d || c !== p) { var m = 1 - s, g = o * u + l * d + c * p + h * f, v = g >= 0 ? 1 : -1, y = 1 - g * g; if (y > Number.EPSILON) { var _ = Math.sqrt(y), x = Math.atan2(_, g * v); m = Math.sin(m * x) / _, s = Math.sin(s * x) / _ } var b = s * v; if (o = o * m + u * b, l = l * m + d * b, c = c * m + p * b, h = h * m + f * b, m === 1 - s) { var w = 1 / Math.sqrt(o * o + l * l + c * c + h * h); o *= w, l *= w, c *= w, h *= w } } e[t] = o, e[t + 1] = l, e[t + 2] = c, e[t + 3] = h } }), Object.defineProperties(c.prototype, { x: { get: function () { return this._x }, set: function (e) { this._x = e, this.onChangeCallback() } }, y: { get: function () { return this._y }, set: function (e) { this._y = e, this.onChangeCallback() } }, z: { get: function () { return this._z }, set: function (e) { this._z = e, this.onChangeCallback() } }, w: { get: function () { return this._w }, set: function (e) { this._w = e, this.onChangeCallback() } } }), Object.assign(c.prototype, { isQuaternion: !0, set: function (e, t, i, n) { return this._x = e, this._y = t, this._z = i, this._w = n, this.onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._w) }, copy: function (e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this }, setFromEuler: function (e, t) { if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); var i = e._x, n = e._y, r = e._z, a = e.order, s = Math.cos, o = Math.sin, l = s(i / 2), c = s(n / 2), h = s(r / 2), u = o(i / 2), d = o(n / 2), p = o(r / 2); return "XYZ" === a ? (this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p) : "YXZ" === a ? (this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p) : "ZXY" === a ? (this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p) : "ZYX" === a ? (this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p) : "YZX" === a ? (this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p) : "XZY" === a && (this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p), !1 !== t && this.onChangeCallback(), this }, setFromAxisAngle: function (e, t) { var i = t / 2, n = Math.sin(i); return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this.onChangeCallback(), this }, setFromRotationMatrix: function (e) { var t, i = e.elements, n = i[0], r = i[4], a = i[8], s = i[1], o = i[5], l = i[9], c = i[2], h = i[6], u = i[10], d = n + o + u; return d > 0 ? (t = .5 / Math.sqrt(d + 1), this._w = .25 / t, this._x = (h - l) * t, this._y = (a - c) * t, this._z = (s - r) * t) : n > o && n > u ? (t = 2 * Math.sqrt(1 + n - o - u), this._w = (h - l) / t, this._x = .25 * t, this._y = (r + s) / t, this._z = (a + c) / t) : o > u ? (t = 2 * Math.sqrt(1 + o - n - u), this._w = (a - c) / t, this._x = (r + s) / t, this._y = .25 * t, this._z = (l + h) / t) : (t = 2 * Math.sqrt(1 + u - n - o), this._w = (s - r) / t, this._x = (a + c) / t, this._y = (l + h) / t, this._z = .25 * t), this.onChangeCallback(), this }, setFromUnitVectors: function (e, t) { var i = e.dot(t) + 1; return i < 1e-6 ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize() }, angleTo: function (e) { return 2 * Math.acos(Math.abs(o.clamp(this.dot(e), -1, 1))) }, rotateTowards: function (e, t) { var i = this.angleTo(e); if (0 === i) return this; var n = Math.min(1, t / i); return this.slerp(e, n), this }, inverse: function () { return this.conjugate() }, conjugate: function () { return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this }, dot: function (e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { var e = this.length(); return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this.onChangeCallback(), this }, multiply: function (e, t) { return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e) }, premultiply: function (e) { return this.multiplyQuaternions(e, this) }, multiplyQuaternions: function (e, t) { var i = e._x, n = e._y, r = e._z, a = e._w, s = t._x, o = t._y, l = t._z, c = t._w; return this._x = i * c + a * s + n * l - r * o, this._y = n * c + a * o + r * s - i * l, this._z = r * c + a * l + i * o - n * s, this._w = a * c - i * s - n * o - r * l, this.onChangeCallback(), this }, slerp: function (e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); var i = this._x, n = this._y, r = this._z, a = this._w, s = a * e._w + i * e._x + n * e._y + r * e._z; if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1) return this._w = a, this._x = i, this._y = n, this._z = r, this; var o = 1 - s * s; if (o <= Number.EPSILON) { var l = 1 - t; return this._w = l * a + t * this._w, this._x = l * i + t * this._x, this._y = l * n + t * this._y, this._z = l * r + t * this._z, this.normalize() } var c = Math.sqrt(o), h = Math.atan2(c, s), u = Math.sin((1 - t) * h) / c, d = Math.sin(t * h) / c; return this._w = a * u + this._w * d, this._x = i * u + this._x * d, this._y = n * u + this._y * d, this._z = r * u + this._z * d, this.onChangeCallback(), this }, equals: function (e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w }, fromArray: function (e, t) { return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this }, toArray: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e }, onChange: function (e) { return this.onChangeCallback = e, this }, onChangeCallback: function () { } }), Object.assign(h.prototype, { isVector3: !0, set: function (e, t, i) { return this.x = e, this.y = t, this.z = i, this }, setScalar: function (e) { return this.x = e, this.y = e, this.z = e, this }, setX: function (e) { return this.x = e, this }, setY: function (e) { return this.y = e, this }, setZ: function (e) { return this.z = e, this }, setComponent: function (e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; default: throw new Error("index is out of range: " + e) }return this }, getComponent: function (e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + e) } }, clone: function () { return new this.constructor(this.x, this.y, this.z) }, copy: function (e) { return this.x = e.x, this.y = e.y, this.z = e.z, this }, add: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this) }, addScalar: function (e) { return this.x += e, this.y += e, this.z += e, this }, addVectors: function (e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this }, addScaledVector: function (e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this }, sub: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this) }, subScalar: function (e) { return this.x -= e, this.y -= e, this.z -= e, this }, subVectors: function (e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this }, multiply: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this) }, multiplyScalar: function (e) { return this.x *= e, this.y *= e, this.z *= e, this }, multiplyVectors: function (e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this }, applyEuler: (a = new c, function (e) { return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(a.setFromEuler(e)) }), applyAxisAngle: function () { var e = new c; return function (t, i) { return this.applyQuaternion(e.setFromAxisAngle(t, i)) } }(), applyMatrix3: function (e) { var t = this.x, i = this.y, n = this.z, r = e.elements; return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this }, applyMatrix4: function (e) { var t = this.x, i = this.y, n = this.z, r = e.elements, a = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]); return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * a, this }, applyQuaternion: function (e) { var t = this.x, i = this.y, n = this.z, r = e.x, a = e.y, s = e.z, o = e.w, l = o * t + a * n - s * i, c = o * i + s * t - r * n, h = o * n + r * i - a * t, u = -r * t - a * i - s * n; return this.x = l * o + u * -r + c * -s - h * -a, this.y = c * o + u * -a + h * -r - l * -s, this.z = h * o + u * -s + l * -a - c * -r, this }, project: function (e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) }, unproject: function (e) { return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld) }, transformDirection: function (e) { var t = this.x, i = this.y, n = this.z, r = e.elements; return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize() }, divide: function (e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this }, divideScalar: function (e) { return this.multiplyScalar(1 / e) }, min: function (e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this }, max: function (e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this }, clamp: function (e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this }, clampScalar: function (e, t) { return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this }, clampLength: function (e, t) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function (e) { return this.x * e.x + this.y * e.y + this.z * e.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (e) { return this.normalize().multiplyScalar(e) }, lerp: function (e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this }, lerpVectors: function (e, t, i) { return this.subVectors(t, e).multiplyScalar(i).add(e) }, cross: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e) }, crossVectors: function (e, t) { var i = e.x, n = e.y, r = e.z, a = t.x, s = t.y, o = t.z; return this.x = n * o - r * s, this.y = r * a - i * o, this.z = i * s - n * a, this }, projectOnVector: function (e) { var t = e.dot(this) / e.lengthSq(); return this.copy(e).multiplyScalar(t) }, projectOnPlane: (r = new h, function (e) { return r.copy(this).projectOnVector(e), this.sub(r) }), reflect: function () { var e = new h; return function (t) { return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t))) } }(), angleTo: function (e) { var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq()); return Math.acos(o.clamp(t, -1, 1)) }, distanceTo: function (e) { return Math.sqrt(this.distanceToSquared(e)) }, distanceToSquared: function (e) { var t = this.x - e.x, i = this.y - e.y, n = this.z - e.z; return t * t + i * i + n * n }, manhattanDistanceTo: function (e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) }, setFromSpherical: function (e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) }, setFromSphericalCoords: function (e, t, i) { var n = Math.sin(t) * e; return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this }, setFromCylindrical: function (e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) }, setFromCylindricalCoords: function (e, t, i) { return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this }, setFromMatrixPosition: function (e) { var t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this }, setFromMatrixScale: function (e) { var t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = i, this.z = n, this }, setFromMatrixColumn: function (e, t) { return this.fromArray(e.elements, 4 * t) }, equals: function (e) { return e.x === this.x && e.y === this.y && e.z === this.z }, fromArray: function (e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this }, toArray: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e }, fromBufferAttribute: function (e, t, i) { return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } }), Object.assign(u.prototype, { isMatrix3: !0, set: function (e, t, i, n, r, a, s, o, l) { var c = this.elements; return c[0] = e, c[1] = n, c[2] = s, c[3] = t, c[4] = r, c[5] = o, c[6] = i, c[7] = a, c[8] = l, this }, identity: function () { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, clone: function () { return (new this.constructor).fromArray(this.elements) }, copy: function (e) { var t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this }, setFromMatrix4: function (e) { var t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this }, applyToBufferAttribute: function () { var e = new h; return function (t) { for (var i = 0, n = t.count; i < n; i++)e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix3(this), t.setXYZ(i, e.x, e.y, e.z); return t } }(), multiply: function (e) { return this.multiplyMatrices(this, e) }, premultiply: function (e) { return this.multiplyMatrices(e, this) }, multiplyMatrices: function (e, t) { var i = e.elements, n = t.elements, r = this.elements, a = i[0], s = i[3], o = i[6], l = i[1], c = i[4], h = i[7], u = i[2], d = i[5], p = i[8], f = n[0], m = n[3], g = n[6], v = n[1], y = n[4], _ = n[7], x = n[2], b = n[5], w = n[8]; return r[0] = a * f + s * v + o * x, r[3] = a * m + s * y + o * b, r[6] = a * g + s * _ + o * w, r[1] = l * f + c * v + h * x, r[4] = l * m + c * y + h * b, r[7] = l * g + c * _ + h * w, r[2] = u * f + d * v + p * x, r[5] = u * m + d * y + p * b, r[8] = u * g + d * _ + p * w, this }, multiplyScalar: function (e) { var t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this }, determinant: function () { var e = this.elements, t = e[0], i = e[1], n = e[2], r = e[3], a = e[4], s = e[5], o = e[6], l = e[7], c = e[8]; return t * a * c - t * s * l - i * r * c + i * s * o + n * r * l - n * a * o }, getInverse: function (e, t) { e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."); var i = e.elements, n = this.elements, r = i[0], a = i[1], s = i[2], o = i[3], l = i[4], c = i[5], h = i[6], u = i[7], d = i[8], p = d * l - c * u, f = c * h - d * o, m = u * o - l * h, g = r * p + a * f + s * m; if (0 === g) { var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"; if (!0 === t) throw new Error(v); return console.warn(v), this.identity() } var y = 1 / g; return n[0] = p * y, n[1] = (s * u - d * a) * y, n[2] = (c * a - s * l) * y, n[3] = f * y, n[4] = (d * r - s * h) * y, n[5] = (s * o - c * r) * y, n[6] = m * y, n[7] = (a * h - u * r) * y, n[8] = (l * r - a * o) * y, this }, transpose: function () { var e, t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this }, getNormalMatrix: function (e) { return this.setFromMatrix4(e).getInverse(this).transpose() }, transposeIntoArray: function (e) { var t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this }, setUvTransform: function (e, t, i, n, r, a, s) { var o = Math.cos(r), l = Math.sin(r); this.set(i * o, i * l, -i * (o * a + l * s) + a + e, -n * l, n * o, -n * (-l * a + o * s) + s + t, 0, 0, 1) }, scale: function (e, t) { var i = this.elements; return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this }, rotate: function (e) { var t = Math.cos(e), i = Math.sin(e), n = this.elements, r = n[0], a = n[3], s = n[6], o = n[1], l = n[4], c = n[7]; return n[0] = t * r + i * o, n[3] = t * a + i * l, n[6] = t * s + i * c, n[1] = -i * r + t * o, n[4] = -i * a + t * l, n[7] = -i * s + t * c, this }, translate: function (e, t) { var i = this.elements; return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this }, equals: function (e) { for (var t = this.elements, i = e.elements, n = 0; n < 9; n++)if (t[n] !== i[n]) return !1; return !0 }, fromArray: function (e, t) { void 0 === t && (t = 0); for (var i = 0; i < 9; i++)this.elements[i] = e[i + t]; return this }, toArray: function (e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); var i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e } }); var d, p, f, m, g, v, y, _, x, b, w, T, M, S, E = { getDataURL: function (e) { var t; if ("undefined" == typeof HTMLCanvasElement) return e.src; if (e instanceof HTMLCanvasElement) t = e; else { void 0 === s && (s = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), s.width = e.width, s.height = e.height; var i = s.getContext("2d"); e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = s } return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png") } }, C = 0; function A(e, t, i, n, r, a, s, c, h, d) { Object.defineProperty(this, "id", { value: C++ }), this.uuid = o.generateUUID(), this.name = "", this.image = void 0 !== e ? e : A.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : A.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : 1001, this.wrapT = void 0 !== n ? n : 1001, this.magFilter = void 0 !== r ? r : 1006, this.minFilter = void 0 !== a ? a : 1008, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== s ? s : 1023, this.type = void 0 !== c ? c : 1009, this.offset = new l(0, 0), this.repeat = new l(1, 1), this.center = new l(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new u, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : 3e3, this.version = 0, this.onUpdate = null } function P(e, t, i, n) { this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1 } function L(e, t, i) { this.width = e, this.height = t, this.scissor = new P(0, 0, e, t), this.scissorTest = !1, this.viewport = new P(0, 0, e, t), i = i || {}, this.texture = new A(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null } function R(e, t, i) { L.call(this, e, t, i), this.samples = 4 } function O(e, t, i) { L.call(this, e, t, i) } function I(e, t, i, n, r, a, s, o, l, c, h, u) { A.call(this, null, a, s, o, l, c, n, r, h, u), this.image = { data: e, width: t, height: i }, this.magFilter = void 0 !== l ? l : 1003, this.minFilter = void 0 !== c ? c : 1003, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } function k(e, t) { this.min = void 0 !== e ? e : new h(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new h(-1 / 0, -1 / 0, -1 / 0) } function D(e, t) { this.center = void 0 !== e ? e : new h, this.radius = void 0 !== t ? t : 0 } function z(e, t) { this.normal = void 0 !== e ? e : new h(1, 0, 0), this.constant = void 0 !== t ? t : 0 } function N(e, t, i, n, r, a) { this.planes = [void 0 !== e ? e : new z, void 0 !== t ? t : new z, void 0 !== i ? i : new z, void 0 !== n ? n : new z, void 0 !== r ? r : new z, void 0 !== a ? a : new z] } function B() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } A.DEFAULT_IMAGE = void 0, A.DEFAULT_MAPPING = 300, A.prototype = Object.assign(Object.create(n.prototype), { constructor: A, isTexture: !0, updateMatrix: function () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this }, toJSON: function (e) { var t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; var i = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { var n = this.image; if (void 0 === n.uuid && (n.uuid = o.generateUUID()), !t && void 0 === e.images[n.uuid]) { var r; if (Array.isArray(n)) { r = []; for (var a = 0, s = n.length; a < s; a++)r.push(E.getDataURL(n[a])) } else r = E.getDataURL(n); e.images[n.uuid] = { uuid: n.uuid, url: r } } i.image = n.uuid } return t || (e.textures[this.uuid] = i), i }, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (e) { if (300 !== this.mapping) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) { case 1e3: e.x = e.x - Math.floor(e.x); break; case 1001: e.x = e.x < 0 ? 0 : 1; break; case 1002: 1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }if (e.y < 0 || e.y > 1) switch (this.wrapT) { case 1e3: e.y = e.y - Math.floor(e.y); break; case 1001: e.y = e.y < 0 ? 0 : 1; break; case 1002: 1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }return this.flipY && (e.y = 1 - e.y), e } }), Object.defineProperty(A.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }), Object.assign(P.prototype, { isVector4: !0, set: function (e, t, i, n) { return this.x = e, this.y = t, this.z = i, this.w = n, this }, setScalar: function (e) { return this.x = e, this.y = e, this.z = e, this.w = e, this }, setX: function (e) { return this.x = e, this }, setY: function (e) { return this.y = e, this }, setZ: function (e) { return this.z = e, this }, setW: function (e) { return this.w = e, this }, setComponent: function (e, t) { switch (e) { case 0: this.x = t; break; case 1: this.y = t; break; case 2: this.z = t; break; case 3: this.w = t; break; default: throw new Error("index is out of range: " + e) }return this }, getComponent: function (e) { switch (e) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + e) } }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function (e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this }, add: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this) }, addScalar: function (e) { return this.x += e, this.y += e, this.z += e, this.w += e, this }, addVectors: function (e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this }, addScaledVector: function (e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this }, sub: function (e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this) }, subScalar: function (e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this }, subVectors: function (e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this }, multiplyScalar: function (e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this }, applyMatrix4: function (e) { var t = this.x, i = this.y, n = this.z, r = this.w, a = e.elements; return this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * r, this }, divideScalar: function (e) { return this.multiplyScalar(1 / e) }, setAxisAngleFromQuaternion: function (e) { this.w = 2 * Math.acos(e.w); var t = Math.sqrt(1 - e.w * e.w); return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this }, setAxisAngleFromRotationMatrix: function (e) { var t, i, n, r, a = e.elements, s = a[0], o = a[4], l = a[8], c = a[1], h = a[5], u = a[9], d = a[2], p = a[6], f = a[10]; if (Math.abs(o - c) < .01 && Math.abs(l - d) < .01 && Math.abs(u - p) < .01) { if (Math.abs(o + c) < .1 && Math.abs(l + d) < .1 && Math.abs(u + p) < .1 && Math.abs(s + h + f - 3) < .1) return this.set(1, 0, 0, 0), this; t = Math.PI; var m = (s + 1) / 2, g = (h + 1) / 2, v = (f + 1) / 2, y = (o + c) / 4, _ = (l + d) / 4, x = (u + p) / 4; return m > g && m > v ? m < .01 ? (i = 0, n = .707106781, r = .707106781) : (n = y / (i = Math.sqrt(m)), r = _ / i) : g > v ? g < .01 ? (i = .707106781, n = 0, r = .707106781) : (i = y / (n = Math.sqrt(g)), r = x / n) : v < .01 ? (i = .707106781, n = .707106781, r = 0) : (i = _ / (r = Math.sqrt(v)), n = x / r), this.set(i, n, r, t), this } var b = Math.sqrt((p - u) * (p - u) + (l - d) * (l - d) + (c - o) * (c - o)); return Math.abs(b) < .001 && (b = 1), this.x = (p - u) / b, this.y = (l - d) / b, this.z = (c - o) / b, this.w = Math.acos((s + h + f - 1) / 2), this }, min: function (e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this }, max: function (e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this }, clamp: function (e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this }, clampScalar: function (e, t) { return void 0 === d && (d = new P, p = new P), d.set(e, e, e, e), p.set(t, t, t, t), this.clamp(d, p) }, clampLength: function (e, t) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, roundToZero: function () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, dot: function (e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (e) { return this.normalize().multiplyScalar(e) }, lerp: function (e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this }, lerpVectors: function (e, t, i) { return this.subVectors(t, e).multiplyScalar(i).add(e) }, equals: function (e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w }, fromArray: function (e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this }, toArray: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e }, fromBufferAttribute: function (e, t, i) { return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } }), L.prototype = Object.assign(Object.create(n.prototype), { constructor: L, isWebGLRenderTarget: !0, setSize: function (e, t) { this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), R.prototype = Object.assign(Object.create(L.prototype), { constructor: R, isWebGLMultisampleRenderTarget: !0, copy: function (e) { return L.prototype.copy.call(this, e), this.samples = e.samples, this } }), O.prototype = Object.create(L.prototype), O.prototype.constructor = O, O.prototype.isWebGLRenderTargetCube = !0, I.prototype = Object.create(A.prototype), I.prototype.constructor = I, I.prototype.isDataTexture = !0, Object.assign(k.prototype, { isBox3: !0, set: function (e, t) { return this.min.copy(e), this.max.copy(t), this }, setFromArray: function (e) { for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, l = e.length; o < l; o += 3) { var c = e[o], h = e[o + 1], u = e[o + 2]; c < t && (t = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > a && (a = h), u > s && (s = u) } return this.min.set(t, i, n), this.max.set(r, a, s), this }, setFromBufferAttribute: function (e) { for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, s = -1 / 0, o = 0, l = e.count; o < l; o++) { var c = e.getX(o), h = e.getY(o), u = e.getZ(o); c < t && (t = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > a && (a = h), u > s && (s = u) } return this.min.set(t, i, n), this.max.set(r, a, s), this }, setFromPoints: function (e) { this.makeEmpty(); for (var t = 0, i = e.length; t < i; t++)this.expandByPoint(e[t]); return this }, setFromCenterAndSize: function () { var e = new h; return function (t, i) { var n = e.copy(i).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this } }(), setFromObject: function (e) { return this.makeEmpty(), this.expandByObject(e) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.min.copy(e.min), this.max.copy(e.max), this }, makeEmpty: function () { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, getCenter: function (e) { return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new h), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (e) { return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new h), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) }, expandByPoint: function (e) { return this.min.min(e), this.max.max(e), this }, expandByVector: function (e) { return this.min.sub(e), this.max.add(e), this }, expandByScalar: function (e) { return this.min.addScalar(-e), this.max.addScalar(e), this }, expandByObject: function () { var e, t, i, n = new h; function r(r) { var a = r.geometry; if (void 0 !== a) if (a.isGeometry) { var s = a.vertices; for (t = 0, i = s.length; t < i; t++)n.copy(s[t]), n.applyMatrix4(r.matrixWorld), e.expandByPoint(n) } else if (a.isBufferGeometry) { var o = a.attributes.position; if (void 0 !== o) for (t = 0, i = o.count; t < i; t++)n.fromBufferAttribute(o, t).applyMatrix4(r.matrixWorld), e.expandByPoint(n) } } return function (t) { return e = this, t.updateMatrixWorld(!0), t.traverse(r), this } }(), containsPoint: function (e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) }, containsBox: function (e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z }, getParameter: function (e, t) { return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new h), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function (e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) }, intersectsSphere: (m = new h, function (e) { return this.clampPoint(e.center, m), m.distanceToSquared(e.center) <= e.radius * e.radius }), intersectsPlane: function (e) { var t, i; return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant }, intersectsTriangle: function () { var e = new h, t = new h, i = new h, n = new h, r = new h, a = new h, s = new h, o = new h, l = new h, c = new h; function u(n) { var r, a; for (r = 0, a = n.length - 3; r <= a; r += 3) { s.fromArray(n, r); var o = l.x * Math.abs(s.x) + l.y * Math.abs(s.y) + l.z * Math.abs(s.z), c = e.dot(s), h = t.dot(s), u = i.dot(s); if (Math.max(-Math.max(c, h, u), Math.min(c, h, u)) > o) return !1 } return !0 } return function (s) { if (this.isEmpty()) return !1; this.getCenter(o), l.subVectors(this.max, o), e.subVectors(s.a, o), t.subVectors(s.b, o), i.subVectors(s.c, o), n.subVectors(t, e), r.subVectors(i, t), a.subVectors(e, i); var h = [0, -n.z, n.y, 0, -r.z, r.y, 0, -a.z, a.y, n.z, 0, -n.x, r.z, 0, -r.x, a.z, 0, -a.x, -n.y, n.x, 0, -r.y, r.x, 0, -a.y, a.x, 0]; return !!u(h) && (!!u(h = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (c.crossVectors(n, r), u(h = [c.x, c.y, c.z]))) } }(), clampPoint: function (e, t) { return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new h), t.copy(e).clamp(this.min, this.max) }, distanceToPoint: function () { var e = new h; return function (t) { return e.copy(t).clamp(this.min, this.max).sub(t).length() } }(), getBoundingSphere: function () { var e = new h; return function (t) { return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(e).length(), t } }(), intersect: function (e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this }, union: function (e) { return this.min.min(e.min), this.max.max(e.max), this }, applyMatrix4: (f = [new h, new h, new h, new h, new h, new h, new h, new h], function (e) { return this.isEmpty() || (f[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), f[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), f[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), f[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), f[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), f[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), f[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), f[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(f)), this }), translate: function (e) { return this.min.add(e), this.max.add(e), this }, equals: function (e) { return e.min.equals(this.min) && e.max.equals(this.max) } }), Object.assign(D.prototype, { set: function (e, t) { return this.center.copy(e), this.radius = t, this }, setFromPoints: (g = new k, function (e, t) { var i = this.center; void 0 !== t ? i.copy(t) : g.setFromPoints(e).getCenter(i); for (var n = 0, r = 0, a = e.length; r < a; r++)n = Math.max(n, i.distanceToSquared(e[r])); return this.radius = Math.sqrt(n), this }), clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.center.copy(e.center), this.radius = e.radius, this }, empty: function () { return this.radius <= 0 }, containsPoint: function (e) { return e.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (e) { return e.distanceTo(this.center) - this.radius }, intersectsSphere: function (e) { var t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t }, intersectsBox: function (e) { return e.intersectsSphere(this) }, intersectsPlane: function (e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius }, clampPoint: function (e, t) { var i = this.center.distanceToSquared(e); return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new h), t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t }, getBoundingBox: function (e) { return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new k), e.set(this.center, this.center), e.expandByScalar(this.radius), e }, applyMatrix4: function (e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this }, translate: function (e) { return this.center.add(e), this }, equals: function (e) { return e.center.equals(this.center) && e.radius === this.radius } }), Object.assign(z.prototype, { set: function (e, t) { return this.normal.copy(e), this.constant = t, this }, setComponents: function (e, t, i, n) { return this.normal.set(e, t, i), this.constant = n, this }, setFromNormalAndCoplanarPoint: function (e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this }, setFromCoplanarPoints: function () { var e = new h, t = new h; return function (i, n, r) { var a = e.subVectors(r, n).cross(t.subVectors(i, n)).normalize(); return this.setFromNormalAndCoplanarPoint(a, i), this } }(), clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.normal.copy(e.normal), this.constant = e.constant, this }, normalize: function () { var e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this }, negate: function () { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function (e) { return this.normal.dot(e) + this.constant }, distanceToSphere: function (e) { return this.distanceToPoint(e.center) - e.radius }, projectPoint: function (e, t) { return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new h), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) }, intersectLine: function () { var e = new h; return function (t, i) { void 0 === i && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new h); var n = t.delta(e), r = this.normal.dot(n); if (0 === r) return 0 === this.distanceToPoint(t.start) ? i.copy(t.start) : void 0; var a = -(t.start.dot(this.normal) + this.constant) / r; return a < 0 || a > 1 ? void 0 : i.copy(n).multiplyScalar(a).add(t.start) } }(), intersectsLine: function (e) { var t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end); return t < 0 && i > 0 || i < 0 && t > 0 }, intersectsBox: function (e) { return e.intersectsPlane(this) }, intersectsSphere: function (e) { return e.intersectsPlane(this) }, coplanarPoint: function (e) { return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new h), e.copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: function () { var e = new h, t = new u; return function (i, n) { var r = n || t.getNormalMatrix(i), a = this.coplanarPoint(e).applyMatrix4(i), s = this.normal.applyMatrix3(r).normalize(); return this.constant = -a.dot(s), this } }(), translate: function (e) { return this.constant -= e.dot(this.normal), this }, equals: function (e) { return e.normal.equals(this.normal) && e.constant === this.constant } }), Object.assign(N.prototype, { set: function (e, t, i, n, r, a) { var s = this.planes; return s[0].copy(e), s[1].copy(t), s[2].copy(i), s[3].copy(n), s[4].copy(r), s[5].copy(a), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { for (var t = this.planes, i = 0; i < 6; i++)t[i].copy(e.planes[i]); return this }, setFromMatrix: function (e) { var t = this.planes, i = e.elements, n = i[0], r = i[1], a = i[2], s = i[3], o = i[4], l = i[5], c = i[6], h = i[7], u = i[8], d = i[9], p = i[10], f = i[11], m = i[12], g = i[13], v = i[14], y = i[15]; return t[0].setComponents(s - n, h - o, f - u, y - m).normalize(), t[1].setComponents(s + n, h + o, f + u, y + m).normalize(), t[2].setComponents(s + r, h + l, f + d, y + g).normalize(), t[3].setComponents(s - r, h - l, f - d, y - g).normalize(), t[4].setComponents(s - a, h - c, f - p, y - v).normalize(), t[5].setComponents(s + a, h + c, f + p, y + v).normalize(), this }, intersectsObject: (y = new D, function (e) { var t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), y.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(y) }), intersectsSprite: function () { var e = new D; return function (t) { return e.center.set(0, 0, 0), e.radius = .7071067811865476, e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e) } }(), intersectsSphere: function (e) { for (var t = this.planes, i = e.center, n = -e.radius, r = 0; r < 6; r++) { if (t[r].distanceToPoint(i) < n) return !1 } return !0 }, intersectsBox: (v = new h, function (e) { for (var t = this.planes, i = 0; i < 6; i++) { var n = t[i]; if (v.x = n.normal.x > 0 ? e.max.x : e.min.x, v.y = n.normal.y > 0 ? e.max.y : e.min.y, v.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(v) < 0) return !1 } return !0 }), containsPoint: function (e) { for (var t = this.planes, i = 0; i < 6; i++)if (t[i].distanceToPoint(e) < 0) return !1; return !0 } }), Object.assign(B.prototype, { isMatrix4: !0, set: function (e, t, i, n, r, a, s, o, l, c, h, u, d, p, f, m) { var g = this.elements; return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = s, g[13] = o, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this }, identity: function () { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, clone: function () { return (new B).fromArray(this.elements) }, copy: function (e) { var t = this.elements, i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this }, copyPosition: function (e) { var t = this.elements, i = e.elements; return t[12] = i[12], t[13] = i[13], t[14] = i[14], this }, extractBasis: function (e, t, i) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this }, makeBasis: function (e, t, i) { return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this }, extractRotation: function () { var e = new h; return function (t) { var i = this.elements, n = t.elements, r = 1 / e.setFromMatrixColumn(t, 0).length(), a = 1 / e.setFromMatrixColumn(t, 1).length(), s = 1 / e.setFromMatrixColumn(t, 2).length(); return i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = 0, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[7] = 0, i[8] = n[8] * s, i[9] = n[9] * s, i[10] = n[10] * s, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this } }(), makeRotationFromEuler: function (e) { e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var t = this.elements, i = e.x, n = e.y, r = e.z, a = Math.cos(i), s = Math.sin(i), o = Math.cos(n), l = Math.sin(n), c = Math.cos(r), h = Math.sin(r); if ("XYZ" === e.order) { var u = a * c, d = a * h, p = s * c, f = s * h; t[0] = o * c, t[4] = -o * h, t[8] = l, t[1] = d + p * l, t[5] = u - f * l, t[9] = -s * o, t[2] = f - u * l, t[6] = p + d * l, t[10] = a * o } else if ("YXZ" === e.order) { var m = o * c, g = o * h, v = l * c, y = l * h; t[0] = m + y * s, t[4] = v * s - g, t[8] = a * l, t[1] = a * h, t[5] = a * c, t[9] = -s, t[2] = g * s - v, t[6] = y + m * s, t[10] = a * o } else if ("ZXY" === e.order) { m = o * c, g = o * h, v = l * c, y = l * h; t[0] = m - y * s, t[4] = -a * h, t[8] = v + g * s, t[1] = g + v * s, t[5] = a * c, t[9] = y - m * s, t[2] = -a * l, t[6] = s, t[10] = a * o } else if ("ZYX" === e.order) { u = a * c, d = a * h, p = s * c, f = s * h; t[0] = o * c, t[4] = p * l - d, t[8] = u * l + f, t[1] = o * h, t[5] = f * l + u, t[9] = d * l - p, t[2] = -l, t[6] = s * o, t[10] = a * o } else if ("YZX" === e.order) { var _ = a * o, x = a * l, b = s * o, w = s * l; t[0] = o * c, t[4] = w - _ * h, t[8] = b * h + x, t[1] = h, t[5] = a * c, t[9] = -s * c, t[2] = -l * c, t[6] = x * h + b, t[10] = _ - w * h } else if ("XZY" === e.order) { _ = a * o, x = a * l, b = s * o, w = s * l; t[0] = o * c, t[4] = -h, t[8] = l * c, t[1] = _ * h + w, t[5] = a * c, t[9] = x * h - b, t[2] = b * h - x, t[6] = s * c, t[10] = w * h + _ } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this }, makeRotationFromQuaternion: (M = new h(0, 0, 0), S = new h(1, 1, 1), function (e) { return this.compose(M, e, S) }), lookAt: (b = new h, w = new h, T = new h, function (e, t, i) { var n = this.elements; return T.subVectors(e, t), 0 === T.lengthSq() && (T.z = 1), T.normalize(), b.crossVectors(i, T), 0 === b.lengthSq() && (1 === Math.abs(i.z) ? T.x += 1e-4 : T.z += 1e-4, T.normalize(), b.crossVectors(i, T)), b.normalize(), w.crossVectors(T, b), n[0] = b.x, n[4] = w.x, n[8] = T.x, n[1] = b.y, n[5] = w.y, n[9] = T.y, n[2] = b.z, n[6] = w.z, n[10] = T.z, this }), multiply: function (e, t) { return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e) }, premultiply: function (e) { return this.multiplyMatrices(e, this) }, multiplyMatrices: function (e, t) { var i = e.elements, n = t.elements, r = this.elements, a = i[0], s = i[4], o = i[8], l = i[12], c = i[1], h = i[5], u = i[9], d = i[13], p = i[2], f = i[6], m = i[10], g = i[14], v = i[3], y = i[7], _ = i[11], x = i[15], b = n[0], w = n[4], T = n[8], M = n[12], S = n[1], E = n[5], C = n[9], A = n[13], P = n[2], L = n[6], R = n[10], O = n[14], I = n[3], k = n[7], D = n[11], z = n[15]; return r[0] = a * b + s * S + o * P + l * I, r[4] = a * w + s * E + o * L + l * k, r[8] = a * T + s * C + o * R + l * D, r[12] = a * M + s * A + o * O + l * z, r[1] = c * b + h * S + u * P + d * I, r[5] = c * w + h * E + u * L + d * k, r[9] = c * T + h * C + u * R + d * D, r[13] = c * M + h * A + u * O + d * z, r[2] = p * b + f * S + m * P + g * I, r[6] = p * w + f * E + m * L + g * k, r[10] = p * T + f * C + m * R + g * D, r[14] = p * M + f * A + m * O + g * z, r[3] = v * b + y * S + _ * P + x * I, r[7] = v * w + y * E + _ * L + x * k, r[11] = v * T + y * C + _ * R + x * D, r[15] = v * M + y * A + _ * O + x * z, this }, multiplyScalar: function (e) { var t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this }, applyToBufferAttribute: function () { var e = new h; return function (t) { for (var i = 0, n = t.count; i < n; i++)e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.applyMatrix4(this), t.setXYZ(i, e.x, e.y, e.z); return t } }(), determinant: function () { var e = this.elements, t = e[0], i = e[4], n = e[8], r = e[12], a = e[1], s = e[5], o = e[9], l = e[13], c = e[2], h = e[6], u = e[10], d = e[14]; return e[3] * (+r * o * h - n * l * h - r * s * u + i * l * u + n * s * d - i * o * d) + e[7] * (+t * o * d - t * l * u + r * a * u - n * a * d + n * l * c - r * o * c) + e[11] * (+t * l * h - t * s * d - r * a * h + i * a * d + r * s * c - i * l * c) + e[15] * (-n * s * c - t * o * h + t * s * u + n * a * h - i * a * u + i * o * c) }, transpose: function () { var e, t = this.elements; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this }, setPosition: function (e, t, i) { var n = this.elements; return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this }, getInverse: function (e, t) { var i = this.elements, n = e.elements, r = n[0], a = n[1], s = n[2], o = n[3], l = n[4], c = n[5], h = n[6], u = n[7], d = n[8], p = n[9], f = n[10], m = n[11], g = n[12], v = n[13], y = n[14], _ = n[15], x = p * y * u - v * f * u + v * h * m - c * y * m - p * h * _ + c * f * _, b = g * f * u - d * y * u - g * h * m + l * y * m + d * h * _ - l * f * _, w = d * v * u - g * p * u + g * c * m - l * v * m - d * c * _ + l * p * _, T = g * p * h - d * v * h - g * c * f + l * v * f + d * c * y - l * p * y, M = r * x + a * b + s * w + o * T; if (0 === M) { var S = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"; if (!0 === t) throw new Error(S); return console.warn(S), this.identity() } var E = 1 / M; return i[0] = x * E, i[1] = (v * f * o - p * y * o - v * s * m + a * y * m + p * s * _ - a * f * _) * E, i[2] = (c * y * o - v * h * o + v * s * u - a * y * u - c * s * _ + a * h * _) * E, i[3] = (p * h * o - c * f * o - p * s * u + a * f * u + c * s * m - a * h * m) * E, i[4] = b * E, i[5] = (d * y * o - g * f * o + g * s * m - r * y * m - d * s * _ + r * f * _) * E, i[6] = (g * h * o - l * y * o - g * s * u + r * y * u + l * s * _ - r * h * _) * E, i[7] = (l * f * o - d * h * o + d * s * u - r * f * u - l * s * m + r * h * m) * E, i[8] = w * E, i[9] = (g * p * o - d * v * o - g * a * m + r * v * m + d * a * _ - r * p * _) * E, i[10] = (l * v * o - g * c * o + g * a * u - r * v * u - l * a * _ + r * c * _) * E, i[11] = (d * c * o - l * p * o - d * a * u + r * p * u + l * a * m - r * c * m) * E, i[12] = T * E, i[13] = (d * v * s - g * p * s + g * a * f - r * v * f - d * a * y + r * p * y) * E, i[14] = (g * c * s - l * v * s - g * a * h + r * v * h + l * a * y - r * c * y) * E, i[15] = (l * p * s - d * c * s + d * a * h - r * p * h - l * a * f + r * c * f) * E, this }, scale: function (e) { var t = this.elements, i = e.x, n = e.y, r = e.z; return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this }, getMaxScaleOnAxis: function () { var e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, i, n)) }, makeTranslation: function (e, t, i) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this }, makeRotationX: function (e) { var t = Math.cos(e), i = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this }, makeRotationY: function (e) { var t = Math.cos(e), i = Math.sin(e); return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this }, makeRotationZ: function (e) { var t = Math.cos(e), i = Math.sin(e); return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, makeRotationAxis: function (e, t) { var i = Math.cos(t), n = Math.sin(t), r = 1 - i, a = e.x, s = e.y, o = e.z, l = r * a, c = r * s; return this.set(l * a + i, l * s - n * o, l * o + n * s, 0, l * s + n * o, c * s + i, c * o - n * a, 0, l * o - n * s, c * o + n * a, r * o * o + i, 0, 0, 0, 0, 1), this }, makeScale: function (e, t, i) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this }, makeShear: function (e, t, i) { return this.set(1, t, i, 0, e, 1, i, 0, e, t, 1, 0, 0, 0, 0, 1), this }, compose: function (e, t, i) { var n = this.elements, r = t._x, a = t._y, s = t._z, o = t._w, l = r + r, c = a + a, h = s + s, u = r * l, d = r * c, p = r * h, f = a * c, m = a * h, g = s * h, v = o * l, y = o * c, _ = o * h, x = i.x, b = i.y, w = i.z; return n[0] = (1 - (f + g)) * x, n[1] = (d + _) * x, n[2] = (p - y) * x, n[3] = 0, n[4] = (d - _) * b, n[5] = (1 - (u + g)) * b, n[6] = (m + v) * b, n[7] = 0, n[8] = (p + y) * w, n[9] = (m - v) * w, n[10] = (1 - (u + f)) * w, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this }, decompose: (_ = new h, x = new B, function (e, t, i) { var n = this.elements, r = _.set(n[0], n[1], n[2]).length(), a = _.set(n[4], n[5], n[6]).length(), s = _.set(n[8], n[9], n[10]).length(); this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], x.copy(this); var o = 1 / r, l = 1 / a, c = 1 / s; return x.elements[0] *= o, x.elements[1] *= o, x.elements[2] *= o, x.elements[4] *= l, x.elements[5] *= l, x.elements[6] *= l, x.elements[8] *= c, x.elements[9] *= c, x.elements[10] *= c, t.setFromRotationMatrix(x), i.x = r, i.y = a, i.z = s, this }), makePerspective: function (e, t, i, n, r, a) { void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); var s = this.elements, o = 2 * r / (t - e), l = 2 * r / (i - n), c = (t + e) / (t - e), h = (i + n) / (i - n), u = -(a + r) / (a - r), d = -2 * a * r / (a - r); return s[0] = o, s[4] = 0, s[8] = c, s[12] = 0, s[1] = 0, s[5] = l, s[9] = h, s[13] = 0, s[2] = 0, s[6] = 0, s[10] = u, s[14] = d, s[3] = 0, s[7] = 0, s[11] = -1, s[15] = 0, this }, makeOrthographic: function (e, t, i, n, r, a) { var s = this.elements, o = 1 / (t - e), l = 1 / (i - n), c = 1 / (a - r), h = (t + e) * o, u = (i + n) * l, d = (a + r) * c; return s[0] = 2 * o, s[4] = 0, s[8] = 0, s[12] = -h, s[1] = 0, s[5] = 2 * l, s[9] = 0, s[13] = -u, s[2] = 0, s[6] = 0, s[10] = -2 * c, s[14] = -d, s[3] = 0, s[7] = 0, s[11] = 0, s[15] = 1, this }, equals: function (e) { for (var t = this.elements, i = e.elements, n = 0; n < 16; n++)if (t[n] !== i[n]) return !1; return !0 }, fromArray: function (e, t) { void 0 === t && (t = 0); for (var i = 0; i < 16; i++)this.elements[i] = e[i + t]; return this }, toArray: function (e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); var i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e } }); var F = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif", lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif", map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif", normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}", uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }; function G(e) { var t = {}; for (var i in e) for (var n in t[i] = {}, e[i]) { var r = e[i][n]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? t[i][n] = r.clone() : Array.isArray(r) ? t[i][n] = r.slice() : t[i][n] = r } return t } function U(e) { for (var t = {}, i = 0; i < e.length; i++) { var n = G(e[i]); for (var r in n) t[r] = n[r] } return t } var H, V, j, W = { clone: G, merge: U }, $ = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; function X(e, t, i) { return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i) } Object.assign(X.prototype, { isColor: !0, r: 1, g: 1, b: 1, set: function (e) { return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this }, setScalar: function (e) { return this.r = e, this.g = e, this.b = e, this }, setHex: function (e) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this }, setRGB: function (e, t, i) { return this.r = e, this.g = t, this.b = i, this }, setHSL: function () { function e(e, t, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e } return function (t, i, n) { if (t = o.euclideanModulo(t, 1), i = o.clamp(i, 0, 1), n = o.clamp(n, 0, 1), 0 === i) this.r = this.g = this.b = n; else { var r = n <= .5 ? n * (1 + i) : n + i - n * i, a = 2 * n - r; this.r = e(a, r, t + 1 / 3), this.g = e(a, r, t), this.b = e(a, r, t - 1 / 3) } return this } }(), setStyle: function (e) { function t(t) { void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.") } var i; if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) { var n, r = i[1], a = i[2]; switch (r) { case "rgb": case "rgba": if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[5]), this; if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[5]), this; break; case "hsl": case "hsla": if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) { var s = parseFloat(n[1]) / 360, o = parseInt(n[2], 10) / 100, l = parseInt(n[3], 10) / 100; return t(n[5]), this.setHSL(s, o, l) } } } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(e)) { var c, h = (c = i[1]).length; if (3 === h) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this; if (6 === h) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this } e && e.length > 0 && (void 0 !== (c = $[e]) ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + e)); return this }, clone: function () { return new this.constructor(this.r, this.g, this.b) }, copy: function (e) { return this.r = e.r, this.g = e.g, this.b = e.b, this }, copyGammaToLinear: function (e, t) { return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this }, copyLinearToGamma: function (e, t) { void 0 === t && (t = 2); var i = t > 0 ? 1 / t : 1; return this.r = Math.pow(e.r, i), this.g = Math.pow(e.g, i), this.b = Math.pow(e.b, i), this }, convertGammaToLinear: function (e) { return this.copyGammaToLinear(this, e), this }, convertLinearToGamma: function (e) { return this.copyLinearToGamma(this, e), this }, copySRGBToLinear: function () { function e(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } return function (t) { return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this } }(), copyLinearToSRGB: function () { function e(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } return function (t) { return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this } }(), convertSRGBToLinear: function () { return this.copySRGBToLinear(this), this }, convertLinearToSRGB: function () { return this.copyLinearToSRGB(this), this }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function (e) { void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = { h: 0, s: 0, l: 0 }); var t, i, n = this.r, r = this.g, a = this.b, s = Math.max(n, r, a), o = Math.min(n, r, a), l = (o + s) / 2; if (o === s) t = 0, i = 0; else { var c = s - o; switch (i = l <= .5 ? c / (s + o) : c / (2 - s - o), s) { case n: t = (r - a) / c + (r < a ? 6 : 0); break; case r: t = (a - n) / c + 2; break; case a: t = (n - r) / c + 4 }t /= 6 } return e.h = t, e.s = i, e.l = l, e }, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: (j = {}, function (e, t, i) { return this.getHSL(j), j.h += e, j.s += t, j.l += i, this.setHSL(j.h, j.s, j.l), this }), add: function (e) { return this.r += e.r, this.g += e.g, this.b += e.b, this }, addColors: function (e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this }, addScalar: function (e) { return this.r += e, this.g += e, this.b += e, this }, sub: function (e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this }, multiply: function (e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this }, multiplyScalar: function (e) { return this.r *= e, this.g *= e, this.b *= e, this }, lerp: function (e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this }, lerpHSL: (H = { h: 0, s: 0, l: 0 }, V = { h: 0, s: 0, l: 0 }, function (e, t) { this.getHSL(H), e.getHSL(V); var i = o.lerp(H.h, V.h, t), n = o.lerp(H.s, V.s, t), r = o.lerp(H.l, V.l, t); return this.setHSL(i, n, r), this }), equals: function (e) { return e.r === this.r && e.g === this.g && e.b === this.b }, fromArray: function (e, t) { return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this }, toArray: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e }, toJSON: function () { return this.getHex() } }); var Y, q = { common: { diffuse: { value: new X(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new u }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new l(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new X(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new X(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, uvTransform: { value: new u } }, sprite: { diffuse: { value: new X(15658734) }, opacity: { value: 1 }, center: { value: new l(.5, .5) }, rotation: { value: 0 }, map: { value: null }, uvTransform: { value: new u } } }, J = { basic: { uniforms: U([q.common, q.specularmap, q.envmap, q.aomap, q.lightmap, q.fog]), vertexShader: F.meshbasic_vert, fragmentShader: F.meshbasic_frag }, lambert: { uniforms: U([q.common, q.specularmap, q.envmap, q.aomap, q.lightmap, q.emissivemap, q.fog, q.lights, { emissive: { value: new X(0) } }]), vertexShader: F.meshlambert_vert, fragmentShader: F.meshlambert_frag }, phong: { uniforms: U([q.common, q.specularmap, q.envmap, q.aomap, q.lightmap, q.emissivemap, q.bumpmap, q.normalmap, q.displacementmap, q.gradientmap, q.fog, q.lights, { emissive: { value: new X(0) }, specular: { value: new X(1118481) }, shininess: { value: 30 } }]), vertexShader: F.meshphong_vert, fragmentShader: F.meshphong_frag }, standard: { uniforms: U([q.common, q.envmap, q.aomap, q.lightmap, q.emissivemap, q.bumpmap, q.normalmap, q.displacementmap, q.roughnessmap, q.metalnessmap, q.fog, q.lights, { emissive: { value: new X(0) }, roughness: { value: .5 }, metalness: { value: .5 }, envMapIntensity: { value: 1 } }]), vertexShader: F.meshphysical_vert, fragmentShader: F.meshphysical_frag }, matcap: { uniforms: U([q.common, q.bumpmap, q.normalmap, q.displacementmap, q.fog, { matcap: { value: null } }]), vertexShader: F.meshmatcap_vert, fragmentShader: F.meshmatcap_frag }, points: { uniforms: U([q.points, q.fog]), vertexShader: F.points_vert, fragmentShader: F.points_frag }, dashed: { uniforms: U([q.common, q.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: F.linedashed_vert, fragmentShader: F.linedashed_frag }, depth: { uniforms: U([q.common, q.displacementmap]), vertexShader: F.depth_vert, fragmentShader: F.depth_frag }, normal: { uniforms: U([q.common, q.bumpmap, q.normalmap, q.displacementmap, { opacity: { value: 1 } }]), vertexShader: F.normal_vert, fragmentShader: F.normal_frag }, sprite: { uniforms: U([q.sprite, q.fog]), vertexShader: F.sprite_vert, fragmentShader: F.sprite_frag }, background: { uniforms: { uvTransform: { value: new u }, t2D: { value: null } }, vertexShader: F.background_vert, fragmentShader: F.background_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: F.cube_vert, fragmentShader: F.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: F.equirect_vert, fragmentShader: F.equirect_frag }, distanceRGBA: { uniforms: U([q.common, q.displacementmap, { referencePosition: { value: new h }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: F.distanceRGBA_vert, fragmentShader: F.distanceRGBA_frag }, shadow: { uniforms: U([q.lights, q.fog, { color: { value: new X(0) }, opacity: { value: 1 } }]), vertexShader: F.shadow_vert, fragmentShader: F.shadow_frag } }; function Z() { var e = null, t = !1, i = null; function n(r, a) { !1 !== t && (i(r, a), e.requestAnimationFrame(n)) } return { start: function () { !0 !== t && null !== i && (e.requestAnimationFrame(n), t = !0) }, stop: function () { t = !1 }, setAnimationLoop: function (e) { i = e }, setContext: function (t) { e = t } } } function K(e) { var t = new WeakMap; return { get: function (e) { return e.isInterleavedBufferAttribute && (e = e.data), t.get(e) }, remove: function (i) { i.isInterleavedBufferAttribute && (i = i.data); var n = t.get(i); n && (e.deleteBuffer(n.buffer), t.delete(i)) }, update: function (i, n) { i.isInterleavedBufferAttribute && (i = i.data); var r = t.get(i); void 0 === r ? t.set(i, function (t, i) { var n = t.array, r = t.dynamic ? 35048 : 35044, a = e.createBuffer(); e.bindBuffer(i, a), e.bufferData(i, n, r), t.onUploadCallback(); var s = 5126; return n instanceof Float32Array ? s = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? s = 5123 : n instanceof Int16Array ? s = 5122 : n instanceof Uint32Array ? s = 5125 : n instanceof Int32Array ? s = 5124 : n instanceof Int8Array ? s = 5120 : n instanceof Uint8Array && (s = 5121), { buffer: a, type: s, bytesPerElement: n.BYTES_PER_ELEMENT, version: t.version } }(i, n)) : r.version < i.version && (!function (t, i, n) { var r = i.array, a = i.updateRange; e.bindBuffer(n, t), !1 === i.dynamic ? e.bufferData(n, r, 35044) : -1 === a.count ? e.bufferSubData(n, 0, r) : 0 === a.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(n, a.offset * r.BYTES_PER_ELEMENT, r.subarray(a.offset, a.offset + a.count)), a.count = -1) }(r.buffer, i, n), r.version = i.version) } } } function Q(e, t, i, n, r, a) { this.a = e, this.b = t, this.c = i, this.normal = n && n.isVector3 ? n : new h, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new X, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0 } function ee(e, t, i, n) { this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = n || ee.DefaultOrder } function te() { this.mask = 1 } J.physical = { uniforms: U([J.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]), vertexShader: F.meshphysical_vert, fragmentShader: F.meshphysical_frag }, Object.assign(Q.prototype, { clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex; for (var t = 0, i = e.vertexNormals.length; t < i; t++)this.vertexNormals[t] = e.vertexNormals[t].clone(); for (t = 0, i = e.vertexColors.length; t < i; t++)this.vertexColors[t] = e.vertexColors[t].clone(); return this } }), ee.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], ee.DefaultOrder = "XYZ", Object.defineProperties(ee.prototype, { x: { get: function () { return this._x }, set: function (e) { this._x = e, this.onChangeCallback() } }, y: { get: function () { return this._y }, set: function (e) { this._y = e, this.onChangeCallback() } }, z: { get: function () { return this._z }, set: function (e) { this._z = e, this.onChangeCallback() } }, order: { get: function () { return this._order }, set: function (e) { this._order = e, this.onChangeCallback() } } }), Object.assign(ee.prototype, { isEuler: !0, set: function (e, t, i, n) { return this._x = e, this._y = t, this._z = i, this._order = n || this._order, this.onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function (e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this }, setFromRotationMatrix: function (e, t, i) { var n = o.clamp, r = e.elements, a = r[0], s = r[4], l = r[8], c = r[1], h = r[5], u = r[9], d = r[2], p = r[6], f = r[10]; return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(n(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(-u, f), this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(p, h), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(l, f), this._z = Math.atan2(c, h)) : (this._y = Math.atan2(-d, a), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2(-d, f), this._z = Math.atan2(-s, h)) : (this._y = 0, this._z = Math.atan2(c, a))) : "ZYX" === t ? (this._y = Math.asin(-n(d, -1, 1)), Math.abs(d) < .99999 ? (this._x = Math.atan2(p, f), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-s, h))) : "YZX" === t ? (this._z = Math.asin(n(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-u, h), this._y = Math.atan2(-d, a)) : (this._x = 0, this._y = Math.atan2(l, f))) : "XZY" === t ? (this._z = Math.asin(-n(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(p, h), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-u, f), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== i && this.onChangeCallback(), this }, setFromQuaternion: function () { var e = new B; return function (t, i, n) { return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, i, n) } }(), setFromVector3: function (e, t) { return this.set(e.x, e.y, e.z, t || this._order) }, reorder: (Y = new c, function (e) { return Y.setFromEuler(this), this.setFromQuaternion(Y, e) }), equals: function (e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order }, fromArray: function (e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this }, toArray: function (e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e }, toVector3: function (e) { return e ? e.set(this._x, this._y, this._z) : new h(this._x, this._y, this._z) }, onChange: function (e) { return this.onChangeCallback = e, this }, onChangeCallback: function () { } }), Object.assign(te.prototype, { set: function (e) { this.mask = 1 << e | 0 }, enable: function (e) { this.mask |= 1 << e | 0 }, toggle: function (e) { this.mask ^= 1 << e | 0 }, disable: function (e) { this.mask &= ~(1 << e | 0) }, test: function (e) { return 0 != (this.mask & e.mask) } }); var ie, ne, re, ae, se, oe = 0; function le() { Object.defineProperty(this, "id", { value: oe++ }), this.uuid = o.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = le.DefaultUp.clone(); var e = new h, t = new ee, i = new c, n = new h(1, 1, 1); t.onChange((function () { i.setFromEuler(t, !1) })), i.onChange((function () { t.setFromQuaternion(i, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: n }, modelViewMatrix: { value: new B }, normalMatrix: { value: new u } }), this.matrix = new B, this.matrixWorld = new B, this.matrixAutoUpdate = le.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new te, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} } le.DefaultUp = new h(0, 1, 0), le.DefaultMatrixAutoUpdate = !0, le.prototype = Object.assign(Object.create(n.prototype), { constructor: le, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix: function (e) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (e) { return this.quaternion.premultiply(e), this }, setRotationFromAxisAngle: function (e, t) { this.quaternion.setFromAxisAngle(e, t) }, setRotationFromEuler: function (e) { this.quaternion.setFromEuler(e, !0) }, setRotationFromMatrix: function (e) { this.quaternion.setFromRotationMatrix(e) }, setRotationFromQuaternion: function (e) { this.quaternion.copy(e) }, rotateOnAxis: (se = new c, function (e, t) { return se.setFromAxisAngle(e, t), this.quaternion.multiply(se), this }), rotateOnWorldAxis: function () { var e = new c; return function (t, i) { return e.setFromAxisAngle(t, i), this.quaternion.premultiply(e), this } }(), rotateX: function () { var e = new h(1, 0, 0); return function (t) { return this.rotateOnAxis(e, t) } }(), rotateY: function () { var e = new h(0, 1, 0); return function (t) { return this.rotateOnAxis(e, t) } }(), rotateZ: function () { var e = new h(0, 0, 1); return function (t) { return this.rotateOnAxis(e, t) } }(), translateOnAxis: function () { var e = new h; return function (t, i) { return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(i)), this } }(), translateX: function () { var e = new h(1, 0, 0); return function (t) { return this.translateOnAxis(e, t) } }(), translateY: function () { var e = new h(0, 1, 0); return function (t) { return this.translateOnAxis(e, t) } }(), translateZ: function () { var e = new h(0, 0, 1); return function (t) { return this.translateOnAxis(e, t) } }(), localToWorld: function (e) { return e.applyMatrix4(this.matrixWorld) }, worldToLocal: (ae = new B, function (e) { return e.applyMatrix4(ae.getInverse(this.matrixWorld)) }), lookAt: function () { var e = new c, t = new B, i = new h, n = new h; return function (r, a, s) { r.isVector3 ? i.copy(r) : i.set(r, a, s); var o = this.parent; this.updateWorldMatrix(!0, !1), n.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? t.lookAt(n, i, this.up) : t.lookAt(i, n, this.up), this.quaternion.setFromRotationMatrix(t), o && (t.extractRotation(o.matrixWorld), e.setFromRotationMatrix(t), this.quaternion.premultiply(e.inverse())) } }(), add: function (e) { if (arguments.length > 1) { for (var t = 0; t < arguments.length; t++)this.add(arguments[t]); return this } return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({ type: "added" }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this) }, remove: function (e) { if (arguments.length > 1) { for (var t = 0; t < arguments.length; t++)this.remove(arguments[t]); return this } var i = this.children.indexOf(e); return -1 !== i && (e.parent = null, e.dispatchEvent({ type: "removed" }), this.children.splice(i, 1)), this }, attach: (re = new B, function (e) { return this.updateWorldMatrix(!0, !1), re.getInverse(this.matrixWorld), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), re.multiply(e.parent.matrixWorld)), e.applyMatrix(re), e.updateWorldMatrix(!1, !1), this.add(e), this }), getObjectById: function (e) { return this.getObjectByProperty("id", e) }, getObjectByName: function (e) { return this.getObjectByProperty("name", e) }, getObjectByProperty: function (e, t) { if (this[e] === t) return this; for (var i = 0, n = this.children.length; i < n; i++) { var r = this.children[i].getObjectByProperty(e, t); if (void 0 !== r) return r } }, getWorldPosition: function (e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new h), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: (ie = new h, ne = new h, function (e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new c), this.updateMatrixWorld(!0), this.matrixWorld.decompose(ie, e, ne), e }), getWorldScale: function () { var e = new h, t = new c; return function (i) { return void 0 === i && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), i = new h), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, i), i } }(), getWorldDirection: function (e) { void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new h), this.updateMatrixWorld(!0); var t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() }, raycast: function () { }, traverse: function (e) { e(this); for (var t = this.children, i = 0, n = t.length; i < n; i++)t[i].traverse(e) }, traverseVisible: function (e) { if (!1 !== this.visible) { e(this); for (var t = this.children, i = 0, n = t.length; i < n; i++)t[i].traverseVisible(e) } }, traverseAncestors: function (e) { var t = this.parent; null !== t && (e(t), t.traverseAncestors(e)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0); for (var t = this.children, i = 0, n = t.length; i < n; i++)t[i].updateMatrixWorld(e) }, updateWorldMatrix: function (e, t) { var i = this.parent; if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) for (var n = this.children, r = 0, a = n.length; r < a; r++)n[r].updateWorldMatrix(!1, !0) }, toJSON: function (e) { var t = void 0 === e || "string" == typeof e, i = {}; t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, i.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); var n = {}; function r(t, i) { return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isMesh && 0 !== this.drawMode && (n.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) { n.geometry = r(e.geometries, this.geometry); var a = this.geometry.parameters; if (void 0 !== a && void 0 !== a.shapes) { var s = a.shapes; if (Array.isArray(s)) for (var o = 0, l = s.length; o < l; o++) { var c = s[o]; r(e.shapes, c) } else r(e.shapes, s) } } if (void 0 !== this.material) if (Array.isArray(this.material)) { var h = []; for (o = 0, l = this.material.length; o < l; o++)h.push(r(e.materials, this.material[o])); n.material = h } else n.material = r(e.materials, this.material); if (this.children.length > 0) { n.children = []; for (o = 0; o < this.children.length; o++)n.children.push(this.children[o].toJSON(e).object) } if (t) { var u = m(e.geometries), d = m(e.materials), p = m(e.textures), f = m(e.images); s = m(e.shapes); u.length > 0 && (i.geometries = u), d.length > 0 && (i.materials = d), p.length > 0 && (i.textures = p), f.length > 0 && (i.images = f), s.length > 0 && (i.shapes = s) } return i.object = n, i; function m(e) { var t = []; for (var i in e) { var n = e[i]; delete n.metadata, t.push(n) } return t } }, clone: function (e) { return (new this.constructor).copy(this, e) }, copy: function (e, t) { if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t) for (var i = 0; i < e.children.length; i++) { var n = e.children[i]; this.add(n.clone()) } return this } }); var ce, he, ue = 0; function de() { Object.defineProperty(this, "id", { value: ue += 2 }), this.uuid = o.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1 } function pe(e, t, i) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function fe(e, t, i) { pe.call(this, new Int8Array(e), t, i) } function me(e, t, i) { pe.call(this, new Uint8Array(e), t, i) } function ge(e, t, i) { pe.call(this, new Uint8ClampedArray(e), t, i) } function ve(e, t, i) { pe.call(this, new Int16Array(e), t, i) } function ye(e, t, i) { pe.call(this, new Uint16Array(e), t, i) } function _e(e, t, i) { pe.call(this, new Int32Array(e), t, i) } function xe(e, t, i) { pe.call(this, new Uint32Array(e), t, i) } function be(e, t, i) { pe.call(this, new Float32Array(e), t, i) } function we(e, t, i) { pe.call(this, new Float64Array(e), t, i) } function Te() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 } function Me(e) { if (0 === e.length) return -1 / 0; for (var t = e[0], i = 1, n = e.length; i < n; ++i)e[i] > t && (t = e[i]); return t } de.prototype = Object.assign(Object.create(n.prototype), { constructor: de, isGeometry: !0, applyMatrix: function (e) { for (var t = (new u).getNormalMatrix(e), i = 0, n = this.vertices.length; i < n; i++) { this.vertices[i].applyMatrix4(e) } for (i = 0, n = this.faces.length; i < n; i++) { var r = this.faces[i]; r.normal.applyMatrix3(t).normalize(); for (var a = 0, s = r.vertexNormals.length; a < s; a++)r.vertexNormals[a].applyMatrix3(t).normalize() } return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this }, rotateX: function () { var e = new B; return function (t) { return e.makeRotationX(t), this.applyMatrix(e), this } }(), rotateY: function () { var e = new B; return function (t) { return e.makeRotationY(t), this.applyMatrix(e), this } }(), rotateZ: function () { var e = new B; return function (t) { return e.makeRotationZ(t), this.applyMatrix(e), this } }(), translate: function () { var e = new B; return function (t, i, n) { return e.makeTranslation(t, i, n), this.applyMatrix(e), this } }(), scale: function () { var e = new B; return function (t, i, n) { return e.makeScale(t, i, n), this.applyMatrix(e), this } }(), lookAt: (he = new le, function (e) { he.lookAt(e), he.updateMatrix(), this.applyMatrix(he.matrix) }), fromBufferGeometry: function (e) { var t = this, i = null !== e.index ? e.index.array : void 0, n = e.attributes, r = n.position.array, a = void 0 !== n.normal ? n.normal.array : void 0, s = void 0 !== n.color ? n.color.array : void 0, o = void 0 !== n.uv ? n.uv.array : void 0, c = void 0 !== n.uv2 ? n.uv2.array : void 0; void 0 !== c && (this.faceVertexUvs[1] = []); for (var u = 0; u < r.length; u += 3)t.vertices.push((new h).fromArray(r, u)), void 0 !== s && t.colors.push((new X).fromArray(s, u)); function d(e, i, n, r) { var u = void 0 === s ? [] : [t.colors[e].clone(), t.colors[i].clone(), t.colors[n].clone()], d = new Q(e, i, n, void 0 === a ? [] : [(new h).fromArray(a, 3 * e), (new h).fromArray(a, 3 * i), (new h).fromArray(a, 3 * n)], u, r); t.faces.push(d), void 0 !== o && t.faceVertexUvs[0].push([(new l).fromArray(o, 2 * e), (new l).fromArray(o, 2 * i), (new l).fromArray(o, 2 * n)]), void 0 !== c && t.faceVertexUvs[1].push([(new l).fromArray(c, 2 * e), (new l).fromArray(c, 2 * i), (new l).fromArray(c, 2 * n)]) } var p = e.groups; if (p.length > 0) for (u = 0; u < p.length; u++)for (var f = p[u], m = f.start, g = m, v = m + f.count; g < v; g += 3)void 0 !== i ? d(i[g], i[g + 1], i[g + 2], f.materialIndex) : d(g, g + 1, g + 2, f.materialIndex); else if (void 0 !== i) for (u = 0; u < i.length; u += 3)d(i[u], i[u + 1], i[u + 2]); else for (u = 0; u < r.length / 3; u += 3)d(u, u + 1, u + 2); return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this }, center: (ce = new h, function () { return this.computeBoundingBox(), this.boundingBox.getCenter(ce).negate(), this.translate(ce.x, ce.y, ce.z), this }), normalize: function () { this.computeBoundingSphere(); var e = this.boundingSphere.center, t = this.boundingSphere.radius, i = 0 === t ? 1 : 1 / t, n = new B; return n.set(i, 0, 0, -i * e.x, 0, i, 0, -i * e.y, 0, 0, i, -i * e.z, 0, 0, 0, 1), this.applyMatrix(n), this }, computeFaceNormals: function () { for (var e = new h, t = new h, i = 0, n = this.faces.length; i < n; i++) { var r = this.faces[i], a = this.vertices[r.a], s = this.vertices[r.b], o = this.vertices[r.c]; e.subVectors(o, s), t.subVectors(a, s), e.cross(t), e.normalize(), r.normal.copy(e) } }, computeVertexNormals: function (e) { var t, i, n, r, a, s; for (void 0 === e && (e = !0), s = new Array(this.vertices.length), t = 0, i = this.vertices.length; t < i; t++)s[t] = new h; if (e) { var o, l, c, u = new h, d = new h; for (n = 0, r = this.faces.length; n < r; n++)a = this.faces[n], o = this.vertices[a.a], l = this.vertices[a.b], c = this.vertices[a.c], u.subVectors(c, l), d.subVectors(o, l), u.cross(d), s[a.a].add(u), s[a.b].add(u), s[a.c].add(u) } else for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++)s[(a = this.faces[n]).a].add(a.normal), s[a.b].add(a.normal), s[a.c].add(a.normal); for (t = 0, i = this.vertices.length; t < i; t++)s[t].normalize(); for (n = 0, r = this.faces.length; n < r; n++) { var p = (a = this.faces[n]).vertexNormals; 3 === p.length ? (p[0].copy(s[a.a]), p[1].copy(s[a.b]), p[2].copy(s[a.c])) : (p[0] = s[a.a].clone(), p[1] = s[a.b].clone(), p[2] = s[a.c].clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeFlatVertexNormals: function () { var e, t, i; for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) { var n = (i = this.faces[e]).vertexNormals; 3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function () { var e, t, i, n, r; for (i = 0, n = this.faces.length; i < n; i++)for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), e = 0, t = r.vertexNormals.length; e < t; e++)r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone(); var a = new de; for (a.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) { if (!this.morphNormals[e]) { this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = []; var s = this.morphNormals[e].faceNormals, o = this.morphNormals[e].vertexNormals; for (i = 0, n = this.faces.length; i < n; i++)l = new h, c = { a: new h, b: new h, c: new h }, s.push(l), o.push(c) } var l, c, u = this.morphNormals[e]; for (a.vertices = this.morphTargets[e].vertices, a.computeFaceNormals(), a.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++)r = this.faces[i], l = u.faceNormals[i], c = u.vertexNormals[i], l.copy(r.normal), c.a.copy(r.vertexNormals[0]), c.b.copy(r.vertexNormals[1]), c.c.copy(r.vertexNormals[2]) } for (i = 0, n = this.faces.length; i < n; i++)(r = this.faces[i]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new k), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new D), this.boundingSphere.setFromPoints(this.vertices) }, merge: function (e, t, i) { if (e && e.isGeometry) { var n, r = this.vertices.length, a = this.vertices, s = e.vertices, o = this.faces, l = e.faces, c = this.faceVertexUvs[0], h = e.faceVertexUvs[0], d = this.colors, p = e.colors; void 0 === i && (i = 0), void 0 !== t && (n = (new u).getNormalMatrix(t)); for (var f = 0, m = s.length; f < m; f++) { var g = s[f].clone(); void 0 !== t && g.applyMatrix4(t), a.push(g) } for (f = 0, m = p.length; f < m; f++)d.push(p[f].clone()); for (f = 0, m = l.length; f < m; f++) { var v, y, _, x = l[f], b = x.vertexNormals, w = x.vertexColors; (v = new Q(x.a + r, x.b + r, x.c + r)).normal.copy(x.normal), void 0 !== n && v.normal.applyMatrix3(n).normalize(); for (var T = 0, M = b.length; T < M; T++)y = b[T].clone(), void 0 !== n && y.applyMatrix3(n).normalize(), v.vertexNormals.push(y); v.color.copy(x.color); for (T = 0, M = w.length; T < M; T++)_ = w[T], v.vertexColors.push(_.clone()); v.materialIndex = x.materialIndex + i, o.push(v) } for (f = 0, m = h.length; f < m; f++) { var S = h[f], E = []; if (void 0 !== S) { for (T = 0, M = S.length; T < M; T++)E.push(S[T].clone()); c.push(E) } } } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e) }, mergeMesh: function (e) { e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e) }, mergeVertices: function () { var e, t, i, n, r, a, s, o, l = {}, c = [], h = [], u = Math.pow(10, 4); for (i = 0, n = this.vertices.length; i < n; i++)e = this.vertices[i], void 0 === l[t = Math.round(e.x * u) + "_" + Math.round(e.y * u) + "_" + Math.round(e.z * u)] ? (l[t] = i, c.push(this.vertices[i]), h[i] = c.length - 1) : h[i] = h[l[t]]; var d = []; for (i = 0, n = this.faces.length; i < n; i++) { (r = this.faces[i]).a = h[r.a], r.b = h[r.b], r.c = h[r.c], a = [r.a, r.b, r.c]; for (var p = 0; p < 3; p++)if (a[p] === a[(p + 1) % 3]) { d.push(i); break } } for (i = d.length - 1; i >= 0; i--) { var f = d[i]; for (this.faces.splice(f, 1), s = 0, o = this.faceVertexUvs.length; s < o; s++)this.faceVertexUvs[s].splice(f, 1) } var m = this.vertices.length - c.length; return this.vertices = c, m }, setFromPoints: function (e) { this.vertices = []; for (var t = 0, i = e.length; t < i; t++) { var n = e[t]; this.vertices.push(new h(n.x, n.y, n.z || 0)) } return this }, sortFacesByMaterialIndex: function () { for (var e = this.faces, t = e.length, i = 0; i < t; i++)e[i]._id = i; e.sort((function (e, t) { return e.materialIndex - t.materialIndex })); var n, r, a = this.faceVertexUvs[0], s = this.faceVertexUvs[1]; a && a.length === t && (n = []), s && s.length === t && (r = []); for (i = 0; i < t; i++) { var o = e[i]._id; n && n.push(a[o]), r && r.push(s[o]) } n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r) }, toJSON: function () { var e = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) { var t = this.parameters; for (var i in t) void 0 !== t[i] && (e[i] = t[i]); return e } for (var n = [], r = 0; r < this.vertices.length; r++) { var a = this.vertices[r]; n.push(a.x, a.y, a.z) } var s = [], o = [], l = {}, c = [], h = {}, u = [], d = {}; for (r = 0; r < this.faces.length; r++) { var p = this.faces[r], f = void 0 !== this.faceVertexUvs[0][r], m = p.normal.length() > 0, g = p.vertexNormals.length > 0, v = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b, y = p.vertexColors.length > 0, _ = 0; if (_ = T(_, 0, 0), _ = T(_, 1, !0), _ = T(_, 2, !1), _ = T(_, 3, f), _ = T(_, 4, m), _ = T(_, 5, g), _ = T(_, 6, v), _ = T(_, 7, y), s.push(_), s.push(p.a, p.b, p.c), s.push(p.materialIndex), f) { var x = this.faceVertexUvs[0][r]; s.push(E(x[0]), E(x[1]), E(x[2])) } if (m && s.push(M(p.normal)), g) { var b = p.vertexNormals; s.push(M(b[0]), M(b[1]), M(b[2])) } if (v && s.push(S(p.color)), y) { var w = p.vertexColors; s.push(S(w[0]), S(w[1]), S(w[2])) } } function T(e, t, i) { return i ? e | 1 << t : e & ~(1 << t) } function M(e) { var t = e.x.toString() + e.y.toString() + e.z.toString(); return void 0 !== l[t] || (l[t] = o.length / 3, o.push(e.x, e.y, e.z)), l[t] } function S(e) { var t = e.r.toString() + e.g.toString() + e.b.toString(); return void 0 !== h[t] || (h[t] = c.length, c.push(e.getHex())), h[t] } function E(e) { var t = e.x.toString() + e.y.toString(); return void 0 !== d[t] || (d[t] = u.length / 2, u.push(e.x, e.y)), d[t] } return e.data = {}, e.data.vertices = n, e.data.normals = o, c.length > 0 && (e.data.colors = c), u.length > 0 && (e.data.uvs = [u]), e.data.faces = s, e }, clone: function () { return (new de).copy(this) }, copy: function (e) { var t, i, n, r, a, s; this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name; var o = e.vertices; for (t = 0, i = o.length; t < i; t++)this.vertices.push(o[t].clone()); var l = e.colors; for (t = 0, i = l.length; t < i; t++)this.colors.push(l[t].clone()); var c = e.faces; for (t = 0, i = c.length; t < i; t++)this.faces.push(c[t].clone()); for (t = 0, i = e.faceVertexUvs.length; t < i; t++) { var h = e.faceVertexUvs[t]; for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), n = 0, r = h.length; n < r; n++) { var u = h[n], d = []; for (a = 0, s = u.length; a < s; a++) { var p = u[a]; d.push(p.clone()) } this.faceVertexUvs[t].push(d) } } var f = e.morphTargets; for (t = 0, i = f.length; t < i; t++) { var m = {}; if (m.name = f[t].name, void 0 !== f[t].vertices) for (m.vertices = [], n = 0, r = f[t].vertices.length; n < r; n++)m.vertices.push(f[t].vertices[n].clone()); if (void 0 !== f[t].normals) for (m.normals = [], n = 0, r = f[t].normals.length; n < r; n++)m.normals.push(f[t].normals[n].clone()); this.morphTargets.push(m) } var g = e.morphNormals; for (t = 0, i = g.length; t < i; t++) { var v = {}; if (void 0 !== g[t].vertexNormals) for (v.vertexNormals = [], n = 0, r = g[t].vertexNormals.length; n < r; n++) { var y = g[t].vertexNormals[n], _ = {}; _.a = y.a.clone(), _.b = y.b.clone(), _.c = y.c.clone(), v.vertexNormals.push(_) } if (void 0 !== g[t].faceNormals) for (v.faceNormals = [], n = 0, r = g[t].faceNormals.length; n < r; n++)v.faceNormals.push(g[t].faceNormals[n].clone()); this.morphNormals.push(v) } var x = e.skinWeights; for (t = 0, i = x.length; t < i; t++)this.skinWeights.push(x[t].clone()); var b = e.skinIndices; for (t = 0, i = b.length; t < i; t++)this.skinIndices.push(b[t].clone()); var w = e.lineDistances; for (t = 0, i = w.length; t < i; t++)this.lineDistances.push(w[t]); var T = e.boundingBox; null !== T && (this.boundingBox = T.clone()); var M = e.boundingSphere; return null !== M && (this.boundingSphere = M.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(pe.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }), Object.assign(pe.prototype, { isBufferAttribute: !0, onUploadCallback: function () { }, setArray: function (e) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); return this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this }, setDynamic: function (e) { return this.dynamic = e, this }, copy: function (e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this }, copyAt: function (e, t, i) { e *= this.itemSize, i *= t.itemSize; for (var n = 0, r = this.itemSize; n < r; n++)this.array[e + n] = t.array[i + n]; return this }, copyArray: function (e) { return this.array.set(e), this }, copyColorsArray: function (e) { for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) { var a = e[n]; void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), a = new X), t[i++] = a.r, t[i++] = a.g, t[i++] = a.b } return this }, copyVector2sArray: function (e) { for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) { var a = e[n]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), a = new l), t[i++] = a.x, t[i++] = a.y } return this }, copyVector3sArray: function (e) { for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) { var a = e[n]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new h), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z } return this }, copyVector4sArray: function (e) { for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) { var a = e[n]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), a = new P), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z, t[i++] = a.w } return this }, set: function (e, t) { return void 0 === t && (t = 0), this.array.set(e, t), this }, getX: function (e) { return this.array[e * this.itemSize] }, setX: function (e, t) { return this.array[e * this.itemSize] = t, this }, getY: function (e) { return this.array[e * this.itemSize + 1] }, setY: function (e, t) { return this.array[e * this.itemSize + 1] = t, this }, getZ: function (e) { return this.array[e * this.itemSize + 2] }, setZ: function (e, t) { return this.array[e * this.itemSize + 2] = t, this }, getW: function (e) { return this.array[e * this.itemSize + 3] }, setW: function (e, t) { return this.array[e * this.itemSize + 3] = t, this }, setXY: function (e, t, i) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this }, setXYZ: function (e, t, i, n) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this }, setXYZW: function (e, t, i, n, r) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this }, onUpload: function (e) { return this.onUploadCallback = e, this }, clone: function () { return new this.constructor(this.array, this.itemSize).copy(this) }, toJSON: function () { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized } } }), fe.prototype = Object.create(pe.prototype), fe.prototype.constructor = fe, me.prototype = Object.create(pe.prototype), me.prototype.constructor = me, ge.prototype = Object.create(pe.prototype), ge.prototype.constructor = ge, ve.prototype = Object.create(pe.prototype), ve.prototype.constructor = ve, ye.prototype = Object.create(pe.prototype), ye.prototype.constructor = ye, _e.prototype = Object.create(pe.prototype), _e.prototype.constructor = _e, xe.prototype = Object.create(pe.prototype), xe.prototype.constructor = xe, be.prototype = Object.create(pe.prototype), be.prototype.constructor = be, we.prototype = Object.create(pe.prototype), we.prototype.constructor = we, Object.assign(Te.prototype, { computeGroups: function (e) { for (var t, i = [], n = void 0, r = e.faces, a = 0; a < r.length; a++) { var s = r[a]; s.materialIndex !== n && (n = s.materialIndex, void 0 !== t && (t.count = 3 * a - t.start, i.push(t)), t = { start: 3 * a, materialIndex: n }) } void 0 !== t && (t.count = 3 * a - t.start, i.push(t)), this.groups = i }, fromGeometry: function (e) { var t, i = e.faces, n = e.vertices, r = e.faceVertexUvs, a = r[0] && r[0].length > 0, s = r[1] && r[1].length > 0, o = e.morphTargets, c = o.length; if (c > 0) { t = []; for (var h = 0; h < c; h++)t[h] = { name: o[h].name, data: [] }; this.morphTargets.position = t } var u, d = e.morphNormals, p = d.length; if (p > 0) { u = []; for (h = 0; h < p; h++)u[h] = { name: d[h].name, data: [] }; this.morphTargets.normal = u } var f = e.skinIndices, m = e.skinWeights, g = f.length === n.length, v = m.length === n.length; n.length > 0 && 0 === i.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."); for (h = 0; h < i.length; h++) { var y = i[h]; this.vertices.push(n[y.a], n[y.b], n[y.c]); var _ = y.vertexNormals; if (3 === _.length) this.normals.push(_[0], _[1], _[2]); else { var x = y.normal; this.normals.push(x, x, x) } var b, w = y.vertexColors; if (3 === w.length) this.colors.push(w[0], w[1], w[2]); else { var T = y.color; this.colors.push(T, T, T) } if (!0 === a) void 0 !== (b = r[0][h]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new l, new l, new l)); if (!0 === s) void 0 !== (b = r[1][h]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new l, new l, new l)); for (var M = 0; M < c; M++) { var S = o[M].vertices; t[M].data.push(S[y.a], S[y.b], S[y.c]) } for (M = 0; M < p; M++) { var E = d[M].vertexNormals[h]; u[M].data.push(E.a, E.b, E.c) } g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c]) } return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this } }); var Se = 1; function Ee() { Object.defineProperty(this, "id", { value: Se += 2 }), this.uuid = o.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } function Ce(e, t, i, n, r, a) { de.call(this), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: n, heightSegments: r, depthSegments: a }, this.fromBufferGeometry(new Ae(e, t, i, n, r, a)), this.mergeVertices() } function Ae(e, t, i, n, r, a) { Ee.call(this), this.type = "BoxBufferGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: n, heightSegments: r, depthSegments: a }; var s = this; e = e || 1, t = t || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1; var o = [], l = [], c = [], u = [], d = 0, p = 0; function f(e, t, i, n, r, a, f, m, g, v, y) { var _, x, b = a / g, w = f / v, T = a / 2, M = f / 2, S = m / 2, E = g + 1, C = v + 1, A = 0, P = 0, L = new h; for (x = 0; x < C; x++) { var R = x * w - M; for (_ = 0; _ < E; _++) { var O = _ * b - T; L[e] = O * n, L[t] = R * r, L[i] = S, l.push(L.x, L.y, L.z), L[e] = 0, L[t] = 0, L[i] = m > 0 ? 1 : -1, c.push(L.x, L.y, L.z), u.push(_ / g), u.push(1 - x / v), A += 1 } } for (x = 0; x < v; x++)for (_ = 0; _ < g; _++) { var I = d + _ + E * x, k = d + _ + E * (x + 1), D = d + (_ + 1) + E * (x + 1), z = d + (_ + 1) + E * x; o.push(I, k, z), o.push(k, D, z), P += 6 } s.addGroup(p, P, y), p += P, d += A } f("z", "y", "x", -1, -1, i, t, e, a, r, 0), f("z", "y", "x", 1, -1, i, t, -e, a, r, 1), f("x", "z", "y", 1, 1, e, i, t, n, a, 2), f("x", "z", "y", 1, -1, e, i, -t, n, a, 3), f("x", "y", "z", 1, -1, e, t, i, n, r, 4), f("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(o), this.addAttribute("position", new be(l, 3)), this.addAttribute("normal", new be(c, 3)), this.addAttribute("uv", new be(u, 2)) } function Pe(e, t, i, n) { de.call(this), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: n }, this.fromBufferGeometry(new Le(e, t, i, n)), this.mergeVertices() } function Le(e, t, i, n) { Ee.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: n }; var r, a, s = (e = e || 1) / 2, o = (t = t || 1) / 2, l = Math.floor(i) || 1, c = Math.floor(n) || 1, h = l + 1, u = c + 1, d = e / l, p = t / c, f = [], m = [], g = [], v = []; for (a = 0; a < u; a++) { var y = a * p - o; for (r = 0; r < h; r++) { var _ = r * d - s; m.push(_, -y, 0), g.push(0, 0, 1), v.push(r / l), v.push(1 - a / c) } } for (a = 0; a < c; a++)for (r = 0; r < l; r++) { var x = r + h * a, b = r + h * (a + 1), w = r + 1 + h * (a + 1), T = r + 1 + h * a; f.push(x, b, T), f.push(b, w, T) } this.setIndex(f), this.addAttribute("position", new be(m, 3)), this.addAttribute("normal", new be(g, 3)), this.addAttribute("uv", new be(v, 2)) } Ee.prototype = Object.assign(Object.create(n.prototype), { constructor: Ee, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (e) { Array.isArray(e) ? this.index = new (Me(e) > 65535 ? xe : ye)(e, 1) : this.index = e }, addAttribute: function (e, t) { return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : (this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new pe(arguments[1], arguments[2]))) }, getAttribute: function (e) { return this.attributes[e] }, removeAttribute: function (e) { return delete this.attributes[e], this }, addGroup: function (e, t, i) { this.groups.push({ start: e, count: t, materialIndex: void 0 !== i ? i : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (e, t) { this.drawRange.start = e, this.drawRange.count = t }, applyMatrix: function (e) { var t = this.attributes.position; void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0); var i = this.attributes.normal; void 0 !== i && ((new u).getNormalMatrix(e).applyToBufferAttribute(i), i.needsUpdate = !0); var n = this.attributes.tangent; void 0 !== n && ((new u).getNormalMatrix(e).applyToBufferAttribute(n), n.needsUpdate = !0); return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: function () { var e = new B; return function (t) { return e.makeRotationX(t), this.applyMatrix(e), this } }(), rotateY: function () { var e = new B; return function (t) { return e.makeRotationY(t), this.applyMatrix(e), this } }(), rotateZ: function () { var e = new B; return function (t) { return e.makeRotationZ(t), this.applyMatrix(e), this } }(), translate: function () { var e = new B; return function (t, i, n) { return e.makeTranslation(t, i, n), this.applyMatrix(e), this } }(), scale: function () { var e = new B; return function (t, i, n) { return e.makeScale(t, i, n), this.applyMatrix(e), this } }(), lookAt: function () { var e = new le; return function (t) { e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix) } }(), center: function () { var e = new h; return function () { return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this } }(), setFromObject: function (e) { var t = e.geometry; if (e.isPoints || e.isLine) { var i = new be(3 * t.vertices.length, 3), n = new be(3 * t.colors.length, 3); if (this.addAttribute("position", i.copyVector3sArray(t.vertices)), this.addAttribute("color", n.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) { var r = new be(t.lineDistances.length, 1); this.addAttribute("lineDistance", r.copyArray(t.lineDistances)) } null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()) } else e.isMesh && t && t.isGeometry && this.fromGeometry(t); return this }, setFromPoints: function (e) { for (var t = [], i = 0, n = e.length; i < n; i++) { var r = e[i]; t.push(r.x, r.y, r.z || 0) } return this.addAttribute("position", new be(t, 3)), this }, updateFromObject: function (e) { var t, i = e.geometry; if (e.isMesh) { var n = i.__directGeometry; if (!0 === i.elementsNeedUpdate && (n = void 0, i.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(i); n.verticesNeedUpdate = i.verticesNeedUpdate, n.normalsNeedUpdate = i.normalsNeedUpdate, n.colorsNeedUpdate = i.colorsNeedUpdate, n.uvsNeedUpdate = i.uvsNeedUpdate, n.groupsNeedUpdate = i.groupsNeedUpdate, i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !1, i.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i.groupsNeedUpdate = !1, i = n } return !0 === i.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(i.vertices), t.needsUpdate = !0), i.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(i.normals), t.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 === i.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(i.colors), t.needsUpdate = !0), i.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(i.uvs), t.needsUpdate = !0), i.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(i.lineDistances), t.needsUpdate = !0), i.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate && (i.computeGroups(e.geometry), this.groups = i.groups, i.groupsNeedUpdate = !1), this }, fromGeometry: function (e) { return e.__directGeometry = (new Te).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry) }, fromDirectGeometry: function (e) { var t = new Float32Array(3 * e.vertices.length); if (this.addAttribute("position", new pe(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) { var i = new Float32Array(3 * e.normals.length); this.addAttribute("normal", new pe(i, 3).copyVector3sArray(e.normals)) } if (e.colors.length > 0) { var n = new Float32Array(3 * e.colors.length); this.addAttribute("color", new pe(n, 3).copyColorsArray(e.colors)) } if (e.uvs.length > 0) { var r = new Float32Array(2 * e.uvs.length); this.addAttribute("uv", new pe(r, 2).copyVector2sArray(e.uvs)) } if (e.uvs2.length > 0) { var a = new Float32Array(2 * e.uvs2.length); this.addAttribute("uv2", new pe(a, 2).copyVector2sArray(e.uvs2)) } for (var s in this.groups = e.groups, e.morphTargets) { for (var o = [], l = e.morphTargets[s], c = 0, h = l.length; c < h; c++) { var u = l[c], d = new be(3 * u.data.length, 3); d.name = u.name, o.push(d.copyVector3sArray(u.data)) } this.morphAttributes[s] = o } if (e.skinIndices.length > 0) { var p = new be(4 * e.skinIndices.length, 4); this.addAttribute("skinIndex", p.copyVector4sArray(e.skinIndices)) } if (e.skinWeights.length > 0) { var f = new be(4 * e.skinWeights.length, 4); this.addAttribute("skinWeight", f.copyVector4sArray(e.skinWeights)) } return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this }, computeBoundingBox: function () { var e = new k; return function () { null === this.boundingBox && (this.boundingBox = new k); var t = this.attributes.position, i = this.morphAttributes.position; if (void 0 !== t) { if (this.boundingBox.setFromBufferAttribute(t), i) for (var n = 0, r = i.length; n < r; n++) { var a = i[n]; e.setFromBufferAttribute(a), this.boundingBox.expandByPoint(e.min), this.boundingBox.expandByPoint(e.max) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } }(), computeBoundingSphere: function () { var e = new k, t = new k, i = new h; return function () { null === this.boundingSphere && (this.boundingSphere = new D); var n = this.attributes.position, r = this.morphAttributes.position; if (n) { var a = this.boundingSphere.center; if (e.setFromBufferAttribute(n), r) for (var s = 0, o = r.length; s < o; s++) { var l = r[s]; t.setFromBufferAttribute(l), e.expandByPoint(t.min), e.expandByPoint(t.max) } e.getCenter(a); var c = 0; for (s = 0, o = n.count; s < o; s++)i.fromBufferAttribute(n, s), c = Math.max(c, a.distanceToSquared(i)); if (r) for (s = 0, o = r.length; s < o; s++)for (var h = 0, u = (l = r[s]).count; h < u; h++)i.fromBufferAttribute(l, h), c = Math.max(c, a.distanceToSquared(i)); this.boundingSphere.radius = Math.sqrt(c), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } }(), computeFaceNormals: function () { }, computeVertexNormals: function () { var e = this.index, t = this.attributes; if (t.position) { var i = t.position.array; if (void 0 === t.normal) this.addAttribute("normal", new pe(new Float32Array(i.length), 3)); else for (var n = t.normal.array, r = 0, a = n.length; r < a; r++)n[r] = 0; var s, o, l, c = t.normal.array, u = new h, d = new h, p = new h, f = new h, m = new h; if (e) { var g = e.array; for (r = 0, a = e.count; r < a; r += 3)s = 3 * g[r + 0], o = 3 * g[r + 1], l = 3 * g[r + 2], u.fromArray(i, s), d.fromArray(i, o), p.fromArray(i, l), f.subVectors(p, d), m.subVectors(u, d), f.cross(m), c[s] += f.x, c[s + 1] += f.y, c[s + 2] += f.z, c[o] += f.x, c[o + 1] += f.y, c[o + 2] += f.z, c[l] += f.x, c[l + 1] += f.y, c[l + 2] += f.z } else for (r = 0, a = i.length; r < a; r += 9)u.fromArray(i, r), d.fromArray(i, r + 3), p.fromArray(i, r + 6), f.subVectors(p, d), m.subVectors(u, d), f.cross(m), c[r] = f.x, c[r + 1] = f.y, c[r + 2] = f.z, c[r + 3] = f.x, c[r + 4] = f.y, c[r + 5] = f.z, c[r + 6] = f.x, c[r + 7] = f.y, c[r + 8] = f.z; this.normalizeNormals(), t.normal.needsUpdate = !0 } }, merge: function (e, t) { if (e && e.isBufferGeometry) { void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); var i = this.attributes; for (var n in i) if (void 0 !== e.attributes[n]) for (var r = i[n].array, a = e.attributes[n], s = a.array, o = a.itemSize * t, l = Math.min(s.length, r.length - o), c = 0, h = o; c < l; c++, h++)r[h] = s[c]; return this } console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e) }, normalizeNormals: function () { var e = new h; return function () { for (var t = this.attributes.normal, i = 0, n = t.count; i < n; i++)e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.normalize(), t.setXYZ(i, e.x, e.y, e.z) } }(), toNonIndexed: function () { function e(e, t) { for (var i = e.array, n = e.itemSize, r = new i.constructor(t.length * n), a = 0, s = 0, o = 0, l = t.length; o < l; o++) { a = t[o] * n; for (var c = 0; c < n; c++)r[s++] = i[a++] } return new pe(r, n) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; var t = new Ee, i = this.index.array, n = this.attributes; for (var r in n) { var a = e(n[r], i); t.addAttribute(r, a) } var s = this.morphAttributes; for (r in s) { for (var o = [], l = s[r], c = 0, h = l.length; c < h; c++) { a = e(l[c], i); o.push(a) } t.morphAttributes[r] = o } for (var u = this.groups, d = (c = 0, u.length); c < d; c++) { var p = u[c]; t.addGroup(p.start, p.count, p.materialIndex) } return t }, toJSON: function () { var e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) { var t = this.parameters; for (var i in t) void 0 !== t[i] && (e[i] = t[i]); return e } e.data = { attributes: {} }; var n = this.index; null !== n && (e.data.index = { type: n.array.constructor.name, array: Array.prototype.slice.call(n.array) }); var r = this.attributes; for (var i in r) { var a = (d = r[i]).toJSON(); "" !== d.name && (a.name = d.name), e.data.attributes[i] = a } var s = {}, o = !1; for (var i in this.morphAttributes) { for (var l = this.morphAttributes[i], c = [], h = 0, u = l.length; h < u; h++) { var d; a = (d = l[h]).toJSON(); "" !== d.name && (a.name = d.name), c.push(a) } c.length > 0 && (s[i] = c, o = !0) } o && (e.data.morphAttributes = s); var p = this.groups; p.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(p))); var f = this.boundingSphere; return null !== f && (e.data.boundingSphere = { center: f.center.toArray(), radius: f.radius }), e }, clone: function () { return (new Ee).copy(this) }, copy: function (e) { var t, i, n; this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name; var r = e.index; null !== r && this.setIndex(r.clone()); var a = e.attributes; for (t in a) { var s = a[t]; this.addAttribute(t, s.clone()) } var o = e.morphAttributes; for (t in o) { var l = [], c = o[t]; for (i = 0, n = c.length; i < n; i++)l.push(c[i].clone()); this.morphAttributes[t] = l } var h = e.groups; for (i = 0, n = h.length; i < n; i++) { var u = h[i]; this.addGroup(u.start, u.count, u.materialIndex) } var d = e.boundingBox; null !== d && (this.boundingBox = d.clone()); var p = e.boundingSphere; return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Ce.prototype = Object.create(de.prototype), Ce.prototype.constructor = Ce, Ae.prototype = Object.create(Ee.prototype), Ae.prototype.constructor = Ae, Pe.prototype = Object.create(de.prototype), Pe.prototype.constructor = Pe, Le.prototype = Object.create(Ee.prototype), Le.prototype.constructor = Le; var Re = 0; function Oe() { Object.defineProperty(this, "id", { value: Re++ }), this.uuid = o.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0 } Oe.prototype = Object.assign(Object.create(n.prototype), { constructor: Oe, isMaterial: !0, onBeforeCompile: function () { }, setValues: function (e) { if (void 0 !== e) for (var t in e) { var i = e[t]; if (void 0 !== i) if ("shading" !== t) { var n = this[t]; void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i; else console.warn("THREE.Material: '" + t + "' parameter is undefined.") } }, toJSON: function (e) { var t = void 0 === e || "string" == typeof e; t && (e = { textures: {}, images: {} }); var i = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; function n(e) { var t = []; for (var i in e) { var n = e[i]; delete n.metadata, t.push(n) } return t } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, i.reflectivity = this.reflectivity, void 0 !== this.combine && (i.combine = this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (i.blending = this.blending), !0 === this.flatShading && (i.flatShading = this.flatShading), 0 !== this.side && (i.side = this.side), 0 !== this.vertexColors && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), t) { var r = n(e.textures), a = n(e.images); r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a) } return i }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection; var t = e.clippingPlanes, i = null; if (null !== t) { var n = t.length; i = new Array(n); for (var r = 0; r !== n; ++r)i[r] = t[r].clone() } return this.clippingPlanes = i, this.shadowSide = e.shadowSide, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }); var Ie, ke, De, ze, Ne, Be, Fe, Ge, Ue, He, Ve, je; function We(e) { Oe.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) } function $e(e, t) { this.origin = void 0 !== e ? e : new h, this.direction = void 0 !== t ? t : new h } function Xe(e, t, i) { this.a = void 0 !== e ? e : new h, this.b = void 0 !== t ? t : new h, this.c = void 0 !== i ? i : new h } function Ye(e) { Oe.call(this), this.type = "MeshBasicMaterial", this.color = new X(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(e) } function qe(e, t) { le.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new Ee, this.material = void 0 !== t ? t : new Ye({ color: 16777215 * Math.random() }), this.drawMode = 0, this.updateMorphTargets() } function Je(e, t, i, n) { var r, a, s = new X(0), o = 0, l = null, c = 0; function h(e, i) { t.buffers.color.setClear(e.r, e.g, e.b, i, n) } return { getClearColor: function () { return s }, setClearColor: function (e, t) { s.set(e), h(s, o = void 0 !== t ? t : 1) }, getClearAlpha: function () { return o }, setClearAlpha: function (e) { h(s, o = e) }, render: function (t, n, u, d) { var p = n.background, f = e.vr, m = f.getSession && f.getSession(); if (m && "additive" === m.environmentBlendMode && (p = null), null === p ? (h(s, o), l = null, c = 0) : p && p.isColor && (h(p, 1), d = !0, l = null, c = 0), (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), p && (p.isCubeTexture || p.isWebGLRenderTargetCube)) { void 0 === a && ((a = new qe(new Ae(1, 1, 1), new We({ type: "BackgroundCubeMaterial", uniforms: G(J.cube.uniforms), vertexShader: J.cube.vertexShader, fragmentShader: J.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.removeAttribute("normal"), a.geometry.removeAttribute("uv"), a.onBeforeRender = function (e, t, i) { this.matrixWorld.copyPosition(i.matrixWorld) }, Object.defineProperty(a.material, "map", { get: function () { return this.uniforms.tCube.value } }), i.update(a)); var g = p.isWebGLRenderTargetCube ? p.texture : p; a.material.uniforms.tCube.value = g, a.material.uniforms.tFlip.value = p.isWebGLRenderTargetCube ? 1 : -1, l === p && c === g.version || (a.material.needsUpdate = !0, l = p, c = g.version), t.unshift(a, a.geometry, a.material, 0, 0, null) } else p && p.isTexture && (void 0 === r && ((r = new qe(new Le(2, 2), new We({ type: "BackgroundMaterial", uniforms: G(J.background.uniforms), vertexShader: J.background.vertexShader, fragmentShader: J.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.removeAttribute("normal"), Object.defineProperty(r.material, "map", { get: function () { return this.uniforms.t2D.value } }), i.update(r)), r.material.uniforms.t2D.value = p, !0 === p.matrixAutoUpdate && p.updateMatrix(), r.material.uniforms.uvTransform.value.copy(p.matrix), l === p && c === p.version || (r.material.needsUpdate = !0, l = p, c = p.version), t.unshift(r, r.geometry, r.material, 0, 0, null)) } } } function Ze(e, t, i, n) { var r; this.setMode = function (e) { r = e }, this.render = function (t, n) { e.drawArrays(r, t, n), i.update(n, r) }, this.renderInstances = function (a, s, o) { var l; if (n.isWebGL2) l = e; else if (null === (l = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, s, o, a.maxInstancedCount), i.update(o, r, a.maxInstancedCount) } } function Ke(e, t, i) { var n; function r(t) { if ("highp" === t) { if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; t = "mediump" } return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } var a = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext, s = void 0 !== i.precision ? i.precision : "highp", o = r(s); o !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead."), s = o); var l = !0 === i.logarithmicDepthBuffer, c = e.getParameter(34930), h = e.getParameter(35660), u = e.getParameter(3379), d = e.getParameter(34076), p = e.getParameter(34921), f = e.getParameter(36347), m = e.getParameter(36348), g = e.getParameter(36349), v = h > 0, y = a || !!t.get("OES_texture_float"); return { isWebGL2: a, getMaxAnisotropy: function () { if (void 0 !== n) return n; var i = t.get("EXT_texture_filter_anisotropic"); return n = null !== i ? e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: r, precision: s, logarithmicDepthBuffer: l, maxTextures: c, maxVertexTextures: h, maxTextureSize: u, maxCubemapSize: d, maxAttributes: p, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: g, vertexTextures: v, floatFragmentTextures: y, floatVertexTextures: v && y, maxSamples: a ? e.getParameter(36183) : 0 } } function Qe() { var e = this, t = null, i = 0, n = !1, r = !1, a = new z, s = new u, o = { value: null, needsUpdate: !1 }; function l() { o.value !== t && (o.value = t, o.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0 } function c(t, i, n, r) { var l = null !== t ? t.length : 0, c = null; if (0 !== l) { if (c = o.value, !0 !== r || null === c) { var h = n + 4 * l, u = i.matrixWorldInverse; s.getNormalMatrix(u), (null === c || c.length < h) && (c = new Float32Array(h)); for (var d = 0, p = n; d !== l; ++d, p += 4)a.copy(t[d]).applyMatrix4(u, s), a.normal.toArray(c, p), c[p + 3] = a.constant } o.value = c, o.needsUpdate = !0 } return e.numPlanes = l, c } this.uniform = o, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, r, a) { var s = 0 !== e.length || r || 0 !== i || n; return n = r, t = c(e, a, 0), i = e.length, s }, this.beginShadows = function () { r = !0, c(null) }, this.endShadows = function () { r = !1, l() }, this.setState = function (e, a, s, h, u, d) { if (!n || null === e || 0 === e.length || r && !s) r ? c(null) : l(); else { var p = r ? 0 : i, f = 4 * p, m = u.clippingState || null; o.value = m, m = c(e, h, f, d); for (var g = 0; g !== f; ++g)m[g] = t[g]; u.clippingState = m, this.numIntersection = a ? this.numPlanes : 0, this.numPlanes += p } } } function et(e) { var t = {}; return { get: function (i) { if (void 0 !== t[i]) return t[i]; var n; switch (i) { case "WEBGL_depth_texture": n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: n = e.getExtension(i) }return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), t[i] = n, n } } } function tt(e, t, i) { var n = {}, r = {}; function a(e) { var s = e.target, o = n[s.id]; for (var l in null !== o.index && t.remove(o.index), o.attributes) t.remove(o.attributes[l]); s.removeEventListener("dispose", a), delete n[s.id]; var c = r[o.id]; c && (t.remove(c), delete r[o.id]), i.memory.geometries-- } return { get: function (e, t) { var r = n[t.id]; return r || (t.addEventListener("dispose", a), t.isBufferGeometry ? r = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new Ee).setFromObject(e)), r = t._bufferGeometry), n[t.id] = r, i.memory.geometries++, r) }, update: function (e) { var i = e.index, n = e.attributes; for (var r in null !== i && t.update(i, 34963), n) t.update(n[r], 34962); var a = e.morphAttributes; for (var r in a) for (var s = a[r], o = 0, l = s.length; o < l; o++)t.update(s[o], 34962) }, getWireframeAttribute: function (e) { var i = r[e.id]; if (i) return i; var n, a = [], s = e.index, o = e.attributes; if (null !== s) for (var l = 0, c = (n = s.array).length; l < c; l += 3) { var h = n[l + 0], u = n[l + 1], d = n[l + 2]; a.push(h, u, u, d, d, h) } else for (l = 0, c = (n = o.position.array).length / 3 - 1; l < c; l += 3) { h = l + 0, u = l + 1, d = l + 2; a.push(h, u, u, d, d, h) } return i = new (Me(a) > 65535 ? xe : ye)(a, 1), t.update(i, 34963), r[e.id] = i, i } } } function it(e, t, i, n) { var r, a, s; this.setMode = function (e) { r = e }, this.setIndex = function (e) { a = e.type, s = e.bytesPerElement }, this.render = function (t, n) { e.drawElements(r, n, a, t * s), i.update(n, r) }, this.renderInstances = function (o, l, c) { var h; if (n.isWebGL2) h = e; else if (null === (h = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); h[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, c, a, l * s, o.maxInstancedCount), i.update(c, r, o.maxInstancedCount) } } function nt(e) { var t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: t, programs: null, autoReset: !0, reset: function () { t.frame++, t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0 }, update: function (e, i, n) { switch (n = n || 1, t.calls++, i) { case 4: t.triangles += n * (e / 3); break; case 5: case 6: t.triangles += n * (e - 2); break; case 1: t.lines += n * (e / 2); break; case 3: t.lines += n * (e - 1); break; case 2: t.lines += n * e; break; case 0: t.points += n * e; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", i) } } } } function rt(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) } function at(e) { var t = {}, i = new Float32Array(8); return { update: function (n, r, a, s) { var o = n.morphTargetInfluences, l = o.length, c = t[r.id]; if (void 0 === c) { c = []; for (var h = 0; h < l; h++)c[h] = [h, 0]; t[r.id] = c } var u = a.morphTargets && r.morphAttributes.position, d = a.morphNormals && r.morphAttributes.normal; for (h = 0; h < l; h++) { 0 !== (p = c[h])[1] && (u && r.removeAttribute("morphTarget" + h), d && r.removeAttribute("morphNormal" + h)) } for (h = 0; h < l; h++) { (p = c[h])[0] = h, p[1] = o[h] } for (c.sort(rt), h = 0; h < 8; h++) { var p; if (p = c[h]) { var f = p[0], m = p[1]; if (m) { u && r.addAttribute("morphTarget" + h, u[f]), d && r.addAttribute("morphNormal" + h, d[f]), i[h] = m; continue } } i[h] = 0 } s.getUniforms().setValue(e, "morphTargetInfluences", i) } } } function st(e, t) { var i = {}; return { update: function (n) { var r = t.render.frame, a = n.geometry, s = e.get(n, a); return i[s.id] !== r && (a.isGeometry && s.updateFromObject(n), e.update(s), i[s.id] = r), s }, dispose: function () { i = {} } } } function ot(e, t, i, n, r, a, s, o, l, c) { e = void 0 !== e ? e : [], t = void 0 !== t ? t : 301, s = void 0 !== s ? s : 1022, A.call(this, e, t, i, n, r, a, s, o, l, c), this.flipY = !1 } function lt(e, t, i, n) { A.call(this, null), this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1 } function ct(e, t, i, n) { A.call(this, null), this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = 1003, this.minFilter = 1003, this.wrapR = 1001, this.generateMipmaps = !1, this.flipY = !1 } We.prototype = Object.create(Oe.prototype), We.prototype.constructor = We, We.prototype.isShaderMaterial = !0, We.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = G(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this }, We.prototype.toJSON = function (e) { var t = Oe.prototype.toJSON.call(this, e); for (var i in t.uniforms = {}, this.uniforms) { var n = this.uniforms[i].value; n && n.isTexture ? t.uniforms[i] = { type: "t", value: n.toJSON(e).uuid } : n && n.isColor ? t.uniforms[i] = { type: "c", value: n.getHex() } : n && n.isVector2 ? t.uniforms[i] = { type: "v2", value: n.toArray() } : n && n.isVector3 ? t.uniforms[i] = { type: "v3", value: n.toArray() } : n && n.isVector4 ? t.uniforms[i] = { type: "v4", value: n.toArray() } : n && n.isMatrix3 ? t.uniforms[i] = { type: "m3", value: n.toArray() } : n && n.isMatrix4 ? t.uniforms[i] = { type: "m4", value: n.toArray() } : t.uniforms[i] = { value: n } } Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; var r = {}; for (var a in this.extensions) !0 === this.extensions[a] && (r[a] = !0); return Object.keys(r).length > 0 && (t.extensions = r), t }, Object.assign($e.prototype, { set: function (e, t) { return this.origin.copy(e), this.direction.copy(t), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this }, at: function (e, t) { return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new h), t.copy(this.direction).multiplyScalar(e).add(this.origin) }, lookAt: function (e) { return this.direction.copy(e).sub(this.origin).normalize(), this }, recast: function () { var e = new h; return function (t) { return this.origin.copy(this.at(t, e)), this } }(), closestPointToPoint: function (e, t) { void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new h), t.subVectors(e, this.origin); var i = t.dot(this.direction); return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin) }, distanceToPoint: function (e) { return Math.sqrt(this.distanceSqToPoint(e)) }, distanceSqToPoint: function () { var e = new h; return function (t) { var i = e.subVectors(t, this.origin).dot(this.direction); return i < 0 ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(i).add(this.origin), e.distanceToSquared(t)) } }(), distanceSqToSegment: (ke = new h, De = new h, ze = new h, function (e, t, i, n) { ke.copy(e).add(t).multiplyScalar(.5), De.copy(t).sub(e).normalize(), ze.copy(this.origin).sub(ke); var r, a, s, o, l = .5 * e.distanceTo(t), c = -this.direction.dot(De), h = ze.dot(this.direction), u = -ze.dot(De), d = ze.lengthSq(), p = Math.abs(1 - c * c); if (p > 0) if (a = c * h - u, o = l * p, (r = c * u - h) >= 0) if (a >= -o) if (a <= o) { var f = 1 / p; s = (r *= f) * (r + c * (a *= f) + 2 * h) + a * (c * r + a + 2 * u) + d } else a = l, s = -(r = Math.max(0, -(c * a + h))) * r + a * (a + 2 * u) + d; else a = -l, s = -(r = Math.max(0, -(c * a + h))) * r + a * (a + 2 * u) + d; else a <= -o ? s = -(r = Math.max(0, -(-c * l + h))) * r + (a = r > 0 ? -l : Math.min(Math.max(-l, -u), l)) * (a + 2 * u) + d : a <= o ? (r = 0, s = (a = Math.min(Math.max(-l, -u), l)) * (a + 2 * u) + d) : s = -(r = Math.max(0, -(c * l + h))) * r + (a = r > 0 ? l : Math.min(Math.max(-l, -u), l)) * (a + 2 * u) + d; else a = c > 0 ? -l : l, s = -(r = Math.max(0, -(c * a + h))) * r + a * (a + 2 * u) + d; return i && i.copy(this.direction).multiplyScalar(r).add(this.origin), n && n.copy(De).multiplyScalar(a).add(ke), s }), intersectSphere: function () { var e = new h; return function (t, i) { e.subVectors(t.center, this.origin); var n = e.dot(this.direction), r = e.dot(e) - n * n, a = t.radius * t.radius; if (r > a) return null; var s = Math.sqrt(a - r), o = n - s, l = n + s; return o < 0 && l < 0 ? null : o < 0 ? this.at(l, i) : this.at(o, i) } }(), intersectsSphere: function (e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius }, distanceToPlane: function (e) { var t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; var i = -(this.origin.dot(e.normal) + e.constant) / t; return i >= 0 ? i : null }, intersectPlane: function (e, t) { var i = this.distanceToPlane(e); return null === i ? null : this.at(i, t) }, intersectsPlane: function (e) { var t = e.distanceToPoint(this.origin); return 0 === t || e.normal.dot(this.direction) * t < 0 }, intersectBox: function (e, t) { var i, n, r, a, s, o, l = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, u = this.origin; return l >= 0 ? (i = (e.min.x - u.x) * l, n = (e.max.x - u.x) * l) : (i = (e.max.x - u.x) * l, n = (e.min.x - u.x) * l), c >= 0 ? (r = (e.min.y - u.y) * c, a = (e.max.y - u.y) * c) : (r = (e.max.y - u.y) * c, a = (e.min.y - u.y) * c), i > a || r > n ? null : ((r > i || i != i) && (i = r), (a < n || n != n) && (n = a), h >= 0 ? (s = (e.min.z - u.z) * h, o = (e.max.z - u.z) * h) : (s = (e.max.z - u.z) * h, o = (e.min.z - u.z) * h), i > o || s > n ? null : ((s > i || i != i) && (i = s), (o < n || n != n) && (n = o), n < 0 ? null : this.at(i >= 0 ? i : n, t))) }, intersectsBox: (Ie = new h, function (e) { return null !== this.intersectBox(e, Ie) }), intersectTriangle: function () { var e = new h, t = new h, i = new h, n = new h; return function (r, a, s, o, l) { t.subVectors(a, r), i.subVectors(s, r), n.crossVectors(t, i); var c, h = this.direction.dot(n); if (h > 0) { if (o) return null; c = 1 } else { if (!(h < 0)) return null; c = -1, h = -h } e.subVectors(this.origin, r); var u = c * this.direction.dot(i.crossVectors(e, i)); if (u < 0) return null; var d = c * this.direction.dot(t.cross(e)); if (d < 0) return null; if (u + d > h) return null; var p = -c * e.dot(n); return p < 0 ? null : this.at(p / h, l) } }(), applyMatrix4: function (e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this }, equals: function (e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } }), Object.assign(Xe, { getNormal: (Be = new h, function (e, t, i, n) { void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"), n = new h), n.subVectors(i, t), Be.subVectors(e, t), n.cross(Be); var r = n.lengthSq(); return r > 0 ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0) }), getBarycoord: function () { var e = new h, t = new h, i = new h; return function (n, r, a, s, o) { e.subVectors(s, r), t.subVectors(a, r), i.subVectors(n, r); var l = e.dot(e), c = e.dot(t), u = e.dot(i), d = t.dot(t), p = t.dot(i), f = l * d - c * c; if (void 0 === o && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), o = new h), 0 === f) return o.set(-2, -1, -1); var m = 1 / f, g = (d * u - c * p) * m, v = (l * p - c * u) * m; return o.set(1 - g - v, v, g) } }(), containsPoint: function () { var e = new h; return function (t, i, n, r) { return Xe.getBarycoord(t, i, n, r, e), e.x >= 0 && e.y >= 0 && e.x + e.y <= 1 } }(), getUV: (Ne = new h, function (e, t, i, n, r, a, s, o) { return this.getBarycoord(e, t, i, n, Ne), o.set(0, 0), o.addScaledVector(r, Ne.x), o.addScaledVector(a, Ne.y), o.addScaledVector(s, Ne.z), o }), isFrontFacing: function () { var e = new h, t = new h; return function (i, n, r, a) { return e.subVectors(r, n), t.subVectors(i, n), e.cross(t).dot(a) < 0 } }() }), Object.assign(Xe.prototype, { set: function (e, t, i) { return this.a.copy(e), this.b.copy(t), this.c.copy(i), this }, setFromPointsAndIndices: function (e, t, i, n) { return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this }, getArea: function () { var e = new h, t = new h; return function () { return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length() } }(), getMidpoint: function (e) { return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new h), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, getNormal: function (e) { return Xe.getNormal(this.a, this.b, this.c, e) }, getPlane: function (e) { return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new h), e.setFromCoplanarPoints(this.a, this.b, this.c) }, getBarycoord: function (e, t) { return Xe.getBarycoord(e, this.a, this.b, this.c, t) }, getUV: function (e, t, i, n, r) { return Xe.getUV(e, this.a, this.b, this.c, t, i, n, r) }, containsPoint: function (e) { return Xe.containsPoint(e, this.a, this.b, this.c) }, isFrontFacing: function (e) { return Xe.isFrontFacing(this.a, this.b, this.c, e) }, intersectsBox: function (e) { return e.intersectsTriangle(this) }, closestPointToPoint: (Fe = new h, Ge = new h, Ue = new h, He = new h, Ve = new h, je = new h, function (e, t) { void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new h); var i, n, r = this.a, a = this.b, s = this.c; Fe.subVectors(a, r), Ge.subVectors(s, r), He.subVectors(e, r); var o = Fe.dot(He), l = Ge.dot(He); if (o <= 0 && l <= 0) return t.copy(r); Ve.subVectors(e, a); var c = Fe.dot(Ve), u = Ge.dot(Ve); if (c >= 0 && u <= c) return t.copy(a); var d = o * u - c * l; if (d <= 0 && o >= 0 && c <= 0) return i = o / (o - c), t.copy(r).addScaledVector(Fe, i); je.subVectors(e, s); var p = Fe.dot(je), f = Ge.dot(je); if (f >= 0 && p <= f) return t.copy(s); var m = p * l - o * f; if (m <= 0 && l >= 0 && f <= 0) return n = l / (l - f), t.copy(r).addScaledVector(Ge, n); var g = c * f - p * u; if (g <= 0 && u - c >= 0 && p - f >= 0) return Ue.subVectors(s, a), n = (u - c) / (u - c + (p - f)), t.copy(a).addScaledVector(Ue, n); var v = 1 / (g + m + d); return i = m * v, n = d * v, t.copy(r).addScaledVector(Fe, i).addScaledVector(Ge, n) }), equals: function (e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } }), Ye.prototype = Object.create(Oe.prototype), Ye.prototype.constructor = Ye, Ye.prototype.isMeshBasicMaterial = !0, Ye.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this }, qe.prototype = Object.assign(Object.create(le.prototype), { constructor: qe, isMesh: !0, setDrawMode: function (e) { this.drawMode = e }, copy: function (e) { return le.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this }, updateMorphTargets: function () { var e, t, i, n = this.geometry; if (n.isBufferGeometry) { var r = n.morphAttributes, a = Object.keys(r); if (a.length > 0) { var s = r[a[0]]; if (void 0 !== s) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = s.length; e < t; e++)i = s[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e } } else { var o = n.morphTargets; void 0 !== o && o.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }, raycast: function () { var e = new B, t = new $e, i = new D, n = new h, r = new h, a = new h, s = new h, o = new h, c = new h, u = new h, d = new h, p = new h, f = new l, m = new l, g = new l, v = new h, y = new h; function _(e, t, i, n, r, a, s, o) { if (null === (1 === t.side ? n.intersectTriangle(s, a, r, !0, o) : n.intersectTriangle(r, a, s, 2 !== t.side, o))) return null; y.copy(o), y.applyMatrix4(e.matrixWorld); var l = i.ray.origin.distanceTo(y); return l < i.near || l > i.far ? null : { distance: l, point: y.clone(), object: e } } function x(e, t, i, h, y, x, b, w, T, M) { n.fromBufferAttribute(y, w), r.fromBufferAttribute(y, T), a.fromBufferAttribute(y, M); var S = e.morphTargetInfluences; if (t.morphTargets && x && S) { u.set(0, 0, 0), d.set(0, 0, 0), p.set(0, 0, 0); for (var E = 0, C = x.length; E < C; E++) { var A = S[E], P = x[E]; 0 !== A && (s.fromBufferAttribute(P, w), o.fromBufferAttribute(P, T), c.fromBufferAttribute(P, M), u.addScaledVector(s.sub(n), A), d.addScaledVector(o.sub(r), A), p.addScaledVector(c.sub(a), A)) } n.add(u), r.add(d), a.add(p) } var L = _(e, t, i, h, n, r, a, v); if (L) { b && (f.fromBufferAttribute(b, w), m.fromBufferAttribute(b, T), g.fromBufferAttribute(b, M), L.uv = Xe.getUV(v, n, r, a, f, m, g, new l)); var R = new Q(w, T, M); Xe.getNormal(n, r, a, R.normal), L.face = R } return L } return function (n, r) { var a, s = this.geometry, o = this.material, c = this.matrixWorld; if (void 0 !== o && (null === s.boundingSphere && s.computeBoundingSphere(), i.copy(s.boundingSphere), i.applyMatrix4(c), !1 !== n.ray.intersectsSphere(i) && (e.getInverse(c), t.copy(n.ray).applyMatrix4(e), null === s.boundingBox || !1 !== t.intersectsBox(s.boundingBox)))) if (s.isBufferGeometry) { var h, u, d, p, y, b, w, T, M, S = s.index, E = s.attributes.position, C = s.morphAttributes.position, A = s.attributes.uv, P = s.groups, L = s.drawRange; if (null !== S) if (Array.isArray(o)) for (p = 0, b = P.length; p < b; p++)for (M = o[(T = P[p]).materialIndex], y = Math.max(T.start, L.start), w = Math.min(T.start + T.count, L.start + L.count); y < w; y += 3)h = S.getX(y), u = S.getX(y + 1), d = S.getX(y + 2), (a = x(this, M, n, t, E, C, A, h, u, d)) && (a.faceIndex = Math.floor(y / 3), a.face.materialIndex = T.materialIndex, r.push(a)); else for (p = Math.max(0, L.start), b = Math.min(S.count, L.start + L.count); p < b; p += 3)h = S.getX(p), u = S.getX(p + 1), d = S.getX(p + 2), (a = x(this, o, n, t, E, C, A, h, u, d)) && (a.faceIndex = Math.floor(p / 3), r.push(a)); else if (void 0 !== E) if (Array.isArray(o)) for (p = 0, b = P.length; p < b; p++)for (M = o[(T = P[p]).materialIndex], y = Math.max(T.start, L.start), w = Math.min(T.start + T.count, L.start + L.count); y < w; y += 3)(a = x(this, M, n, t, E, C, A, h = y, u = y + 1, d = y + 2)) && (a.faceIndex = Math.floor(y / 3), a.face.materialIndex = T.materialIndex, r.push(a)); else for (p = Math.max(0, L.start), b = Math.min(E.count, L.start + L.count); p < b; p += 3)(a = x(this, o, n, t, E, C, A, h = p, u = p + 1, d = p + 2)) && (a.faceIndex = Math.floor(p / 3), r.push(a)) } else if (s.isGeometry) { var R, O, I, k, D = Array.isArray(o), z = s.vertices, N = s.faces, B = s.faceVertexUvs[0]; B.length > 0 && (k = B); for (var F = 0, G = N.length; F < G; F++) { var U = N[F], H = D ? o[U.materialIndex] : o; if (void 0 !== H && (R = z[U.a], O = z[U.b], I = z[U.c], a = _(this, H, n, t, R, O, I, v))) { if (k && k[F]) { var V = k[F]; f.copy(V[0]), m.copy(V[1]), g.copy(V[2]), a.uv = Xe.getUV(v, R, O, I, f, m, g, new l) } a.face = U, a.faceIndex = F, r.push(a) } } } } }(), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), ot.prototype = Object.create(A.prototype), ot.prototype.constructor = ot, ot.prototype.isCubeTexture = !0, Object.defineProperty(ot.prototype, "images", { get: function () { return this.image }, set: function (e) { this.image = e } }), lt.prototype = Object.create(A.prototype), lt.prototype.constructor = lt, lt.prototype.isDataTexture2DArray = !0, ct.prototype = Object.create(A.prototype), ct.prototype.constructor = ct, ct.prototype.isDataTexture3D = !0; var ht = new A, ut = new lt, dt = new ct, pt = new ot, ft = [], mt = [], gt = new Float32Array(16), vt = new Float32Array(9), yt = new Float32Array(4); function _t(e, t, i) { var n = e[0]; if (n <= 0 || n > 0) return e; var r = t * i, a = ft[r]; if (void 0 === a && (a = new Float32Array(r), ft[r] = a), 0 !== t) { n.toArray(a, 0); for (var s = 1, o = 0; s !== t; ++s)o += i, e[s].toArray(a, o) } return a } function xt(e, t) { if (e.length !== t.length) return !1; for (var i = 0, n = e.length; i < n; i++)if (e[i] !== t[i]) return !1; return !0 } function bt(e, t) { for (var i = 0, n = t.length; i < n; i++)e[i] = t[i] } function wt(e, t) { var i = mt[t]; void 0 === i && (i = new Int32Array(t), mt[t] = i); for (var n = 0; n !== t; ++n)i[n] = e.allocateTextureUnit(); return i } function Tt(e, t) { var i = this.cache; i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t) } function Mt(e, t) { var i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y); else { if (xt(i, t)) return; e.uniform2fv(this.addr, t), bt(i, t) } } function St(e, t) { var i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z); else if (void 0 !== t.r) i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b); else { if (xt(i, t)) return; e.uniform3fv(this.addr, t), bt(i, t) } } function Et(e, t) { var i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w); else { if (xt(i, t)) return; e.uniform4fv(this.addr, t), bt(i, t) } } function Ct(e, t) { var i = this.cache, n = t.elements; if (void 0 === n) { if (xt(i, t)) return; e.uniformMatrix2fv(this.addr, !1, t), bt(i, t) } else { if (xt(i, n)) return; yt.set(n), e.uniformMatrix2fv(this.addr, !1, yt), bt(i, n) } } function At(e, t) { var i = this.cache, n = t.elements; if (void 0 === n) { if (xt(i, t)) return; e.uniformMatrix3fv(this.addr, !1, t), bt(i, t) } else { if (xt(i, n)) return; vt.set(n), e.uniformMatrix3fv(this.addr, !1, vt), bt(i, n) } } function Pt(e, t) { var i = this.cache, n = t.elements; if (void 0 === n) { if (xt(i, t)) return; e.uniformMatrix4fv(this.addr, !1, t), bt(i, t) } else { if (xt(i, n)) return; gt.set(n), e.uniformMatrix4fv(this.addr, !1, gt), bt(i, n) } } function Lt(e, t, i) { var n = this.cache, r = i.allocateTextureUnit(); n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(t || ht, r) } function Rt(e, t, i) { var n = this.cache, r = i.allocateTextureUnit(); n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(t || ut, r) } function Ot(e, t, i) { var n = this.cache, r = i.allocateTextureUnit(); n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(t || dt, r) } function It(e, t, i) { var n = this.cache, r = i.allocateTextureUnit(); n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(t || pt, r) } function kt(e, t) { var i = this.cache; i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t) } function Dt(e, t) { var i = this.cache; xt(i, t) || (e.uniform2iv(this.addr, t), bt(i, t)) } function zt(e, t) { var i = this.cache; xt(i, t) || (e.uniform3iv(this.addr, t), bt(i, t)) } function Nt(e, t) { var i = this.cache; xt(i, t) || (e.uniform4iv(this.addr, t), bt(i, t)) } function Bt(e, t) { e.uniform1fv(this.addr, t) } function Ft(e, t) { e.uniform1iv(this.addr, t) } function Gt(e, t) { e.uniform2iv(this.addr, t) } function Ut(e, t) { e.uniform3iv(this.addr, t) } function Ht(e, t) { e.uniform4iv(this.addr, t) } function Vt(e, t) { var i = _t(t, this.size, 2); e.uniform2fv(this.addr, i) } function jt(e, t) { var i = _t(t, this.size, 3); e.uniform3fv(this.addr, i) } function Wt(e, t) { var i = _t(t, this.size, 4); e.uniform4fv(this.addr, i) } function $t(e, t) { var i = _t(t, this.size, 4); e.uniformMatrix2fv(this.addr, !1, i) } function Xt(e, t) { var i = _t(t, this.size, 9); e.uniformMatrix3fv(this.addr, !1, i) } function Yt(e, t) { var i = _t(t, this.size, 16); e.uniformMatrix4fv(this.addr, !1, i) } function qt(e, t, i) { var n = t.length, r = wt(i, n); e.uniform1iv(this.addr, r); for (var a = 0; a !== n; ++a)i.safeSetTexture2D(t[a] || ht, r[a]) } function Jt(e, t, i) { var n = t.length, r = wt(i, n); e.uniform1iv(this.addr, r); for (var a = 0; a !== n; ++a)i.safeSetTextureCube(t[a] || pt, r[a]) } function Zt(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.setValue = function (e) { switch (e) { case 5126: return Tt; case 35664: return Mt; case 35665: return St; case 35666: return Et; case 35674: return Ct; case 35675: return At; case 35676: return Pt; case 35678: case 36198: return Lt; case 35679: return Ot; case 35680: return It; case 36289: return Rt; case 5124: case 35670: return kt; case 35667: case 35671: return Dt; case 35668: case 35672: return zt; case 35669: case 35673: return Nt } }(t.type) } function Kt(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = function (e) { switch (e) { case 5126: return Bt; case 35664: return Vt; case 35665: return jt; case 35666: return Wt; case 35674: return $t; case 35675: return Xt; case 35676: return Yt; case 35678: return qt; case 35680: return Jt; case 5124: case 35670: return Ft; case 35667: case 35671: return Gt; case 35668: case 35672: return Ut; case 35669: case 35673: return Ht } }(t.type) } function Qt(e) { this.id = e, this.seq = [], this.map = {} } Kt.prototype.updateCache = function (e) { var t = this.cache; e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), bt(t, e) }, Qt.prototype.setValue = function (e, t, i) { for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) { var s = n[r]; s.setValue(e, t[s.id], i) } }; var ei = /([\w\d_]+)(\])?(\[|\.)?/g; function ti(e, t) { e.seq.push(t), e.map[t.id] = t } function ii(e, t, i) { var n = e.name, r = n.length; for (ei.lastIndex = 0; ;) { var a = ei.exec(n), s = ei.lastIndex, o = a[1], l = "]" === a[2], c = a[3]; if (l && (o |= 0), void 0 === c || "[" === c && s + 2 === r) { ti(i, void 0 === c ? new Zt(o, e, t) : new Kt(o, e, t)); break } var h = i.map[o]; void 0 === h && ti(i, h = new Qt(o)), i = h } } function ni(e, t) { this.seq = [], this.map = {}; for (var i = e.getProgramParameter(t, 35718), n = 0; n < i; ++n) { var r = e.getActiveUniform(t, n); ii(r, e.getUniformLocation(t, r.name), this) } } function ri(e, t, i, n) { var r = e.createShader(t); return e.shaderSource(r, i), e.compileShader(r), !0 === n && (!1 === e.getShaderParameter(r, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === t ? "vertex" : "fragment", e.getShaderInfoLog(r), function (e) { for (var t = e.split("\n"), i = 0; i < t.length; i++)t[i] = i + 1 + ": " + t[i]; return t.join("\n") }(i))), r } ni.prototype.setValue = function (e, t, i, n) { var r = this.map[t]; void 0 !== r && r.setValue(e, i, n) }, ni.prototype.setOptional = function (e, t, i) { var n = t[i]; void 0 !== n && this.setValue(e, i, n) }, ni.upload = function (e, t, i, n) { for (var r = 0, a = t.length; r !== a; ++r) { var s = t[r], o = i[s.id]; !1 !== o.needsUpdate && s.setValue(e, o.value, n) } }, ni.seqWithValue = function (e, t) { for (var i = [], n = 0, r = e.length; n !== r; ++n) { var a = e[n]; a.id in t && i.push(a) } return i }; var ai = 0; function si(e) { switch (e) { case 3e3: return ["Linear", "( value )"]; case 3001: return ["sRGB", "( value )"]; case 3002: return ["RGBE", "( value )"]; case 3004: return ["RGBM", "( value, 7.0 )"]; case 3005: return ["RGBM", "( value, 16.0 )"]; case 3006: return ["RGBD", "( value, 256.0 )"]; case 3007: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; default: throw new Error("unsupported encoding: " + e) } } function oi(e, t) { var i = si(t); return "vec4 " + e + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }" } function li(e, t) { var i = si(t); return "vec4 " + e + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }" } function ci(e, t) { var i; switch (t) { case 1: i = "Linear"; break; case 2: i = "Reinhard"; break; case 3: i = "Uncharted2"; break; case 4: i = "OptimizedCineon"; break; case 5: i = "ACESFilmic"; break; default: throw new Error("unsupported toneMapping: " + t) }return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }" } function hi(e) { return "" !== e } function ui(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights) } function di(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } function pi(e) { return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, (function (e, t) { var i = F[t]; if (void 0 === i) throw new Error("Can not resolve #include <" + t + ">"); return pi(i) })) } function fi(e) { return e.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, (function (e, t, i, n) { for (var r = "", a = parseInt(t); a < parseInt(i); a++)r += n.replace(/\[ i \]/g, "[ " + a + " ]"); return r })) } function mi(e, t, i, n, r, a, s, o) { var l = e.context, c = n.defines, h = r.vertexShader, u = r.fragmentShader, d = "SHADOWMAP_TYPE_BASIC"; 1 === a.shadowMapType ? d = "SHADOWMAP_TYPE_PCF" : 2 === a.shadowMapType && (d = "SHADOWMAP_TYPE_PCF_SOFT"); var p = "ENVMAP_TYPE_CUBE", f = "ENVMAP_MODE_REFLECTION", m = "ENVMAP_BLENDING_MULTIPLY"; if (a.envMap) { switch (n.envMap.mapping) { case 301: case 302: p = "ENVMAP_TYPE_CUBE"; break; case 306: case 307: p = "ENVMAP_TYPE_CUBE_UV"; break; case 303: case 304: p = "ENVMAP_TYPE_EQUIREC"; break; case 305: p = "ENVMAP_TYPE_SPHERE" }switch (n.envMap.mapping) { case 302: case 304: f = "ENVMAP_MODE_REFRACTION" }switch (n.combine) { case 0: m = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: m = "ENVMAP_BLENDING_MIX"; break; case 2: m = "ENVMAP_BLENDING_ADD" } } var g, v, y = e.gammaFactor > 0 ? e.gammaFactor : 1, _ = s.isWebGL2 ? "" : function (e, t, i) { return [(e = e || {}).derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap && !t.objectSpaceNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(hi).join("\n") }(n.extensions, a, t), x = function (e) { var t = []; for (var i in e) { var n = e[i]; !1 !== n && t.push("#define " + i + " " + n) } return t.join("\n") }(c), b = l.createProgram(); if (n.isRawShaderMaterial ? ((g = [x].filter(hi).join("\n")).length > 0 && (g += "\n"), (v = [_, x].filter(hi).join("\n")).length > 0 && (v += "\n")) : (g = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, x, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + d : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (s.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(hi).join("\n"), v = [_, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, x, a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + y, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + p : "", a.envMap ? "#define " + f : "", a.envMap ? "#define " + m : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + d : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (s.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (s.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== a.toneMapping ? "#define TONE_MAPPING" : "", 0 !== a.toneMapping ? F.tonemapping_pars_fragment : "", 0 !== a.toneMapping ? ci("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? F.encodings_pars_fragment : "", a.mapEncoding ? oi("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? oi("matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? oi("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? oi("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? li("linearToOutputTexel", a.outputEncoding) : "", a.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(hi).join("\n")), h = di(h = ui(h = pi(h), a), a), u = di(u = ui(u = pi(u), a), a), h = fi(h), u = fi(u), s.isWebGL2 && !n.isRawShaderMaterial) { var w = !1, T = /^\s*#version\s+300\s+es\s*\n/; n.isShaderMaterial && null !== h.match(T) && null !== u.match(T) && (w = !0, h = h.replace(T, ""), u = u.replace(T, "")), g = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#version 300 es\n", "#define varying in", w ? "" : "out highp vec4 pc_fragColor;", w ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v } var M, S, E = v + u, C = ri(l, 35633, g + h, e.debug.checkShaderErrors), A = ri(l, 35632, E, e.debug.checkShaderErrors); if (l.attachShader(b, C), l.attachShader(b, A), void 0 !== n.index0AttributeName ? l.bindAttribLocation(b, 0, n.index0AttributeName) : !0 === a.morphTargets && l.bindAttribLocation(b, 0, "position"), l.linkProgram(b), e.debug.checkShaderErrors) { var P = l.getProgramInfoLog(b).trim(), L = l.getShaderInfoLog(C).trim(), R = l.getShaderInfoLog(A).trim(), O = !0, I = !0; !1 === l.getProgramParameter(b, 35714) ? (O = !1, console.error("THREE.WebGLProgram: shader error: ", l.getError(), "35715", l.getProgramParameter(b, 35715), "gl.getProgramInfoLog", P, L, R)) : "" !== P ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", P) : "" !== L && "" !== R || (I = !1), I && (this.diagnostics = { runnable: O, material: n, programLog: P, vertexShader: { log: L, prefix: g }, fragmentShader: { log: R, prefix: v } }) } return l.deleteShader(C), l.deleteShader(A), this.getUniforms = function () { return void 0 === M && (M = new ni(l, b, o)), M }, this.getAttributes = function () { return void 0 === S && (S = function (e, t) { for (var i = {}, n = e.getProgramParameter(t, 35721), r = 0; r < n; r++) { var a = e.getActiveAttrib(t, r).name; i[a] = e.getAttribLocation(t, a) } return i }(l, b)), S }, this.destroy = function () { l.deleteProgram(b), this.program = void 0 }, Object.defineProperties(this, { uniforms: { get: function () { return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms() } }, attributes: { get: function () { return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes() } } }), this.name = r.name, this.id = ai++, this.code = i, this.usedTimes = 1, this.program = b, this.vertexShader = C, this.fragmentShader = A, this } function gi(e, t, i, n) { var r = [], a = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, s = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"]; function o(e, t) { var i; return e ? e.isTexture ? i = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = e.texture.encoding) : i = 3e3, 3e3 === i && t && (i = 3007), i } this.getParameters = function (t, n, r, s, l, c, h) { var u = a[t.type], d = h.isSkinnedMesh ? function (e) { var t = e.skeleton.bones; if (i.floatVertexTextures) return 1024; var n = i.maxVertexUniforms, r = Math.floor((n - 20) / 4), a = Math.min(r, t.length); return a < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + a + "."), 0) : a }(h) : 0, p = i.precision; null !== t.precision && (p = i.getMaxPrecision(t.precision)) !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", p, "instead."); var f = e.getRenderTarget(); return { shaderID: u, precision: p, supportsVertexTextures: i.vertexTextures, outputEncoding: o(f ? f.texture : null, e.gammaOutput), map: !!t.map, mapEncoding: o(t.map, e.gammaInput), matcap: !!t.matcap, matcapEncoding: o(t.matcap, e.gammaInput), envMap: !!t.envMap, envMapMode: t.envMap && t.envMap.mapping, envMapEncoding: o(t.envMap, e.gammaInput), envMapCubeUV: !!t.envMap && (306 === t.envMap.mapping || 307 === t.envMap.mapping), lightMap: !!t.lightMap, aoMap: !!t.aoMap, emissiveMap: !!t.emissiveMap, emissiveMapEncoding: o(t.emissiveMap, e.gammaInput), bumpMap: !!t.bumpMap, normalMap: !!t.normalMap, objectSpaceNormalMap: 1 === t.normalMapType, displacementMap: !!t.displacementMap, roughnessMap: !!t.roughnessMap, metalnessMap: !!t.metalnessMap, specularMap: !!t.specularMap, alphaMap: !!t.alphaMap, gradientMap: !!t.gradientMap, combine: t.combine, vertexTangents: t.normalMap && t.vertexTangents, vertexColors: t.vertexColors, fog: !!s, useFog: t.fog, fogExp: s && s.isFogExp2, flatShading: t.flatShading, sizeAttenuation: t.sizeAttenuation, logarithmicDepthBuffer: i.logarithmicDepthBuffer, skinning: t.skinning && d > 0, maxBones: d, useVertexTexture: i.floatVertexTextures, morphTargets: t.morphTargets, morphNormals: t.morphNormals, maxMorphTargets: e.maxMorphTargets, maxMorphNormals: e.maxMorphNormals, numDirLights: n.directional.length, numPointLights: n.point.length, numSpotLights: n.spot.length, numRectAreaLights: n.rectArea.length, numHemiLights: n.hemi.length, numClippingPlanes: l, numClipIntersection: c, dithering: t.dithering, shadowMapEnabled: e.shadowMap.enabled && h.receiveShadow && r.length > 0, shadowMapType: e.shadowMap.type, toneMapping: e.toneMapping, physicallyCorrectLights: e.physicallyCorrectLights, premultipliedAlpha: t.premultipliedAlpha, alphaTest: t.alphaTest, doubleSided: 2 === t.side, flipSided: 1 === t.side, depthPacking: void 0 !== t.depthPacking && t.depthPacking } }, this.getProgramCode = function (t, i) { var n = []; if (i.shaderID ? n.push(i.shaderID) : (n.push(t.fragmentShader), n.push(t.vertexShader)), void 0 !== t.defines) for (var r in t.defines) n.push(r), n.push(t.defines[r]); for (var a = 0; a < s.length; a++)n.push(i[s[a]]); return n.push(t.onBeforeCompile.toString()), n.push(e.gammaOutput), n.push(e.gammaFactor), n.join() }, this.acquireProgram = function (a, s, o, l) { for (var c, h = 0, u = r.length; h < u; h++) { var d = r[h]; if (d.code === l) { ++(c = d).usedTimes; break } } return void 0 === c && (c = new mi(e, t, l, a, s, o, i, n), r.push(c)), c }, this.releaseProgram = function (e) { if (0 == --e.usedTimes) { var t = r.indexOf(e); r[t] = r[r.length - 1], r.pop(), e.destroy() } }, this.programs = r } function vi() { var e = new WeakMap; return { get: function (t) { var i = e.get(t); return void 0 === i && (i = {}, e.set(t, i)), i }, remove: function (t) { e.delete(t) }, update: function (t, i, n) { e.get(t)[i] = n }, dispose: function () { e = new WeakMap } } } function yi(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id } function _i(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id } function xi() { var e = [], t = 0, i = [], n = [], r = { id: -1 }; function a(i, n, a, s, o, l) { var c = e[t]; return void 0 === c ? (c = { id: i.id, object: i, geometry: n, material: a, program: a.program || r, groupOrder: s, renderOrder: i.renderOrder, z: o, group: l }, e[t] = c) : (c.id = i.id, c.object = i, c.geometry = n, c.material = a, c.program = a.program || r, c.groupOrder = s, c.renderOrder = i.renderOrder, c.z = o, c.group = l), t++, c } return { opaque: i, transparent: n, init: function () { t = 0, i.length = 0, n.length = 0 }, push: function (e, t, r, s, o, l) { var c = a(e, t, r, s, o, l); (!0 === r.transparent ? n : i).push(c) }, unshift: function (e, t, r, s, o, l) { var c = a(e, t, r, s, o, l); (!0 === r.transparent ? n : i).unshift(c) }, sort: function () { i.length > 1 && i.sort(yi), n.length > 1 && n.sort(_i) } } } function bi() { var e = {}; function t(i) { var n = i.target; n.removeEventListener("dispose", t), delete e[n.id] } return { get: function (i, n) { var r, a = e[i.id]; return void 0 === a ? (r = new xi, e[i.id] = {}, e[i.id][n.id] = r, i.addEventListener("dispose", t)) : void 0 === (r = a[n.id]) && (r = new xi, a[n.id] = r), r }, dispose: function () { e = {} } } } function wi() { var e = {}; return { get: function (t) { if (void 0 !== e[t.id]) return e[t.id]; var i; switch (t.type) { case "DirectionalLight": i = { direction: new h, color: new X, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new l }; break; case "SpotLight": i = { position: new h, direction: new h, color: new X, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new l }; break; case "PointLight": i = { position: new h, color: new X, distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new l, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break; case "HemisphereLight": i = { direction: new h, skyColor: new X, groundColor: new X }; break; case "RectAreaLight": i = { color: new X, position: new h, halfWidth: new h, halfHeight: new h } }return e[t.id] = i, i } } } var Ti = 0; function Mi() { for (var e = new wi, t = { id: Ti++, hash: { stateID: -1, directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, shadowsLength: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }, i = 0; i < 9; i++)t.probe.push(new h); var n = new h, r = new B, a = new B; return { setup: function (i, s, o) { for (var l = 0, c = 0, h = 0, u = 0; u < 9; u++)t.probe[u].set(0, 0, 0); for (var d = 0, p = 0, f = 0, m = 0, g = 0, v = o.matrixWorldInverse, y = (u = 0, i.length); u < y; u++) { var _ = i[u], x = _.color, b = _.intensity, w = _.distance, T = _.shadow && _.shadow.map ? _.shadow.map.texture : null; if (_.isAmbientLight) l += x.r * b, c += x.g * b, h += x.b * b; else if (_.isLightProbe) for (var M = 0; M < 9; M++)t.probe[M].addScaledVector(_.sh.coefficients[M], b); else if (_.isDirectionalLight) { if ((E = e.get(_)).color.copy(_.color).multiplyScalar(_.intensity), E.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(v), E.shadow = _.castShadow, _.castShadow) { var S = _.shadow; E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize } t.directionalShadowMap[d] = T, t.directionalShadowMatrix[d] = _.shadow.matrix, t.directional[d] = E, d++ } else if (_.isSpotLight) { if ((E = e.get(_)).position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(v), E.color.copy(x).multiplyScalar(b), E.distance = w, E.direction.setFromMatrixPosition(_.matrixWorld), n.setFromMatrixPosition(_.target.matrixWorld), E.direction.sub(n), E.direction.transformDirection(v), E.coneCos = Math.cos(_.angle), E.penumbraCos = Math.cos(_.angle * (1 - _.penumbra)), E.decay = _.decay, E.shadow = _.castShadow, _.castShadow) { S = _.shadow; E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize } t.spotShadowMap[f] = T, t.spotShadowMatrix[f] = _.shadow.matrix, t.spot[f] = E, f++ } else if (_.isRectAreaLight) { (E = e.get(_)).color.copy(x).multiplyScalar(b), E.position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(v), a.identity(), r.copy(_.matrixWorld), r.premultiply(v), a.extractRotation(r), E.halfWidth.set(.5 * _.width, 0, 0), E.halfHeight.set(0, .5 * _.height, 0), E.halfWidth.applyMatrix4(a), E.halfHeight.applyMatrix4(a), t.rectArea[m] = E, m++ } else if (_.isPointLight) { if ((E = e.get(_)).position.setFromMatrixPosition(_.matrixWorld), E.position.applyMatrix4(v), E.color.copy(_.color).multiplyScalar(_.intensity), E.distance = _.distance, E.decay = _.decay, E.shadow = _.castShadow, _.castShadow) { S = _.shadow; E.shadowBias = S.bias, E.shadowRadius = S.radius, E.shadowMapSize = S.mapSize, E.shadowCameraNear = S.camera.near, E.shadowCameraFar = S.camera.far } t.pointShadowMap[p] = T, t.pointShadowMatrix[p] = _.shadow.matrix, t.point[p] = E, p++ } else if (_.isHemisphereLight) { var E; (E = e.get(_)).direction.setFromMatrixPosition(_.matrixWorld), E.direction.transformDirection(v), E.direction.normalize(), E.skyColor.copy(_.color).multiplyScalar(b), E.groundColor.copy(_.groundColor).multiplyScalar(b), t.hemi[g] = E, g++ } } t.ambient[0] = l, t.ambient[1] = c, t.ambient[2] = h, t.directional.length = d, t.spot.length = f, t.rectArea.length = m, t.point.length = p, t.hemi.length = g, t.hash.stateID = t.id, t.hash.directionalLength = d, t.hash.pointLength = p, t.hash.spotLength = f, t.hash.rectAreaLength = m, t.hash.hemiLength = g, t.hash.shadowsLength = s.length }, state: t } } function Si() { var e = new Mi, t = [], i = []; return { init: function () { t.length = 0, i.length = 0 }, state: { lightsArray: t, shadowsArray: i, lights: e }, setupLights: function (n) { e.setup(t, i, n) }, pushLight: function (e) { t.push(e) }, pushShadow: function (e) { i.push(e) } } } function Ei() { var e = {}; function t(i) { var n = i.target; n.removeEventListener("dispose", t), delete e[n.id] } return { get: function (i, n) { var r; return void 0 === e[i.id] ? (r = new Si, e[i.id] = {}, e[i.id][n.id] = r, i.addEventListener("dispose", t)) : void 0 === e[i.id][n.id] ? (r = new Si, e[i.id][n.id] = r) : r = e[i.id][n.id], r }, dispose: function () { e = {} } } } function Ci(e) { Oe.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e) } function Ai(e) { Oe.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new h, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(e) } function Pi(e, t, i) { for (var n = new N, r = new B, a = new l, s = new l(i, i), o = new h, c = new h, u = new Array(4), d = new Array(4), p = {}, f = { 0: 1, 1: 0, 2: 2 }, m = [new h(1, 0, 0), new h(-1, 0, 0), new h(0, 0, 1), new h(0, 0, -1), new h(0, 1, 0), new h(0, -1, 0)], g = [new h(0, 1, 0), new h(0, 1, 0), new h(0, 1, 0), new h(0, 1, 0), new h(0, 0, 1), new h(0, 0, -1)], v = [new P, new P, new P, new P, new P, new P], y = 0; 4 !== y; ++y) { var _ = 0 != (1 & y), x = 0 != (2 & y), b = new Ci({ depthPacking: 3201, morphTargets: _, skinning: x }); u[y] = b; var w = new Ai({ morphTargets: _, skinning: x }); d[y] = w } var T = this; function M(t, i, n, r, a, s) { var o = t.geometry, l = null, c = u, h = t.customDepthMaterial; if (n && (c = d, h = t.customDistanceMaterial), h) l = h; else { var m = !1; i.morphTargets && (o && o.isBufferGeometry ? m = o.morphAttributes && o.morphAttributes.position && o.morphAttributes.position.length > 0 : o && o.isGeometry && (m = o.morphTargets && o.morphTargets.length > 0)), t.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t); var g = 0; m && (g |= 1), t.isSkinnedMesh && i.skinning && (g |= 2), l = c[g] } if (e.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) { var v = l.uuid, y = i.uuid, _ = p[v]; void 0 === _ && (_ = {}, p[v] = _); var x = _[y]; void 0 === x && (x = l.clone(), _[y] = x), l = x } return l.visible = i.visible, l.wireframe = i.wireframe, l.side = null != i.shadowSide ? i.shadowSide : f[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, n && l.isMeshDistanceMaterial && (l.referencePosition.copy(r), l.nearDistance = a, l.farDistance = s), l } function S(i, r, a, s) { if (!1 !== i.visible) { if (i.layers.test(r.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || n.intersectsObject(i))) { i.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, i.matrixWorld); var o = t.update(i), l = i.material; if (Array.isArray(l)) for (var h = o.groups, u = 0, d = h.length; u < d; u++) { var p = h[u], f = l[p.materialIndex]; if (f && f.visible) { var m = M(i, f, s, c, a.near, a.far); e.renderBufferDirect(a, null, o, m, i, p) } } else if (l.visible) { m = M(i, l, s, c, a.near, a.far); e.renderBufferDirect(a, null, o, m, i, null) } } for (var g = i.children, v = 0, y = g.length; v < y; v++)S(g[v], r, a, s) } } this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (t, i, l) { if (!1 !== T.enabled && (!1 !== T.autoUpdate || !1 !== T.needsUpdate) && 0 !== t.length) { var h, u = e.getRenderTarget(), d = e.getActiveCubeFace(), p = e.getActiveMipMapLevel(), f = e.state; f.setBlending(0), f.buffers.color.setClear(1, 1, 1, 1), f.buffers.depth.setTest(!0), f.setScissorTest(!1); for (var y = 0, _ = t.length; y < _; y++) { var x = t[y], b = x.shadow, w = x && x.isPointLight; if (void 0 !== b) { var M = b.camera; if (a.copy(b.mapSize), a.min(s), w) { var E = a.x, C = a.y; v[0].set(2 * E, C, E, C), v[1].set(0, C, E, C), v[2].set(3 * E, C, E, C), v[3].set(E, C, E, C), v[4].set(3 * E, 0, E, C), v[5].set(E, 0, E, C), a.x *= 4, a.y *= 2 } if (null === b.map) { var A = { minFilter: 1003, magFilter: 1003, format: 1023 }; b.map = new L(a.x, a.y, A), b.map.texture.name = x.name + ".shadowMap", M.updateProjectionMatrix() } b.isSpotLightShadow && b.update(x); var P = b.map, R = b.matrix; c.setFromMatrixPosition(x.matrixWorld), M.position.copy(c), w ? (h = 6, R.makeTranslation(-c.x, -c.y, -c.z)) : (h = 1, o.setFromMatrixPosition(x.target.matrixWorld), M.lookAt(o), M.updateMatrixWorld(), R.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), R.multiply(M.projectionMatrix), R.multiply(M.matrixWorldInverse)), e.setRenderTarget(P), e.clear(); for (var O = 0; O < h; O++) { if (w) { o.copy(M.position), o.add(m[O]), M.up.copy(g[O]), M.lookAt(o), M.updateMatrixWorld(); var I = v[O]; f.viewport(I) } r.multiplyMatrices(M.projectionMatrix, M.matrixWorldInverse), n.setFromMatrix(r), S(i, l, M, w) } } else console.warn("THREE.WebGLShadowMap:", x, "has no shadow.") } T.needsUpdate = !1, e.setRenderTarget(u, d, p) } } } function Li(e, t, i, n) { var r = new function () { var t = !1, i = new P, n = null, r = new P(0, 0, 0, 0); return { setMask: function (i) { n === i || t || (e.colorMask(i, i, i, i), n = i) }, setLocked: function (e) { t = e }, setClear: function (t, n, a, s, o) { !0 === o && (t *= s, n *= s, a *= s), i.set(t, n, a, s), !1 === r.equals(i) && (e.clearColor(t, n, a, s), r.copy(i)) }, reset: function () { t = !1, n = null, r.set(-1, 0, 0, 0) } } }, a = new function () { var t = !1, i = null, n = null, r = null; return { setTest: function (e) { e ? G(2929) : U(2929) }, setMask: function (n) { i === n || t || (e.depthMask(n), i = n) }, setFunc: function (t) { if (n !== t) { if (t) switch (t) { case 0: e.depthFunc(512); break; case 1: e.depthFunc(519); break; case 2: e.depthFunc(513); break; case 3: e.depthFunc(515); break; case 4: e.depthFunc(514); break; case 5: e.depthFunc(518); break; case 6: e.depthFunc(516); break; case 7: e.depthFunc(517); break; default: e.depthFunc(515) } else e.depthFunc(515); n = t } }, setLocked: function (e) { t = e }, setClear: function (t) { r !== t && (e.clearDepth(t), r = t) }, reset: function () { t = !1, i = null, n = null, r = null } } }, s = new function () { var t = !1, i = null, n = null, r = null, a = null, s = null, o = null, l = null, c = null; return { setTest: function (e) { e ? G(2960) : U(2960) }, setMask: function (n) { i === n || t || (e.stencilMask(n), i = n) }, setFunc: function (t, i, s) { n === t && r === i && a === s || (e.stencilFunc(t, i, s), n = t, r = i, a = s) }, setOp: function (t, i, n) { s === t && o === i && l === n || (e.stencilOp(t, i, n), s = t, o = i, l = n) }, setLocked: function (e) { t = e }, setClear: function (t) { c !== t && (e.clearStencil(t), c = t) }, reset: function () { t = !1, i = null, n = null, r = null, a = null, s = null, o = null, l = null, c = null } } }, o = e.getParameter(34921), l = new Uint8Array(o), c = new Uint8Array(o), h = new Uint8Array(o), u = {}, d = null, p = null, f = null, m = null, g = null, v = null, y = null, _ = null, x = null, b = null, w = !1, T = null, M = null, S = null, E = null, C = null, A = e.getParameter(35661), L = !1, R = 0, O = e.getParameter(7938); -1 !== O.indexOf("WebGL") ? (R = parseFloat(/^WebGL\ ([0-9])/.exec(O)[1]), L = R >= 1) : -1 !== O.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(O)[1]), L = R >= 2); var I = null, k = {}, D = new P, z = new P; function N(t, i, n) { var r = new Uint8Array(4), a = e.createTexture(); e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728); for (var s = 0; s < n; s++)e.texImage2D(i + s, 0, 6408, 1, 1, 0, 6408, 5121, r); return a } var B = {}; function F(i, r) { (l[i] = 1, 0 === c[i] && (e.enableVertexAttribArray(i), c[i] = 1), h[i] !== r) && ((n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), h[i] = r) } function G(t) { !0 !== u[t] && (e.enable(t), u[t] = !0) } function U(t) { !1 !== u[t] && (e.disable(t), u[t] = !1) } function H(t, n, r, a, s, o, l, c) { if (0 !== t) { if (f || (G(3042), f = !0), 5 === t) s = s || n, o = o || r, l = l || a, n === g && s === _ || (e.blendEquationSeparate(i.convert(n), i.convert(s)), g = n, _ = s), r === v && a === y && o === x && l === b || (e.blendFuncSeparate(i.convert(r), i.convert(a), i.convert(o), i.convert(l)), v = r, y = a, x = o, b = l), m = t, w = null; else if (t !== m || c !== w) { if (100 === g && 100 === _ || (e.blendEquation(32774), g = 100, _ = 100), c) switch (t) { case 1: e.blendFuncSeparate(1, 771, 1, 771); break; case 2: e.blendFunc(1, 1); break; case 3: e.blendFuncSeparate(0, 0, 769, 771); break; case 4: e.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) } else switch (t) { case 1: e.blendFuncSeparate(770, 771, 1, 771); break; case 2: e.blendFunc(770, 1); break; case 3: e.blendFunc(0, 769); break; case 4: e.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", t) }v = null, y = null, x = null, b = null, m = t, w = c } } else f && (U(3042), f = !1) } function V(t) { T !== t && (t ? e.frontFace(2304) : e.frontFace(2305), T = t) } function j(t) { 0 !== t ? (G(2884), t !== M && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : U(2884), M = t } function W(t, i, n) { t ? (G(32823), E === i && C === n || (e.polygonOffset(i, n), E = i, C = n)) : U(32823) } function $(t) { void 0 === t && (t = 33984 + A - 1), I !== t && (e.activeTexture(t), I = t) } return B[3553] = N(3553, 3553, 1), B[34067] = N(34067, 34069, 6), r.setClear(0, 0, 0, 1), a.setClear(1), s.setClear(0), G(2929), a.setFunc(3), V(!1), j(1), G(2884), H(0), { buffers: { color: r, depth: a, stencil: s }, initAttributes: function () { for (var e = 0, t = l.length; e < t; e++)l[e] = 0 }, enableAttribute: function (e) { F(e, 0) }, enableAttributeAndDivisor: F, disableUnusedAttributes: function () { for (var t = 0, i = c.length; t !== i; ++t)c[t] !== l[t] && (e.disableVertexAttribArray(t), c[t] = 0) }, enable: G, disable: U, getCompressedTextureFormats: function () { if (null === d && (d = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc"))) for (var i = e.getParameter(34467), n = 0; n < i.length; n++)d.push(i[n]); return d }, useProgram: function (t) { return p !== t && (e.useProgram(t), p = t, !0) }, setBlending: H, setMaterial: function (e, t) { 2 === e.side ? U(2884) : G(2884); var i = 1 === e.side; t && (i = !i), V(i), 1 === e.blending && !1 === e.transparent ? H(0) : H(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), r.setMask(e.colorWrite), W(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits) }, setFlipSided: V, setCullFace: j, setLineWidth: function (t) { t !== S && (L && e.lineWidth(t), S = t) }, setPolygonOffset: W, setScissorTest: function (e) { e ? G(3089) : U(3089) }, activeTexture: $, bindTexture: function (t, i) { null === I && $(); var n = k[I]; void 0 === n && (n = { type: void 0, texture: void 0 }, k[I] = n), n.type === t && n.texture === i || (e.bindTexture(t, i || B[t]), n.type = t, n.texture = i) }, compressedTexImage2D: function () { try { e.compressedTexImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function () { try { e.texImage2D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function () { try { e.texImage3D.apply(e, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function (t) { !1 === D.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), D.copy(t)) }, viewport: function (t) { !1 === z.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), z.copy(t)) }, reset: function () { for (var t = 0; t < c.length; t++)1 === c[t] && (e.disableVertexAttribArray(t), c[t] = 0); u = {}, d = null, I = null, k = {}, p = null, m = null, T = null, M = null, r.reset(), a.reset(), s.reset() } } } function Ri(e, t, i, n, r, a, s) { var l, c = {}, h = "undefined" != typeof OffscreenCanvas; function u(e, t) { return h ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function d(e, t, i, n) { var r = 1; if ((e.width > n || e.height > n) && (r = n / Math.max(e.width, e.height)), r < 1 || !0 === t) { if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) { var a = t ? o.floorPowerOfTwo : Math.floor, s = a(r * e.width), c = a(r * e.height); void 0 === l && (l = u(s, c)); var h = i ? u(s, c) : l; return h.width = s, h.height = c, h.getContext("2d").drawImage(e, 0, 0, s, c), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + c + ")."), h } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e } return e } function p(e) { return o.isPowerOfTwo(e.width) && o.isPowerOfTwo(e.height) } function f(e, t) { return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter } function m(t, i, r, a) { e.generateMipmap(t), n.get(i).__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E } function g(e, i) { if (!r.isWebGL2) return e; var n = e; return 6403 === e && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 5121 === i && (n = 33321)), 6407 === e && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 5121 === i && (n = 32849)), 6408 === e && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 5121 === i && (n = 32856)), 33325 === n || 33326 === n || 34842 === n || 34836 === n ? t.get("EXT_color_buffer_float") : 34843 !== n && 34837 !== n || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n } function v(e) { return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729 } function y(t) { var i = t.target; i.removeEventListener("dispose", y), function (t) { var i = n.get(t); if (void 0 === i.__webglInit) return; e.deleteTexture(i.__webglTexture), n.remove(t) }(i), i.isVideoTexture && delete c[i.id], s.memory.textures-- } function _(t) { var i = t.target; i.removeEventListener("dispose", _), function (t) { var i = n.get(t), r = n.get(t.texture); if (!t) return; void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture); t.depthTexture && t.depthTexture.dispose(); if (t.isWebGLRenderTargetCube) for (var a = 0; a < 6; a++)e.deleteFramebuffer(i.__webglFramebuffer[a]), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[a]); else e.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer); n.remove(t.texture), n.remove(t) }(i), s.memory.textures-- } var x = 0; function b(e, t) { var r = n.get(e); if (e.isVideoTexture && function (e) { var t = e.id, i = s.render.frame; c[t] !== i && (c[t] = i, e.update()) }(e), e.version > 0 && r.__version !== e.version) { var a = e.image; if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== a.complete) return void E(r, e, t); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } } i.activeTexture(33984 + t), i.bindTexture(3553, r.__webglTexture) } function w(t, s) { var o = n.get(t); if (6 === t.image.length) if (t.version > 0 && o.__version !== t.version) { S(o, t), i.activeTexture(33984 + s), i.bindTexture(34067, o.__webglTexture), e.pixelStorei(37440, t.flipY); for (var l = t && t.isCompressedTexture, c = t.image[0] && t.image[0].isDataTexture, h = [], u = 0; u < 6; u++)h[u] = l || c ? c ? t.image[u].image : t.image[u] : d(t.image[u], !1, !0, r.maxCubemapSize); var v = h[0], y = p(v) || r.isWebGL2, _ = a.convert(t.format), x = a.convert(t.type), b = g(_, x); M(34067, t, y); for (u = 0; u < 6; u++)if (l) for (var w, T = h[u].mipmaps, E = 0, C = T.length; E < C; E++)w = T[E], 1023 !== t.format && 1022 !== t.format ? i.getCompressedTextureFormats().indexOf(_) > -1 ? i.compressedTexImage2D(34069 + u, E, b, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + u, E, b, w.width, w.height, 0, _, x, w.data); else c ? i.texImage2D(34069 + u, 0, b, h[u].width, h[u].height, 0, _, x, h[u].data) : i.texImage2D(34069 + u, 0, b, _, x, h[u]); o.__maxMipLevel = l ? T.length - 1 : 0, f(t, y) && m(34067, t, v.width, v.height), o.__version = t.version, t.onUpdate && t.onUpdate(t) } else i.activeTexture(33984 + s), i.bindTexture(34067, o.__webglTexture) } function T(e, t) { i.activeTexture(33984 + t), i.bindTexture(34067, n.get(e).__webglTexture) } function M(i, s, o) { var l; if (o ? (e.texParameteri(i, 10242, a.convert(s.wrapS)), e.texParameteri(i, 10243, a.convert(s.wrapT)), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, a.convert(s.wrapR)), e.texParameteri(i, 10240, a.convert(s.magFilter)), e.texParameteri(i, 10241, a.convert(s.minFilter))) : (e.texParameteri(i, 10242, 33071), e.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || e.texParameteri(i, 32882, 33071), 1001 === s.wrapS && 1001 === s.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(i, 10240, v(s.magFilter)), e.texParameteri(i, 10241, v(s.minFilter)), 1003 !== s.minFilter && 1006 !== s.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), l = t.get("EXT_texture_filter_anisotropic")) { if (1015 === s.type && null === t.get("OES_texture_float_linear")) return; if (1016 === s.type && null === (r.isWebGL2 || t.get("OES_texture_half_float_linear"))) return; (s.anisotropy > 1 || n.get(s).__currentAnisotropy) && (e.texParameterf(i, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), n.get(s).__currentAnisotropy = s.anisotropy) } } function S(t, i) { void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", y), t.__webglTexture = e.createTexture(), s.memory.textures++) } function E(t, n, s) { var o = 3553; n.isDataTexture2DArray && (o = 35866), n.isDataTexture3D && (o = 32879), S(t, n), i.activeTexture(33984 + s), i.bindTexture(o, t.__webglTexture), e.pixelStorei(37440, n.flipY), e.pixelStorei(37441, n.premultiplyAlpha), e.pixelStorei(3317, n.unpackAlignment); var l = function (e) { return !r.isWebGL2 && (1001 !== e.wrapS || 1001 !== e.wrapT || 1003 !== e.minFilter && 1006 !== e.minFilter) }(n) && !1 === p(n.image), c = d(n.image, l, !1, r.maxTextureSize), h = p(c) || r.isWebGL2, u = a.convert(n.format), v = a.convert(n.type), y = g(u, v); M(o, n, h); var _, x = n.mipmaps; if (n.isDepthTexture) { if (y = 6402, 1015 === n.type) { if (!r.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0"); y = 36012 } else r.isWebGL2 && (y = 33189); 1026 === n.format && 6402 === y && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, v = a.convert(n.type)), 1027 === n.format && (y = 34041, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, v = a.convert(n.type))), i.texImage2D(3553, 0, y, c.width, c.height, 0, u, v, null) } else if (n.isDataTexture) if (x.length > 0 && h) { for (var b = 0, w = x.length; b < w; b++)_ = x[b], i.texImage2D(3553, b, y, _.width, _.height, 0, u, v, _.data); n.generateMipmaps = !1, t.__maxMipLevel = x.length - 1 } else i.texImage2D(3553, 0, y, c.width, c.height, 0, u, v, c.data), t.__maxMipLevel = 0; else if (n.isCompressedTexture) { for (b = 0, w = x.length; b < w; b++)_ = x[b], 1023 !== n.format && 1022 !== n.format ? i.getCompressedTextureFormats().indexOf(u) > -1 ? i.compressedTexImage2D(3553, b, y, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, b, y, _.width, _.height, 0, u, v, _.data); t.__maxMipLevel = x.length - 1 } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, y, c.width, c.height, c.depth, 0, u, v, c.data), t.__maxMipLevel = 0; else if (n.isDataTexture3D) i.texImage3D(32879, 0, y, c.width, c.height, c.depth, 0, u, v, c.data), t.__maxMipLevel = 0; else if (x.length > 0 && h) { for (b = 0, w = x.length; b < w; b++)_ = x[b], i.texImage2D(3553, b, y, u, v, _); n.generateMipmaps = !1, t.__maxMipLevel = x.length - 1 } else i.texImage2D(3553, 0, y, u, v, c), t.__maxMipLevel = 0; f(n, h) && m(3553, n, c.width, c.height), t.__version = n.version, n.onUpdate && n.onUpdate(n) } function C(t, r, s, o) { var l = a.convert(r.texture.format), c = a.convert(r.texture.type), h = g(l, c); i.texImage2D(o, 0, h, r.width, r.height, 0, l, c, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, s, o, n.get(r.texture).__webglTexture, 0), e.bindFramebuffer(36160, null) } function A(t, i, n) { if (e.bindRenderbuffer(36161, t), i.depthBuffer && !i.stencilBuffer) { if (n) { var r = L(i); e.renderbufferStorageMultisample(36161, r, 33189, i.width, i.height) } else e.renderbufferStorage(36161, 33189, i.width, i.height); e.framebufferRenderbuffer(36160, 36096, 36161, t) } else if (i.depthBuffer && i.stencilBuffer) { if (n) { r = L(i); e.renderbufferStorageMultisample(36161, r, 34041, i.width, i.height) } else e.renderbufferStorage(36161, 34041, i.width, i.height); e.framebufferRenderbuffer(36160, 33306, 36161, t) } else { var s = g(a.convert(i.texture.format), a.convert(i.texture.type)); if (n) { r = L(i); e.renderbufferStorageMultisample(36161, r, s, i.width, i.height) } else e.renderbufferStorage(36161, s, i.width, i.height) } e.bindRenderbuffer(36161, null) } function P(t) { var i = n.get(t), r = !0 === t.isWebGLRenderTargetCube; if (t.depthTexture) { if (r) throw new Error("target.depthTexture not supported in Cube render targets"); !function (t, i) { if (i && i.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported"); if (e.bindFramebuffer(36160, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); n.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), b(i.depthTexture, 0); var r = n.get(i.depthTexture).__webglTexture; if (1026 === i.depthTexture.format) e.framebufferTexture2D(36160, 36096, 3553, r, 0); else { if (1027 !== i.depthTexture.format) throw new Error("Unknown depthTexture format"); e.framebufferTexture2D(36160, 33306, 3553, r, 0) } }(i.__webglFramebuffer, t) } else if (r) { i.__webglDepthbuffer = []; for (var a = 0; a < 6; a++)e.bindFramebuffer(36160, i.__webglFramebuffer[a]), i.__webglDepthbuffer[a] = e.createRenderbuffer(), A(i.__webglDepthbuffer[a], t) } else e.bindFramebuffer(36160, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), A(i.__webglDepthbuffer, t); e.bindFramebuffer(36160, null) } function L(e) { return r.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, e.samples) : 0 } var R = !1, O = !1; this.allocateTextureUnit = function () { var e = x; return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures), x += 1, e }, this.resetTextureUnits = function () { x = 0 }, this.setTexture2D = b, this.setTexture2DArray = function (e, t) { var r = n.get(e); e.version > 0 && r.__version !== e.version ? E(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(35866, r.__webglTexture)) }, this.setTexture3D = function (e, t) { var r = n.get(e); e.version > 0 && r.__version !== e.version ? E(r, e, t) : (i.activeTexture(33984 + t), i.bindTexture(32879, r.__webglTexture)) }, this.setTextureCube = w, this.setTextureCubeDynamic = T, this.setupRenderTarget = function (t) { var o = n.get(t), l = n.get(t.texture); t.addEventListener("dispose", _), l.__webglTexture = e.createTexture(), s.memory.textures++; var c = !0 === t.isWebGLRenderTargetCube, h = !0 === t.isWebGLMultisampleRenderTarget, u = p(t) || r.isWebGL2; if (c) { o.__webglFramebuffer = []; for (var d = 0; d < 6; d++)o.__webglFramebuffer[d] = e.createFramebuffer() } else if (o.__webglFramebuffer = e.createFramebuffer(), h) if (r.isWebGL2) { o.__webglMultisampledFramebuffer = e.createFramebuffer(), o.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, o.__webglColorRenderbuffer); var v = g(a.convert(t.texture.format), a.convert(t.texture.type)), y = L(t); e.renderbufferStorageMultisample(36161, y, v, t.width, t.height), e.bindFramebuffer(36160, o.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, o.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (o.__webglDepthRenderbuffer = e.createRenderbuffer(), A(o.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (c) { i.bindTexture(34067, l.__webglTexture), M(34067, t.texture, u); for (d = 0; d < 6; d++)C(o.__webglFramebuffer[d], t, 36064, 34069 + d); f(t.texture, u) && m(34067, t.texture, t.width, t.height), i.bindTexture(34067, null) } else i.bindTexture(3553, l.__webglTexture), M(3553, t.texture, u), C(o.__webglFramebuffer, t, 36064, 3553), f(t.texture, u) && m(3553, t.texture, t.width, t.height), i.bindTexture(3553, null); t.depthBuffer && P(t) }, this.updateRenderTargetMipmap = function (e) { var t = e.texture; if (f(t, p(e) || r.isWebGL2)) { var a = e.isWebGLRenderTargetCube ? 34067 : 3553, s = n.get(t).__webglTexture; i.bindTexture(a, s), m(a, t, e.width, e.height), i.bindTexture(a, null) } }, this.updateMultisampleRenderTarget = function (t) { if (t.isWebGLMultisampleRenderTarget) if (r.isWebGL2) { var i = n.get(t); e.bindFramebuffer(36008, i.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, i.__webglFramebuffer); var a = t.width, s = t.height, o = 16384; t.depthBuffer && (o |= 256), t.stencilBuffer && (o |= 1024), e.blitFramebuffer(0, 0, a, s, 0, 0, a, s, o, 9728) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (e, t) { e && e.isWebGLRenderTarget && (!1 === R && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), R = !0), e = e.texture), b(e, t) }, this.safeSetTextureCube = function (e, t) { e && e.isWebGLRenderTargetCube && (!1 === O && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), O = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? w(e, t) : T(e, t) } } function Oi(e, t, i) { return { convert: function (e) { var n; if (1e3 === e) return 10497; if (1001 === e) return 33071; if (1002 === e) return 33648; if (1003 === e) return 9728; if (1004 === e) return 9984; if (1005 === e) return 9986; if (1006 === e) return 9729; if (1007 === e) return 9985; if (1008 === e) return 9987; if (1009 === e) return 5121; if (1017 === e) return 32819; if (1018 === e) return 32820; if (1019 === e) return 33635; if (1010 === e) return 5120; if (1011 === e) return 5122; if (1012 === e) return 5123; if (1013 === e) return 5124; if (1014 === e) return 5125; if (1015 === e) return 5126; if (1016 === e) { if (i.isWebGL2) return 5131; if (null !== (n = t.get("OES_texture_half_float"))) return n.HALF_FLOAT_OES } if (1021 === e) return 6406; if (1022 === e) return 6407; if (1023 === e) return 6408; if (1024 === e) return 6409; if (1025 === e) return 6410; if (1026 === e) return 6402; if (1027 === e) return 34041; if (1028 === e) return 6403; if (100 === e) return 32774; if (101 === e) return 32778; if (102 === e) return 32779; if (200 === e) return 0; if (201 === e) return 1; if (202 === e) return 768; if (203 === e) return 769; if (204 === e) return 770; if (205 === e) return 771; if (206 === e) return 772; if (207 === e) return 773; if (208 === e) return 774; if (209 === e) return 775; if (210 === e) return 776; if ((33776 === e || 33777 === e || 33778 === e || 33779 === e) && null !== (n = t.get("WEBGL_compressed_texture_s3tc"))) { if (33776 === e) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (33777 === e) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (33778 === e) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (33779 === e) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if ((35840 === e || 35841 === e || 35842 === e || 35843 === e) && null !== (n = t.get("WEBGL_compressed_texture_pvrtc"))) { if (35840 === e) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === e) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === e) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === e) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === e && null !== (n = t.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL; if ((37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e) && null !== (n = t.get("WEBGL_compressed_texture_astc"))) return e; if (103 === e || 104 === e) { if (i.isWebGL2) { if (103 === e) return 32775; if (104 === e) return 32776 } if (null !== (n = t.get("EXT_blend_minmax"))) { if (103 === e) return n.MIN_EXT; if (104 === e) return n.MAX_EXT } } if (1020 === e) { if (i.isWebGL2) return 34042; if (null !== (n = t.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL } return 0 } } } function Ii() { le.call(this), this.type = "Group" } function ki() { le.call(this), this.type = "Camera", this.matrixWorldInverse = new B, this.projectionMatrix = new B, this.projectionMatrixInverse = new B } function Di(e, t, i, n) { ki.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } function zi(e) { Di.call(this), this.cameras = e || [] } Ci.prototype = Object.create(Oe.prototype), Ci.prototype.constructor = Ci, Ci.prototype.isMeshDepthMaterial = !0, Ci.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this }, Ai.prototype = Object.create(Oe.prototype), Ai.prototype.constructor = Ai, Ai.prototype.isMeshDistanceMaterial = !0, Ai.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this }, Ii.prototype = Object.assign(Object.create(le.prototype), { constructor: Ii, isGroup: !0 }), ki.prototype = Object.assign(Object.create(le.prototype), { constructor: ki, isCamera: !0, copy: function (e, t) { return le.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this }, getWorldDirection: function (e) { void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new h), this.updateMatrixWorld(!0); var t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() }, updateMatrixWorld: function (e) { le.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function () { return (new this.constructor).copy(this) } }), Di.prototype = Object.assign(Object.create(ki.prototype), { constructor: Di, isPerspectiveCamera: !0, copy: function (e, t) { return ki.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this }, setFocalLength: function (e) { var t = .5 * this.getFilmHeight() / e; this.fov = 2 * o.RAD2DEG * Math.atan(t), this.updateProjectionMatrix() }, getFocalLength: function () { var e = Math.tan(.5 * o.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / e }, getEffectiveFOV: function () { return 2 * o.RAD2DEG * Math.atan(Math.tan(.5 * o.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (e, t, i, n, r, a) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var e = this.near, t = e * Math.tan(.5 * o.DEG2RAD * this.fov) / this.zoom, i = 2 * t, n = this.aspect * i, r = -.5 * n, a = this.view; if (null !== this.view && this.view.enabled) { var s = a.fullWidth, l = a.fullHeight; r += a.offsetX * n / s, t -= a.offsetY * i / l, n *= a.width / s, i *= a.height / l } var c = this.filmOffset; 0 !== c && (r += e * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (e) { var t = le.prototype.toJSON.call(this, e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } }), zi.prototype = Object.assign(Object.create(Di.prototype), { constructor: zi, isArrayCamera: !0 }); var Ni, Bi, Fi, Gi, Ui, Hi, Vi = new h, ji = new h; function Wi(e, t, i) { Vi.setFromMatrixPosition(t.matrixWorld), ji.setFromMatrixPosition(i.matrixWorld); var n = Vi.distanceTo(ji), r = t.projectionMatrix.elements, a = i.projectionMatrix.elements, s = r[14] / (r[10] - 1), o = r[14] / (r[10] + 1), l = (r[9] + 1) / r[5], c = (r[9] - 1) / r[5], h = (r[8] - 1) / r[0], u = (a[8] + 1) / a[0], d = s * h, p = s * u, f = n / (-h + u), m = f * -h; t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld); var g = s + f, v = o + f, y = d - m, _ = p + (n - m), x = l * o / v * g, b = c * o / v * g; e.projectionMatrix.makePerspective(y, _, x, b, g, v) } function $i(e) { var t, i, n = this, r = null, a = null, s = null, o = [], u = new B, d = new B, p = 1, f = "local-floor"; "undefined" != typeof window && "VRFrameData" in window && (a = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", M, !1)); var m = new B, g = new c, v = new h, y = new Di; y.viewport = new P, y.layers.enable(1); var _ = new Di; _.viewport = new P, _.layers.enable(2); var x = new zi([y, _]); function b() { return null !== r && !0 === r.isPresenting } x.layers.enable(1), x.layers.enable(2); var w, T = new l; function M() { if (b()) { var a = r.getEyeParameters("left"); t = 2 * a.renderWidth * p, i = a.renderHeight * p, w = e.getPixelRatio(), e.getSize(T), e.setDrawingBufferSize(t, i, 1), y.viewport.set(0, 0, t / 2, i), _.viewport.set(t / 2, 0, t / 2, i), A.start() } else n.enabled && e.setDrawingBufferSize(T.width, T.height, w), A.stop() } var S = []; function E(e) { for (var t = navigator.getGamepads && navigator.getGamepads(), i = 0, n = 0, r = t.length; i < r; i++) { var a = t[i]; if (a && ("Daydream Controller" === a.id || "Gear VR Controller" === a.id || "Oculus Go Controller" === a.id || "OpenVR Gamepad" === a.id || a.id.startsWith("Oculus Touch") || a.id.startsWith("Spatial Controller"))) { if (n === e) return a; n++ } } } function C(e, n) { null !== n && 4 === n.length && e.set(n[0] * t, n[1] * i, n[2] * t, n[3] * i) } this.enabled = !1, this.getController = function (e) { var t = o[e]; return void 0 === t && ((t = new Ii).matrixAutoUpdate = !1, t.visible = !1, o[e] = t), t }, this.getDevice = function () { return r }, this.setDevice = function (e) { void 0 !== e && (r = e), A.setContext(e) }, this.setFramebufferScaleFactor = function (e) { p = e }, this.setReferenceSpaceType = function (e) { f = e }, this.setPoseTarget = function (e) { void 0 !== e && (s = e) }, this.getCamera = function (e) { var t = "local-floor" === f ? 1.6 : 0; if (!1 === b()) return e.position.set(0, t, 0), e.rotation.set(0, 0, 0), e; if (r.depthNear = e.near, r.depthFar = e.far, r.getFrameData(a), "local-floor" === f) { var i = r.stageParameters; i ? u.fromArray(i.sittingToStandingTransform) : u.makeTranslation(0, t, 0) } var n = a.pose, l = null !== s ? s : e; l.matrix.copy(u), l.matrix.decompose(l.position, l.quaternion, l.scale), null !== n.orientation && (g.fromArray(n.orientation), l.quaternion.multiply(g)), null !== n.position && (g.setFromRotationMatrix(u), v.fromArray(n.position), v.applyQuaternion(g), l.position.add(v)), l.updateMatrixWorld(), y.near = e.near, _.near = e.near, y.far = e.far, _.far = e.far, y.matrixWorldInverse.fromArray(a.leftViewMatrix), _.matrixWorldInverse.fromArray(a.rightViewMatrix), d.getInverse(u), "local-floor" === f && (y.matrixWorldInverse.multiply(d), _.matrixWorldInverse.multiply(d)); var c = l.parent; null !== c && (m.getInverse(c.matrixWorld), y.matrixWorldInverse.multiply(m), _.matrixWorldInverse.multiply(m)), y.matrixWorld.getInverse(y.matrixWorldInverse), _.matrixWorld.getInverse(_.matrixWorldInverse), y.projectionMatrix.fromArray(a.leftProjectionMatrix), _.projectionMatrix.fromArray(a.rightProjectionMatrix), Wi(x, y, _); var h = r.getLayers(); if (h.length) { var p = h[0]; C(y.viewport, p.leftBounds), C(_.viewport, p.rightBounds) } return function () { for (var e = 0; e < o.length; e++) { var t = o[e], i = E(e); if (void 0 !== i && void 0 !== i.pose) { if (null === i.pose) return; var n = i.pose; !1 === n.hasPosition && t.position.set(.2, -.6, -.05), null !== n.position && t.position.fromArray(n.position), null !== n.orientation && t.quaternion.fromArray(n.orientation), t.matrix.compose(t.position, t.quaternion, t.scale), t.matrix.premultiply(u), t.matrix.decompose(t.position, t.quaternion, t.scale), t.matrixWorldNeedsUpdate = !0, t.visible = !0; var r = "Daydream Controller" === i.id ? 0 : 1; void 0 === S[e] && (S[e] = !1), S[e] !== i.buttons[r].pressed && (S[e] = i.buttons[r].pressed, !0 === S[e] ? t.dispatchEvent({ type: "selectstart" }) : (t.dispatchEvent({ type: "selectend" }), t.dispatchEvent({ type: "select" }))) } else t.visible = !1 } }(), x }, this.getStandingMatrix = function () { return u }, this.isPresenting = b; var A = new Z; this.setAnimationLoop = function (e) { A.setAnimationLoop(e), b() && A.start() }, this.submitFrame = function () { b() && r.submitFrame() }, this.dispose = function () { "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", M) }, this.setFrameOfReferenceType = function () { console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.") } } function Xi(e) { var t = e.context, i = null, n = null, r = "local-floor", a = null, s = [], o = []; function l() { return null !== i && null !== n } var c = new Di; c.layers.enable(1), c.viewport = new P; var h = new Di; h.layers.enable(2), h.viewport = new P; var u = new zi([c, h]); function d(e) { for (var t = 0; t < s.length; t++)o[t] === e.inputSource && s[t].dispatchEvent({ type: e.type }) } function p() { e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), v.stop() } function f(e) { n = e, v.setContext(i), v.start() } function m(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld) } u.layers.enable(1), u.layers.enable(2), this.enabled = !1, this.getController = function (e) { var t = s[e]; return void 0 === t && ((t = new Ii).matrixAutoUpdate = !1, t.visible = !1, s[e] = t), t }, this.setFramebufferScaleFactor = function (e) { }, this.setReferenceSpaceType = function (e) { r = e }, this.setSession = function (e) { null !== (i = e) && (i.addEventListener("select", d), i.addEventListener("selectstart", d), i.addEventListener("selectend", d), i.addEventListener("end", p), i.updateRenderState({ baseLayer: new XRWebGLLayer(i, t) }), i.requestReferenceSpace(r).then(f), o = i.inputSources, i.addEventListener("inputsourceschange", (function () { o = i.inputSources, console.log(o); for (var e = 0; e < s.length; e++) { s[e].userData.inputSource = o[e] } }))) }, this.getCamera = function (e) { if (l()) { var t = e.parent, i = u.cameras; m(u, t); for (var n = 0; n < i.length; n++)m(i[n], t); e.matrixWorld.copy(u.matrixWorld); for (var r = e.children, a = (n = 0, r.length); n < a; n++)r[n].updateMatrixWorld(!0); return Wi(u, c, h), u } return e }, this.isPresenting = l; var g = null; var v = new Z; v.setAnimationLoop((function (t, r) { if (null !== (a = r.getViewerPose(n))) { var l = a.views, c = i.renderState.baseLayer; e.setFramebuffer(c.framebuffer); for (var h = 0; h < l.length; h++) { var d = l[h], p = c.getViewport(d), f = d.transform.inverse.matrix, m = u.cameras[h]; m.matrix.fromArray(f).getInverse(m.matrix), m.projectionMatrix.fromArray(d.projectionMatrix), m.viewport.set(p.x, p.y, p.width, p.height), 0 === h && u.matrix.copy(m.matrix) } } for (h = 0; h < s.length; h++) { var v = s[h], y = o[h]; if (y) { var _ = r.getPose(y.targetRaySpace, n); if (null !== _) { v.matrix.fromArray(_.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.visible = !0; continue } } v.visible = !1 } g && g(t) })), this.setAnimationLoop = function (e) { g = e }, this.dispose = function () { }, this.getStandingMatrix = function () { return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new B }, this.getDevice = function () { console.warn("THREE.WebXRManager: getDevice() has been deprecated.") }, this.setDevice = function () { console.warn("THREE.WebXRManager: setDevice() has been deprecated.") }, this.setFrameOfReferenceType = function () { console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.") }, this.submitFrame = function () { } } function Yi(e) { console.log("THREE.WebGLRenderer", "105"); var t = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), i = void 0 !== e.context ? e.context : null, n = void 0 !== e.alpha && e.alpha, r = void 0 === e.depth || e.depth, a = void 0 === e.stencil || e.stencil, s = void 0 !== e.antialias && e.antialias, c = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, u = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, d = void 0 !== e.powerPreference ? e.powerPreference : "default", p = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat, f = null, m = null; this.domElement = t, this.context = null, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = 1, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; var g, v, y, _, x, b, w, T, M, S, E, C, A, L, R, O, k, D, z = this, F = !1, U = null, H = 0, V = 0, j = null, W = null, $ = -1, X = { geometry: null, program: null, wireframe: !1 }, Y = null, Q = null, ee = new P, te = new P, ie = null, ne = t.width, re = t.height, ae = 1, se = new P(0, 0, ne, re), oe = new P(0, 0, ne, re), le = !1, ce = new N, he = new Qe, ue = !1, de = !1, pe = new B, fe = new h; function me() { return null === j ? ae : 1 } try { var ge = { alpha: n, depth: r, stencil: a, antialias: s, premultipliedAlpha: c, preserveDrawingBuffer: u, powerPreference: d, failIfMajorPerformanceCaveat: p, xrCompatible: !0 }; if (t.addEventListener("webglcontextlost", xe, !1), t.addEventListener("webglcontextrestored", be, !1), null === (g = i || t.getContext("webgl", ge) || t.getContext("experimental-webgl", ge))) throw null !== t.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context."); void 0 === g.getShaderPrecisionFormat && (g.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e } function ve() { v = new et(g), (y = new Ke(g, v, e)).isWebGL2 || (v.get("WEBGL_depth_texture"), v.get("OES_texture_float"), v.get("OES_texture_half_float"), v.get("OES_texture_half_float_linear"), v.get("OES_standard_derivatives"), v.get("OES_element_index_uint"), v.get("ANGLE_instanced_arrays")), v.get("OES_texture_float_linear"), D = new Oi(g, v, y), (_ = new Li(g, v, D, y)).scissor(te.copy(oe).multiplyScalar(ae)), _.viewport(ee.copy(se).multiplyScalar(ae)), x = new nt(g), b = new vi, w = new Ri(g, v, _, b, y, D, x), T = new K(g), M = new tt(g, T, x), S = new st(M, x), R = new at(g), E = new gi(z, v, y, w), C = new bi, A = new Ei, L = new Je(z, _, S, c), O = new Ze(g, v, x, y), k = new it(g, v, x, y), x.programs = E.programs, z.context = g, z.capabilities = y, z.extensions = v, z.properties = b, z.renderLists = C, z.state = _, z.info = x } ve(); var ye = "undefined" != typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new Xi(z) : new $i(z); this.vr = ye; var _e = new Pi(z, S, y.maxTextureSize); function xe(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), F = !0 } function be() { console.log("THREE.WebGLRenderer: Context Restored."), F = !1, ve() } function we(e) { var t = e.target; t.removeEventListener("dispose", we), function (e) { Te(e), b.remove(e) }(t) } function Te(e) { var t = b.get(e).program; e.program = void 0, void 0 !== t && E.releaseProgram(t) } this.shadowMap = _e, this.getContext = function () { return g }, this.getContextAttributes = function () { return g.getContextAttributes() }, this.forceContextLoss = function () { var e = v.get("WEBGL_lose_context"); e && e.loseContext() }, this.forceContextRestore = function () { var e = v.get("WEBGL_lose_context"); e && e.restoreContext() }, this.getPixelRatio = function () { return ae }, this.setPixelRatio = function (e) { void 0 !== e && (ae = e, this.setSize(ne, re, !1)) }, this.getSize = function (e) { return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new l), e.set(ne, re) }, this.setSize = function (e, i, n) { ye.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (ne = e, re = i, t.width = e * ae, t.height = i * ae, !1 !== n && (t.style.width = e + "px", t.style.height = i + "px"), this.setViewport(0, 0, e, i)) }, this.getDrawingBufferSize = function (e) { return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new l), e.set(ne * ae, re * ae) }, this.setDrawingBufferSize = function (e, i, n) { ne = e, re = i, ae = n, t.width = e * n, t.height = i * n, this.setViewport(0, 0, e, i) }, this.getCurrentViewport = function (e) { return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new P), e.copy(ee) }, this.getViewport = function (e) { return e.copy(se) }, this.setViewport = function (e, t, i, n) { e.isVector4 ? se.set(e.x, e.y, e.z, e.w) : se.set(e, t, i, n), _.viewport(ee.copy(se).multiplyScalar(ae)) }, this.getScissor = function (e) { return e.copy(oe) }, this.setScissor = function (e, t, i, n) { e.isVector4 ? oe.set(e.x, e.y, e.z, e.w) : oe.set(e, t, i, n), _.scissor(te.copy(oe).multiplyScalar(ae)) }, this.getScissorTest = function () { return le }, this.setScissorTest = function (e) { _.setScissorTest(le = e) }, this.getClearColor = function () { return L.getClearColor() }, this.setClearColor = function () { L.setClearColor.apply(L, arguments) }, this.getClearAlpha = function () { return L.getClearAlpha() }, this.setClearAlpha = function () { L.setClearAlpha.apply(L, arguments) }, this.clear = function (e, t, i) { var n = 0; (void 0 === e || e) && (n |= 16384), (void 0 === t || t) && (n |= 256), (void 0 === i || i) && (n |= 1024), g.clear(n) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", xe, !1), t.removeEventListener("webglcontextrestored", be, !1), C.dispose(), A.dispose(), b.dispose(), S.dispose(), ye.dispose(), Se.stop() }, this.renderBufferImmediate = function (e, t) { _.initAttributes(); var i = b.get(e); e.hasPositions && !i.position && (i.position = g.createBuffer()), e.hasNormals && !i.normal && (i.normal = g.createBuffer()), e.hasUvs && !i.uv && (i.uv = g.createBuffer()), e.hasColors && !i.color && (i.color = g.createBuffer()); var n = t.getAttributes(); e.hasPositions && (g.bindBuffer(34962, i.position), g.bufferData(34962, e.positionArray, 35048), _.enableAttribute(n.position), g.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), e.hasNormals && (g.bindBuffer(34962, i.normal), g.bufferData(34962, e.normalArray, 35048), _.enableAttribute(n.normal), g.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (g.bindBuffer(34962, i.uv), g.bufferData(34962, e.uvArray, 35048), _.enableAttribute(n.uv), g.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), e.hasColors && (g.bindBuffer(34962, i.color), g.bufferData(34962, e.colorArray, 35048), _.enableAttribute(n.color), g.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), _.disableUnusedAttributes(), g.drawArrays(4, 0, e.count), e.count = 0 }, this.renderBufferDirect = function (e, t, i, n, r, a) { var s = r.isMesh && r.matrixWorld.determinant() < 0; _.setMaterial(n, s); var o = Le(e, t, n, r), l = !1; X.geometry === i.id && X.program === o.id && X.wireframe === (!0 === n.wireframe) || (X.geometry = i.id, X.program = o.id, X.wireframe = !0 === n.wireframe, l = !0), r.morphTargetInfluences && (R.update(r, i, n, o), l = !0); var c, h = i.index, u = i.attributes.position, d = 1; !0 === n.wireframe && (h = M.getWireframeAttribute(i), d = 2); var p = O; null !== h && (c = T.get(h), (p = k).setIndex(c)), l && (!function (e, t, i) { if (i && i.isInstancedBufferGeometry && !y.isWebGL2 && null === v.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); _.initAttributes(); var n = i.attributes, r = t.getAttributes(), a = e.defaultAttributeValues; for (var s in r) { var o = r[s]; if (o >= 0) { var l = n[s]; if (void 0 !== l) { var c = l.normalized, h = l.itemSize, u = T.get(l); if (void 0 === u) continue; var d = u.buffer, p = u.type, f = u.bytesPerElement; if (l.isInterleavedBufferAttribute) { var m = l.data, x = m.stride, b = l.offset; m && m.isInstancedInterleavedBuffer ? (_.enableAttributeAndDivisor(o, m.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = m.meshPerAttribute * m.count)) : _.enableAttribute(o), g.bindBuffer(34962, d), g.vertexAttribPointer(o, h, p, c, x * f, b * f) } else l.isInstancedBufferAttribute ? (_.enableAttributeAndDivisor(o, l.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = l.meshPerAttribute * l.count)) : _.enableAttribute(o), g.bindBuffer(34962, d), g.vertexAttribPointer(o, h, p, c, 0, 0) } else if (void 0 !== a) { var w = a[s]; if (void 0 !== w) switch (w.length) { case 2: g.vertexAttrib2fv(o, w); break; case 3: g.vertexAttrib3fv(o, w); break; case 4: g.vertexAttrib4fv(o, w); break; default: g.vertexAttrib1fv(o, w) } } } } _.disableUnusedAttributes() }(n, o, i), null !== h && g.bindBuffer(34963, c.buffer)); var f = 1 / 0; null !== h ? f = h.count : void 0 !== u && (f = u.count); var m = i.drawRange.start * d, x = i.drawRange.count * d, b = null !== a ? a.start * d : 0, w = null !== a ? a.count * d : 1 / 0, S = Math.max(m, b), E = Math.min(f, m + x, b + w) - 1, C = Math.max(0, E - S + 1); if (0 !== C) { if (r.isMesh) if (!0 === n.wireframe) _.setLineWidth(n.wireframeLinewidth * me()), p.setMode(1); else switch (r.drawMode) { case 0: p.setMode(4); break; case 1: p.setMode(5); break; case 2: p.setMode(6) } else if (r.isLine) { var A = n.linewidth; void 0 === A && (A = 1), _.setLineWidth(A * me()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3) } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4); i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && p.renderInstances(i, S, C) : p.render(S, C) } }, this.compile = function (e, t) { (m = A.get(e, t)).init(), e.traverse((function (e) { e.isLight && (m.pushLight(e), e.castShadow && m.pushShadow(e)) })), m.setupLights(t), e.traverse((function (t) { if (t.material) if (Array.isArray(t.material)) for (var i = 0; i < t.material.length; i++)Pe(t.material[i], e.fog, t); else Pe(t.material, e.fog, t) })) }; var Me = null; var Se = new Z; function Ee(e, t, i, n) { if (!1 !== e.visible) { if (e.layers.test(t.layers)) if (e.isGroup) i = e.renderOrder; else if (e.isLight) m.pushLight(e), e.castShadow && m.pushShadow(e); else if (e.isSprite) { if (!e.frustumCulled || ce.intersectsSprite(e)) { n && fe.setFromMatrixPosition(e.matrixWorld).applyMatrix4(pe); var r = S.update(e); (a = e.material).visible && f.push(e, r, a, i, fe.z, null) } } else if (e.isImmediateRenderObject) n && fe.setFromMatrixPosition(e.matrixWorld).applyMatrix4(pe), f.push(e, null, e.material, i, fe.z, null); else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || ce.intersectsObject(e))) { n && fe.setFromMatrixPosition(e.matrixWorld).applyMatrix4(pe); r = S.update(e); var a = e.material; if (Array.isArray(a)) for (var s = r.groups, o = 0, l = s.length; o < l; o++) { var c = s[o], h = a[c.materialIndex]; h && h.visible && f.push(e, r, h, i, fe.z, c) } else a.visible && f.push(e, r, a, i, fe.z, null) } var u = e.children; for (o = 0, l = u.length; o < l; o++)Ee(u[o], t, i, n) } } function Ce(e, t, i, n) { for (var r = 0, a = e.length; r < a; r++) { var s = e[r], o = s.object, l = s.geometry, c = void 0 === n ? s.material : n, h = s.group; if (i.isArrayCamera) { Q = i; for (var u = i.cameras, d = 0, p = u.length; d < p; d++) { var f = u[d]; o.layers.test(f.layers) && (_.viewport(ee.copy(f.viewport)), m.setupLights(f), Ae(o, t, f, l, c, h)) } } else Q = null, Ae(o, t, i, l, c, h) } } function Ae(e, t, i, n, r, a) { if (e.onBeforeRender(z, t, i, n, r, a), m = A.get(t, Q || i), e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) { _.setMaterial(r); var s = Le(i, t.fog, r, e); X.geometry = null, X.program = null, X.wireframe = !1, function (e, t) { e.render((function (e) { z.renderBufferImmediate(e, t) })) }(e, s) } else z.renderBufferDirect(i, t.fog, n, r, e, a); e.onAfterRender(z, t, i, n, r, a), m = A.get(t, Q || i) } function Pe(e, t, i) { var n = b.get(e), r = m.state.lights, a = m.state.shadowsArray, s = n.lightsHash, o = r.state.hash, l = E.getParameters(e, r.state, a, t, he.numPlanes, he.numIntersection, i), c = E.getProgramCode(e, l), h = n.program, u = !0; if (void 0 === h) e.addEventListener("dispose", we); else if (h.code !== c) Te(e); else if (s.stateID !== o.stateID || s.directionalLength !== o.directionalLength || s.pointLength !== o.pointLength || s.spotLength !== o.spotLength || s.rectAreaLength !== o.rectAreaLength || s.hemiLength !== o.hemiLength || s.shadowsLength !== o.shadowsLength) s.stateID = o.stateID, s.directionalLength = o.directionalLength, s.pointLength = o.pointLength, s.spotLength = o.spotLength, s.rectAreaLength = o.rectAreaLength, s.hemiLength = o.hemiLength, s.shadowsLength = o.shadowsLength, u = !1; else { if (void 0 !== l.shaderID) return; u = !1 } if (u) { if (l.shaderID) { var d = J[l.shaderID]; n.shader = { name: e.type, uniforms: G(d.uniforms), vertexShader: d.vertexShader, fragmentShader: d.fragmentShader } } else n.shader = { name: e.type, uniforms: e.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader }; e.onBeforeCompile(n.shader, z), c = E.getProgramCode(e, l), h = E.acquireProgram(e, n.shader, l, c), n.program = h, e.program = h } var p = h.getAttributes(); if (e.morphTargets) { e.numSupportedMorphTargets = 0; for (var f = 0; f < z.maxMorphTargets; f++)p["morphTarget" + f] >= 0 && e.numSupportedMorphTargets++ } if (e.morphNormals) { e.numSupportedMorphNormals = 0; for (f = 0; f < z.maxMorphNormals; f++)p["morphNormal" + f] >= 0 && e.numSupportedMorphNormals++ } var g = n.shader.uniforms; (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (n.numClippingPlanes = he.numPlanes, n.numIntersection = he.numIntersection, g.clippingPlanes = he.uniform), n.fog = t, void 0 === s && (n.lightsHash = s = {}), s.stateID = o.stateID, s.directionalLength = o.directionalLength, s.pointLength = o.pointLength, s.spotLength = o.spotLength, s.rectAreaLength = o.rectAreaLength, s.hemiLength = o.hemiLength, s.shadowsLength = o.shadowsLength, e.lights && (g.ambientLightColor.value = r.state.ambient, g.lightProbe.value = r.state.probe, g.directionalLights.value = r.state.directional, g.spotLights.value = r.state.spot, g.rectAreaLights.value = r.state.rectArea, g.pointLights.value = r.state.point, g.hemisphereLights.value = r.state.hemi, g.directionalShadowMap.value = r.state.directionalShadowMap, g.directionalShadowMatrix.value = r.state.directionalShadowMatrix, g.spotShadowMap.value = r.state.spotShadowMap, g.spotShadowMatrix.value = r.state.spotShadowMatrix, g.pointShadowMap.value = r.state.pointShadowMap, g.pointShadowMatrix.value = r.state.pointShadowMatrix); var v = n.program.getUniforms(), y = ni.seqWithValue(v.seq, g); n.uniformsList = y } function Le(e, t, i, n) { w.resetTextureUnits(); var r = b.get(i), a = m.state.lights, s = r.lightsHash, l = a.state.hash; if (ue && (de || e !== Y)) { var c = e === Y && i.id === $; he.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, e, r, c) } !1 === i.needsUpdate && (void 0 === r.program || i.fog && r.fog !== t ? i.needsUpdate = !0 : (!i.lights || s.stateID === l.stateID && s.directionalLength === l.directionalLength && s.pointLength === l.pointLength && s.spotLength === l.spotLength && s.rectAreaLength === l.rectAreaLength && s.hemiLength === l.hemiLength && s.shadowsLength === l.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === he.numPlanes && r.numIntersection === he.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (Pe(i, t, n), i.needsUpdate = !1); var h, u, d = !1, p = !1, f = !1, v = r.program, x = v.getUniforms(), T = r.shader.uniforms; if (_.useProgram(v.program) && (d = !0, p = !0, f = !0), i.id !== $ && ($ = i.id, p = !0), d || Y !== e) { if (x.setValue(g, "projectionMatrix", e.projectionMatrix), y.logarithmicDepthBuffer && x.setValue(g, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), Y !== e && (Y = e, p = !0, f = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) { var M = x.map.cameraPosition; void 0 !== M && M.setValue(g, fe.setFromMatrixPosition(e.matrixWorld)) } (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && x.setValue(g, "viewMatrix", e.matrixWorldInverse) } if (i.skinning) { x.setOptional(g, n, "bindMatrix"), x.setOptional(g, n, "bindMatrixInverse"); var S = n.skeleton; if (S) { var E = S.bones; if (y.floatVertexTextures) { if (void 0 === S.boneTexture) { var C = Math.sqrt(4 * E.length); C = o.ceilPowerOfTwo(C), C = Math.max(C, 4); var A = new Float32Array(C * C * 4); A.set(S.boneMatrices); var P = new I(A, C, C, 1023, 1015); P.needsUpdate = !0, S.boneMatrices = A, S.boneTexture = P, S.boneTextureSize = C } x.setValue(g, "boneTexture", S.boneTexture, w), x.setValue(g, "boneTextureSize", S.boneTextureSize) } else x.setOptional(g, S, "boneMatrices") } } return p && (x.setValue(g, "toneMappingExposure", z.toneMappingExposure), x.setValue(g, "toneMappingWhitePoint", z.toneMappingWhitePoint), i.lights && (u = f, (h = T).ambientLightColor.needsUpdate = u, h.lightProbe.needsUpdate = u, h.directionalLights.needsUpdate = u, h.pointLights.needsUpdate = u, h.spotLights.needsUpdate = u, h.rectAreaLights.needsUpdate = u, h.hemisphereLights.needsUpdate = u), t && i.fog && function (e, t) { e.fogColor.value.copy(t.color), t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density) }(T, t), i.isMeshBasicMaterial ? Re(T, i) : i.isMeshLambertMaterial ? (Re(T, i), function (e, t) { t.emissiveMap && (e.emissiveMap.value = t.emissiveMap) }(T, i)) : i.isMeshPhongMaterial ? (Re(T, i), i.isMeshToonMaterial ? function (e, t) { Oe(e, t), t.gradientMap && (e.gradientMap.value = t.gradientMap) }(T, i) : Oe(T, i)) : i.isMeshStandardMaterial ? (Re(T, i), i.isMeshPhysicalMaterial ? function (e, t) { Ie(e, t), e.reflectivity.value = t.reflectivity, e.clearCoat.value = t.clearCoat, e.clearCoatRoughness.value = t.clearCoatRoughness }(T, i) : Ie(T, i)) : i.isMeshMatcapMaterial ? (Re(T, i), function (e, t) { t.matcap && (e.matcap.value = t.matcap); t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)); t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()); t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(T, i)) : i.isMeshDepthMaterial ? (Re(T, i), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(T, i)) : i.isMeshDistanceMaterial ? (Re(T, i), function (e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias); e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance }(T, i)) : i.isMeshNormalMaterial ? (Re(T, i), function (e, t) { t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)); t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()); t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(T, i)) : i.isLineBasicMaterial ? (function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity }(T, i), i.isLineDashedMaterial && function (e, t) { e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale }(T, i)) : i.isPointsMaterial ? function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * ae, e.scale.value = .5 * re, e.map.value = t.map, null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(), e.uvTransform.value.copy(t.map.matrix)) }(T, i) : i.isSpriteMaterial ? function (e, t) { e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, e.map.value = t.map, null !== t.map && (!0 === t.map.matrixAutoUpdate && t.map.updateMatrix(), e.uvTransform.value.copy(t.map.matrix)) }(T, i) : i.isShadowMaterial && (T.color.value.copy(i.color), T.opacity.value = i.opacity), void 0 !== T.ltc_1 && (T.ltc_1.value = q.LTC_1), void 0 !== T.ltc_2 && (T.ltc_2.value = q.LTC_2), ni.upload(g, r.uniformsList, T, w)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (ni.upload(g, r.uniformsList, T, w), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && x.setValue(g, "center", n.center), x.setValue(g, "modelViewMatrix", n.modelViewMatrix), x.setValue(g, "normalMatrix", n.normalMatrix), x.setValue(g, "modelMatrix", n.matrixWorld), v } function Re(e, t) { var i; e.opacity.value = t.opacity, t.color && e.diffuse.value.copy(t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = b.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? i = t.map : t.specularMap ? i = t.specularMap : t.displacementMap ? i = t.displacementMap : t.normalMap ? i = t.normalMap : t.bumpMap ? i = t.bumpMap : t.roughnessMap ? i = t.roughnessMap : t.metalnessMap ? i = t.metalnessMap : t.alphaMap ? i = t.alphaMap : t.emissiveMap && (i = t.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)) } function Oe(e, t) { e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) } function Ie(e, t) { e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, 1 === t.side && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), 1 === t.side && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity) } Se.setAnimationLoop((function (e) { ye.isPresenting() || Me && Me(e) })), "undefined" != typeof window && Se.setContext(window), this.setAnimationLoop = function (e) { Me = e, ye.setAnimationLoop(e), Se.start() }, this.render = function (e, t) { var i, n; if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), i = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), n = arguments[3]), t && t.isCamera) { if (!F) { X.geometry = null, X.program = null, X.wireframe = !1, $ = -1, Y = null, !0 === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), ye.enabled && (t = ye.getCamera(t)), (m = A.get(e, t)).init(), e.onBeforeRender(z, e, t, i || j), pe.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), ce.setFromMatrix(pe), de = this.localClippingEnabled, ue = he.init(this.clippingPlanes, de, t), (f = C.get(e, t)).init(), Ee(e, t, 0, z.sortObjects), !0 === z.sortObjects && f.sort(), ue && he.beginShadows(); var r = m.state.shadowsArray; _e.render(r, e, t), m.setupLights(t), ue && he.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== i && this.setRenderTarget(i), L.render(f, e, t, n); var a = f.opaque, s = f.transparent; if (e.overrideMaterial) { var o = e.overrideMaterial; a.length && Ce(a, e, t, o), s.length && Ce(s, e, t, o) } else a.length && Ce(a, e, t), s.length && Ce(s, e, t); e.onAfterRender(z, e, t), null !== j && (w.updateRenderTargetMipmap(j), w.updateMultisampleRenderTarget(j)), _.buffers.depth.setTest(!0), _.buffers.depth.setMask(!0), _.buffers.color.setMask(!0), _.setPolygonOffset(!1), ye.enabled && ye.submitFrame(), f = null, m = null } } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.") }, this.setFramebuffer = function (e) { U !== e && g.bindFramebuffer(36160, e), U = e }, this.getActiveCubeFace = function () { return H }, this.getActiveMipMapLevel = function () { return V }, this.getRenderTarget = function () { return j }, this.setRenderTarget = function (e, t, i) { j = e, H = t, V = i, e && void 0 === b.get(e).__webglFramebuffer && w.setupRenderTarget(e); var n = U, r = !1; if (e) { var a = b.get(e).__webglFramebuffer; e.isWebGLRenderTargetCube ? (n = a[t || 0], r = !0) : n = e.isWebGLMultisampleRenderTarget ? b.get(e).__webglMultisampledFramebuffer : a, ee.copy(e.viewport), te.copy(e.scissor), ie = e.scissorTest } else ee.copy(se).multiplyScalar(ae), te.copy(oe).multiplyScalar(ae), ie = le; if (W !== n && (g.bindFramebuffer(36160, n), W = n), _.viewport(ee), _.scissor(te), _.setScissorTest(ie), r) { var s = b.get(e.texture); g.framebufferTexture2D(36160, 36064, 34069 + (t || 0), s.__webglTexture, i || 0) } }, this.readRenderTargetPixels = function (e, t, i, n, r, a, s) { if (e && e.isWebGLRenderTarget) { var o = b.get(e).__webglFramebuffer; if (e.isWebGLRenderTargetCube && void 0 !== s && (o = o[s]), o) { var l = !1; o !== W && (g.bindFramebuffer(36160, o), l = !0); try { var c = e.texture, h = c.format, u = c.type; if (1023 !== h && D.convert(h) !== g.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); if (!(1009 === u || D.convert(u) === g.getParameter(35738) || 1015 === u && (y.isWebGL2 || v.get("OES_texture_float") || v.get("WEBGL_color_buffer_float")) || 1016 === u && (y.isWebGL2 ? v.get("EXT_color_buffer_float") : v.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); 36053 === g.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - n && i >= 0 && i <= e.height - r && g.readPixels(t, i, n, r, D.convert(h), D.convert(u), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { l && g.bindFramebuffer(36160, W) } } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") }, this.copyFramebufferToTexture = function (e, t, i) { var n = t.image.width, r = t.image.height, a = D.convert(t.format); w.setTexture2D(t, 0), g.copyTexImage2D(3553, i || 0, a, e.x, e.y, n, r, 0) }, this.copyTextureToTexture = function (e, t, i, n) { var r = t.image.width, a = t.image.height, s = D.convert(i.format), o = D.convert(i.type); w.setTexture2D(i, 0), t.isDataTexture ? g.texSubImage2D(3553, n || 0, e.x, e.y, r, a, s, o, t.image.data) : g.texSubImage2D(3553, n || 0, e.x, e.y, s, o, t.image) } } function qi(e, t) { this.name = "", this.color = new X(e), this.density = void 0 !== t ? t : 25e-5 } function Ji(e, t, i) { this.name = "", this.color = new X(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3 } function Zi() { le.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0 } function Ki(e, t) { this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function Qi(e, t, i, n) { this.data = e, this.itemSize = t, this.offset = i, this.normalized = !0 === n } function en(e) { Oe.call(this), this.type = "SpriteMaterial", this.color = new X(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(e) } function tn(e) { if (le.call(this), this.type = "Sprite", void 0 === Ni) { Ni = new Ee; var t = new Ki(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5); Ni.setIndex([0, 1, 2, 0, 2, 3]), Ni.addAttribute("position", new Qi(t, 3, 0, !1)), Ni.addAttribute("uv", new Qi(t, 2, 3, !1)) } this.geometry = Ni, this.material = void 0 !== e ? e : new en, this.center = new l(.5, .5) } function nn() { le.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }) } function rn(e, t) { e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), qe.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new B, this.bindMatrixInverse = new B } function an(e, t) { if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses(); else if (this.bones.length === t.length) this.boneInverses = t.slice(0); else { console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = []; for (var i = 0, n = this.bones.length; i < n; i++)this.boneInverses.push(new B) } } function sn() { le.call(this), this.type = "Bone" } function on(e) { Oe.call(this), this.type = "LineBasicMaterial", this.color = new X(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(e) } function ln(e, t, i) { 1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), le.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new Ee, this.material = void 0 !== t ? t : new on({ color: 16777215 * Math.random() }) } function cn(e, t) { ln.call(this, e, t), this.type = "LineSegments" } function hn(e, t) { ln.call(this, e, t), this.type = "LineLoop" } function un(e) { Oe.call(this), this.type = "PointsMaterial", this.color = new X(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(e) } function dn(e, t) { le.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new Ee, this.material = void 0 !== t ? t : new un({ color: 16777215 * Math.random() }) } function pn(e, t, i, n, r, a, s, o, l) { A.call(this, e, t, i, n, r, a, s, o, l), this.format = void 0 !== s ? s : 1022, this.minFilter = void 0 !== a ? a : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1 } function fn(e, t, i, n, r, a, s, o, l, c, h, u) { A.call(this, null, a, s, o, l, c, n, r, h, u), this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 } function mn(e, t, i, n, r, a, s, o, l) { A.call(this, e, t, i, n, r, a, s, o, l), this.needsUpdate = !0 } function gn(e, t, i, n, r, a, s, o, l, c) { if (1026 !== (c = void 0 !== c ? c : 1026) && 1027 !== c) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === i && 1026 === c && (i = 1012), void 0 === i && 1027 === c && (i = 1020), A.call(this, null, n, r, a, s, o, c, i, l), this.image = { width: e, height: t }, this.magFilter = void 0 !== s ? s : 1003, this.minFilter = void 0 !== o ? o : 1003, this.flipY = !1, this.generateMipmaps = !1 } function vn(e) { Ee.call(this), this.type = "WireframeGeometry"; var t, i, n, r, a, s, o, l, c, u, d = [], p = [0, 0], f = {}, m = ["a", "b", "c"]; if (e && e.isGeometry) { var g = e.faces; for (t = 0, n = g.length; t < n; t++) { var v = g[t]; for (i = 0; i < 3; i++)o = v[m[i]], l = v[m[(i + 1) % 3]], p[0] = Math.min(o, l), p[1] = Math.max(o, l), void 0 === f[c = p[0] + "," + p[1]] && (f[c] = { index1: p[0], index2: p[1] }) } for (c in f) s = f[c], u = e.vertices[s.index1], d.push(u.x, u.y, u.z), u = e.vertices[s.index2], d.push(u.x, u.y, u.z) } else if (e && e.isBufferGeometry) { var y, _, x, b, w, T, M; if (u = new h, null !== e.index) { for (y = e.attributes.position, _ = e.index, 0 === (x = e.groups).length && (x = [{ start: 0, count: _.count, materialIndex: 0 }]), r = 0, a = x.length; r < a; ++r)for (t = w = (b = x[r]).start, n = w + b.count; t < n; t += 3)for (i = 0; i < 3; i++)o = _.getX(t + i), l = _.getX(t + (i + 1) % 3), p[0] = Math.min(o, l), p[1] = Math.max(o, l), void 0 === f[c = p[0] + "," + p[1]] && (f[c] = { index1: p[0], index2: p[1] }); for (c in f) s = f[c], u.fromBufferAttribute(y, s.index1), d.push(u.x, u.y, u.z), u.fromBufferAttribute(y, s.index2), d.push(u.x, u.y, u.z) } else for (t = 0, n = (y = e.attributes.position).count / 3; t < n; t++)for (i = 0; i < 3; i++)T = 3 * t + i, u.fromBufferAttribute(y, T), d.push(u.x, u.y, u.z), M = 3 * t + (i + 1) % 3, u.fromBufferAttribute(y, M), d.push(u.x, u.y, u.z) } this.addAttribute("position", new be(d, 3)) } function yn(e, t, i) { de.call(this), this.type = "ParametricGeometry", this.parameters = { func: e, slices: t, stacks: i }, this.fromBufferGeometry(new _n(e, t, i)), this.mergeVertices() } function _n(e, t, i) { Ee.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: e, slices: t, stacks: i }; var n, r, a = [], s = [], o = [], l = [], c = 1e-5, u = new h, d = new h, p = new h, f = new h, m = new h; e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); var g = t + 1; for (n = 0; n <= i; n++) { var v = n / i; for (r = 0; r <= t; r++) { var y = r / t; e(y, v, d), s.push(d.x, d.y, d.z), y - c >= 0 ? (e(y - c, v, p), f.subVectors(d, p)) : (e(y + c, v, p), f.subVectors(p, d)), v - c >= 0 ? (e(y, v - c, p), m.subVectors(d, p)) : (e(y, v + c, p), m.subVectors(p, d)), u.crossVectors(f, m).normalize(), o.push(u.x, u.y, u.z), l.push(y, v) } } for (n = 0; n < i; n++)for (r = 0; r < t; r++) { var _ = n * g + r, x = n * g + r + 1, b = (n + 1) * g + r + 1, w = (n + 1) * g + r; a.push(_, x, w), a.push(x, b, w) } this.setIndex(a), this.addAttribute("position", new be(s, 3)), this.addAttribute("normal", new be(o, 3)), this.addAttribute("uv", new be(l, 2)) } function xn(e, t, i, n) { de.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: i, detail: n }, this.fromBufferGeometry(new bn(e, t, i, n)), this.mergeVertices() } function bn(e, t, i, n) { Ee.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: e, indices: t, radius: i, detail: n }, i = i || 1; var r = [], a = []; function s(e, t, i, n) { var r, a, s = Math.pow(2, n), l = []; for (r = 0; r <= s; r++) { l[r] = []; var c = e.clone().lerp(i, r / s), h = t.clone().lerp(i, r / s), u = s - r; for (a = 0; a <= u; a++)l[r][a] = 0 === a && r === s ? c : c.clone().lerp(h, a / u) } for (r = 0; r < s; r++)for (a = 0; a < 2 * (s - r) - 1; a++) { var d = Math.floor(a / 2); a % 2 == 0 ? (o(l[r][d + 1]), o(l[r + 1][d]), o(l[r][d])) : (o(l[r][d + 1]), o(l[r + 1][d + 1]), o(l[r + 1][d])) } } function o(e) { r.push(e.x, e.y, e.z) } function c(t, i) { var n = 3 * t; i.x = e[n + 0], i.y = e[n + 1], i.z = e[n + 2] } function u(e, t, i, n) { n < 0 && 1 === e.x && (a[t] = e.x - 1), 0 === i.x && 0 === i.z && (a[t] = n / 2 / Math.PI + .5) } function d(e) { return Math.atan2(e.z, -e.x) } function p(e) { return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) } !function (e) { for (var i = new h, n = new h, r = new h, a = 0; a < t.length; a += 3)c(t[a + 0], i), c(t[a + 1], n), c(t[a + 2], r), s(i, n, r, e) }(n = n || 0), function (e) { for (var t = new h, i = 0; i < r.length; i += 3)t.x = r[i + 0], t.y = r[i + 1], t.z = r[i + 2], t.normalize().multiplyScalar(e), r[i + 0] = t.x, r[i + 1] = t.y, r[i + 2] = t.z }(i), function () { for (var e = new h, t = 0; t < r.length; t += 3) { e.x = r[t + 0], e.y = r[t + 1], e.z = r[t + 2]; var i = d(e) / 2 / Math.PI + .5, n = p(e) / Math.PI + .5; a.push(i, 1 - n) } (function () { for (var e = new h, t = new h, i = new h, n = new h, s = new l, o = new l, c = new l, p = 0, f = 0; p < r.length; p += 9, f += 6) { e.set(r[p + 0], r[p + 1], r[p + 2]), t.set(r[p + 3], r[p + 4], r[p + 5]), i.set(r[p + 6], r[p + 7], r[p + 8]), s.set(a[f + 0], a[f + 1]), o.set(a[f + 2], a[f + 3]), c.set(a[f + 4], a[f + 5]), n.copy(e).add(t).add(i).divideScalar(3); var m = d(n); u(s, f + 0, e, m), u(o, f + 2, t, m), u(c, f + 4, i, m) } })(), function () { for (var e = 0; e < a.length; e += 6) { var t = a[e + 0], i = a[e + 2], n = a[e + 4], r = Math.max(t, i, n), s = Math.min(t, i, n); r > .9 && s < .1 && (t < .2 && (a[e + 0] += 1), i < .2 && (a[e + 2] += 1), n < .2 && (a[e + 4] += 1)) } }() }(), this.addAttribute("position", new be(r, 3)), this.addAttribute("normal", new be(r.slice(), 3)), this.addAttribute("uv", new be(a, 2)), 0 === n ? this.computeVertexNormals() : this.normalizeNormals() } function wn(e, t) { de.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new Tn(e, t)), this.mergeVertices() } function Tn(e, t) { bn.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: e, detail: t } } function Mn(e, t) { de.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new Sn(e, t)), this.mergeVertices() } function Sn(e, t) { bn.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = { radius: e, detail: t } } function En(e, t) { de.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new Cn(e, t)), this.mergeVertices() } function Cn(e, t) { var i = (1 + Math.sqrt(5)) / 2, n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1]; bn.call(this, n, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: e, detail: t } } function An(e, t) { de.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new Pn(e, t)), this.mergeVertices() } function Pn(e, t) { var i = (1 + Math.sqrt(5)) / 2, n = 1 / i, r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n]; bn.call(this, r, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: e, detail: t } } function Ln(e, t, i, n, r, a) { de.call(this), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: i, radialSegments: n, closed: r }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed."); var s = new Rn(e, t, i, n, r); this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals, this.fromBufferGeometry(s), this.mergeVertices() } function Rn(e, t, i, n, r) { Ee.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: e, tubularSegments: t, radius: i, radialSegments: n, closed: r }, t = t || 64, i = i || 1, n = n || 8, r = r || !1; var a = e.computeFrenetFrames(t, r); this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals; var s, o, c = new h, u = new h, d = new l, p = new h, f = [], m = [], g = [], v = []; function y(r) { p = e.getPointAt(r / t, p); var s = a.normals[r], l = a.binormals[r]; for (o = 0; o <= n; o++) { var h = o / n * Math.PI * 2, d = Math.sin(h), g = -Math.cos(h); u.x = g * s.x + d * l.x, u.y = g * s.y + d * l.y, u.z = g * s.z + d * l.z, u.normalize(), m.push(u.x, u.y, u.z), c.x = p.x + i * u.x, c.y = p.y + i * u.y, c.z = p.z + i * u.z, f.push(c.x, c.y, c.z) } } !function () { for (s = 0; s < t; s++)y(s); y(!1 === r ? t : 0), function () { for (s = 0; s <= t; s++)for (o = 0; o <= n; o++)d.x = s / t, d.y = o / n, g.push(d.x, d.y) }(), function () { for (o = 1; o <= t; o++)for (s = 1; s <= n; s++) { var e = (n + 1) * (o - 1) + (s - 1), i = (n + 1) * o + (s - 1), r = (n + 1) * o + s, a = (n + 1) * (o - 1) + s; v.push(e, i, a), v.push(i, r, a) } }() }(), this.setIndex(v), this.addAttribute("position", new be(f, 3)), this.addAttribute("normal", new be(m, 3)), this.addAttribute("uv", new be(g, 2)) } function On(e, t, i, n, r, a, s) { de.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: i, radialSegments: n, p: r, q: a }, void 0 !== s && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new In(e, t, i, n, r, a)), this.mergeVertices() } function In(e, t, i, n, r, a) { Ee.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: e, tube: t, tubularSegments: i, radialSegments: n, p: r, q: a }, e = e || 1, t = t || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, a = a || 3; var s, o, l = [], c = [], u = [], d = [], p = new h, f = new h, m = new h, g = new h, v = new h, y = new h, _ = new h; for (s = 0; s <= i; ++s) { var x = s / i * r * Math.PI * 2; for (A(x, r, a, e, m), A(x + .01, r, a, e, g), y.subVectors(g, m), _.addVectors(g, m), v.crossVectors(y, _), _.crossVectors(v, y), v.normalize(), _.normalize(), o = 0; o <= n; ++o) { var b = o / n * Math.PI * 2, w = -t * Math.cos(b), T = t * Math.sin(b); p.x = m.x + (w * _.x + T * v.x), p.y = m.y + (w * _.y + T * v.y), p.z = m.z + (w * _.z + T * v.z), c.push(p.x, p.y, p.z), f.subVectors(p, m).normalize(), u.push(f.x, f.y, f.z), d.push(s / i), d.push(o / n) } } for (o = 1; o <= i; o++)for (s = 1; s <= n; s++) { var M = (n + 1) * (o - 1) + (s - 1), S = (n + 1) * o + (s - 1), E = (n + 1) * o + s, C = (n + 1) * (o - 1) + s; l.push(M, S, C), l.push(S, E, C) } function A(e, t, i, n, r) { var a = Math.cos(e), s = Math.sin(e), o = i / t * e, l = Math.cos(o); r.x = n * (2 + l) * .5 * a, r.y = n * (2 + l) * s * .5, r.z = n * Math.sin(o) * .5 } this.setIndex(l), this.addAttribute("position", new be(c, 3)), this.addAttribute("normal", new be(u, 3)), this.addAttribute("uv", new be(d, 2)) } function kn(e, t, i, n, r) { de.call(this), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: n, arc: r }, this.fromBufferGeometry(new Dn(e, t, i, n, r)), this.mergeVertices() } function Dn(e, t, i, n, r) { Ee.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: n, arc: r }, e = e || 1, t = t || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI; var a, s, o = [], l = [], c = [], u = [], d = new h, p = new h, f = new h; for (a = 0; a <= i; a++)for (s = 0; s <= n; s++) { var m = s / n * r, g = a / i * Math.PI * 2; p.x = (e + t * Math.cos(g)) * Math.cos(m), p.y = (e + t * Math.cos(g)) * Math.sin(m), p.z = t * Math.sin(g), l.push(p.x, p.y, p.z), d.x = e * Math.cos(m), d.y = e * Math.sin(m), f.subVectors(p, d).normalize(), c.push(f.x, f.y, f.z), u.push(s / n), u.push(a / i) } for (a = 1; a <= i; a++)for (s = 1; s <= n; s++) { var v = (n + 1) * a + s - 1, y = (n + 1) * (a - 1) + s - 1, _ = (n + 1) * (a - 1) + s, x = (n + 1) * a + s; o.push(v, y, x), o.push(y, _, x) } this.setIndex(o), this.addAttribute("position", new be(l, 3)), this.addAttribute("normal", new be(c, 3)), this.addAttribute("uv", new be(u, 2)) } Object.assign(qi.prototype, { isFogExp2: !0, clone: function () { return new qi(this.color, this.density) }, toJSON: function () { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } }), Object.assign(Ji.prototype, { isFog: !0, clone: function () { return new Ji(this.color, this.near, this.far) }, toJSON: function () { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } }), Zi.prototype = Object.assign(Object.create(le.prototype), { constructor: Zi, isScene: !0, copy: function (e, t) { return le.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this }, toJSON: function (e) { var t = le.prototype.toJSON.call(this, e); return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(Ki.prototype, "needsUpdate", { set: function (e) { !0 === e && this.version++ } }), Object.assign(Ki.prototype, { isInterleavedBuffer: !0, onUploadCallback: function () { }, setArray: function (e) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); return this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this }, setDynamic: function (e) { return this.dynamic = e, this }, copy: function (e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this }, copyAt: function (e, t, i) { e *= this.stride, i *= t.stride; for (var n = 0, r = this.stride; n < r; n++)this.array[e + n] = t.array[i + n]; return this }, set: function (e, t) { return void 0 === t && (t = 0), this.array.set(e, t), this }, clone: function () { return (new this.constructor).copy(this) }, onUpload: function (e) { return this.onUploadCallback = e, this } }), Object.defineProperties(Qi.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } } }), Object.assign(Qi.prototype, { isInterleavedBufferAttribute: !0, setX: function (e, t) { return this.data.array[e * this.data.stride + this.offset] = t, this }, setY: function (e, t) { return this.data.array[e * this.data.stride + this.offset + 1] = t, this }, setZ: function (e, t) { return this.data.array[e * this.data.stride + this.offset + 2] = t, this }, setW: function (e, t) { return this.data.array[e * this.data.stride + this.offset + 3] = t, this }, getX: function (e) { return this.data.array[e * this.data.stride + this.offset] }, getY: function (e) { return this.data.array[e * this.data.stride + this.offset + 1] }, getZ: function (e) { return this.data.array[e * this.data.stride + this.offset + 2] }, getW: function (e) { return this.data.array[e * this.data.stride + this.offset + 3] }, setXY: function (e, t, i) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this }, setXYZ: function (e, t, i, n) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this }, setXYZW: function (e, t, i, n, r) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this } }), en.prototype = Object.create(Oe.prototype), en.prototype.constructor = en, en.prototype.isSpriteMaterial = !0, en.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this }, tn.prototype = Object.assign(Object.create(le.prototype), { constructor: tn, isSprite: !0, raycast: function () { var e = new h, t = new h, i = new h, n = new l, r = new l, a = new B, s = new h, o = new h, c = new h, u = new l, d = new l, p = new l; function f(e, t, i, s, o, l) { n.subVectors(e, i).addScalar(.5).multiply(s), void 0 !== o ? (r.x = l * n.x - o * n.y, r.y = o * n.x + l * n.y) : r.copy(n), e.copy(t), e.x += r.x, e.y += r.y, e.applyMatrix4(a) } return function (n, r) { t.setFromMatrixScale(this.matrixWorld), a.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), i.setFromMatrixPosition(this.modelViewMatrix); var h, m, g = this.material.rotation; 0 !== g && (m = Math.cos(g), h = Math.sin(g)); var v = this.center; f(s.set(-.5, -.5, 0), i, v, t, h, m), f(o.set(.5, -.5, 0), i, v, t, h, m), f(c.set(.5, .5, 0), i, v, t, h, m), u.set(0, 0), d.set(1, 0), p.set(1, 1); var y = n.ray.intersectTriangle(s, o, c, !1, e); if (null !== y || (f(o.set(-.5, .5, 0), i, v, t, h, m), d.set(0, 1), null !== (y = n.ray.intersectTriangle(s, c, o, !1, e)))) { var _ = n.ray.origin.distanceTo(e); _ < n.near || _ > n.far || r.push({ distance: _, point: e.clone(), uv: Xe.getUV(e, s, o, c, u, d, p, new l), face: null, object: this }) } } }(), clone: function () { return new this.constructor(this.material).copy(this) }, copy: function (e) { return le.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this } }), nn.prototype = Object.assign(Object.create(le.prototype), { constructor: nn, isLOD: !0, copy: function (e) { le.prototype.copy.call(this, e, !1); for (var t = e.levels, i = 0, n = t.length; i < n; i++) { var r = t[i]; this.addLevel(r.object.clone(), r.distance) } return this }, addLevel: function (e, t) { void 0 === t && (t = 0), t = Math.abs(t); for (var i = this.levels, n = 0; n < i.length && !(t < i[n].distance); n++); return i.splice(n, 0, { distance: t, object: e }), this.add(e), this }, getObjectForDistance: function (e) { for (var t = this.levels, i = 1, n = t.length; i < n && !(e < t[i].distance); i++); return t[i - 1].object }, raycast: (Bi = new h, function (e, t) { Bi.setFromMatrixPosition(this.matrixWorld); var i = e.ray.origin.distanceTo(Bi); this.getObjectForDistance(i).raycast(e, t) }), update: function () { var e = new h, t = new h; return function (i) { var n = this.levels; if (n.length > 1) { e.setFromMatrixPosition(i.matrixWorld), t.setFromMatrixPosition(this.matrixWorld); var r = e.distanceTo(t); n[0].object.visible = !0; for (var a = 1, s = n.length; a < s && r >= n[a].distance; a++)n[a - 1].object.visible = !1, n[a].object.visible = !0; for (; a < s; a++)n[a].object.visible = !1 } } }(), toJSON: function (e) { var t = le.prototype.toJSON.call(this, e); t.object.levels = []; for (var i = this.levels, n = 0, r = i.length; n < r; n++) { var a = i[n]; t.object.levels.push({ object: a.object.uuid, distance: a.distance }) } return t } }), rn.prototype = Object.assign(Object.create(qe.prototype), { constructor: rn, isSkinnedMesh: !0, bind: function (e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { for (var e = new P, t = this.geometry.attributes.skinWeight, i = 0, n = t.count; i < n; i++) { e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.w = t.getW(i); var r = 1 / e.manhattanLength(); r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w) } }, updateMatrixWorld: function (e) { qe.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), Object.assign(an.prototype, { calculateInverses: function () { this.boneInverses = []; for (var e = 0, t = this.bones.length; e < t; e++) { var i = new B; this.bones[e] && i.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(i) } }, pose: function () { var e, t, i; for (t = 0, i = this.bones.length; t < i; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]); for (t = 0, i = this.bones.length; t < i; t++)(e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale)) }, update: (Fi = new B, Gi = new B, function () { for (var e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture, r = 0, a = e.length; r < a; r++) { var s = e[r] ? e[r].matrixWorld : Gi; Fi.multiplyMatrices(s, t[r]), Fi.toArray(i, 16 * r) } void 0 !== n && (n.needsUpdate = !0) }), clone: function () { return new an(this.bones, this.boneInverses) }, getBoneByName: function (e) { for (var t = 0, i = this.bones.length; t < i; t++) { var n = this.bones[t]; if (n.name === e) return n } } }), sn.prototype = Object.assign(Object.create(le.prototype), { constructor: sn, isBone: !0 }), on.prototype = Object.create(Oe.prototype), on.prototype.constructor = on, on.prototype.isLineBasicMaterial = !0, on.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this }, ln.prototype = Object.assign(Object.create(le.prototype), { constructor: ln, isLine: !0, computeLineDistances: (Ui = new h, Hi = new h, function () { var e = this.geometry; if (e.isBufferGeometry) if (null === e.index) { for (var t = e.attributes.position, i = [0], n = 1, r = t.count; n < r; n++)Ui.fromBufferAttribute(t, n - 1), Hi.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += Ui.distanceTo(Hi); e.addAttribute("lineDistance", new be(i, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (e.isGeometry) { var a = e.vertices; for ((i = e.lineDistances)[0] = 0, n = 1, r = a.length; n < r; n++)i[n] = i[n - 1], i[n] += a[n - 1].distanceTo(a[n]) } return this }), raycast: function () { var e = new B, t = new $e, i = new D; return function (n, r) { var a = n.linePrecision, s = this.geometry, o = this.matrixWorld; if (null === s.boundingSphere && s.computeBoundingSphere(), i.copy(s.boundingSphere), i.applyMatrix4(o), i.radius += a, !1 !== n.ray.intersectsSphere(i)) { e.getInverse(o), t.copy(n.ray).applyMatrix4(e); var l = a / ((this.scale.x + this.scale.y + this.scale.z) / 3), c = l * l, u = new h, d = new h, p = new h, f = new h, m = this && this.isLineSegments ? 2 : 1; if (s.isBufferGeometry) { var g = s.index, v = s.attributes.position.array; if (null !== g) for (var y = g.array, _ = 0, x = y.length - 1; _ < x; _ += m) { var b = y[_], w = y[_ + 1]; if (u.fromArray(v, 3 * b), d.fromArray(v, 3 * w), !(t.distanceSqToSegment(u, d, f, p) > c)) f.applyMatrix4(this.matrixWorld), (S = n.ray.origin.distanceTo(f)) < n.near || S > n.far || r.push({ distance: S, point: p.clone().applyMatrix4(this.matrixWorld), index: _, face: null, faceIndex: null, object: this }) } else for (_ = 0, x = v.length / 3 - 1; _ < x; _ += m) { if (u.fromArray(v, 3 * _), d.fromArray(v, 3 * _ + 3), !(t.distanceSqToSegment(u, d, f, p) > c)) f.applyMatrix4(this.matrixWorld), (S = n.ray.origin.distanceTo(f)) < n.near || S > n.far || r.push({ distance: S, point: p.clone().applyMatrix4(this.matrixWorld), index: _, face: null, faceIndex: null, object: this }) } } else if (s.isGeometry) { var T = s.vertices, M = T.length; for (_ = 0; _ < M - 1; _ += m) { var S; if (!(t.distanceSqToSegment(T[_], T[_ + 1], f, p) > c)) f.applyMatrix4(this.matrixWorld), (S = n.ray.origin.distanceTo(f)) < n.near || S > n.far || r.push({ distance: S, point: p.clone().applyMatrix4(this.matrixWorld), index: _, face: null, faceIndex: null, object: this }) } } } } }(), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), cn.prototype = Object.assign(Object.create(ln.prototype), { constructor: cn, isLineSegments: !0, computeLineDistances: function () { var e = new h, t = new h; return function () { var i = this.geometry; if (i.isBufferGeometry) if (null === i.index) { for (var n = i.attributes.position, r = [], a = 0, s = n.count; a < s; a += 2)e.fromBufferAttribute(n, a), t.fromBufferAttribute(n, a + 1), r[a] = 0 === a ? 0 : r[a - 1], r[a + 1] = r[a] + e.distanceTo(t); i.addAttribute("lineDistance", new be(r, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (i.isGeometry) { var o = i.vertices; for (r = i.lineDistances, a = 0, s = o.length; a < s; a += 2)e.copy(o[a]), t.copy(o[a + 1]), r[a] = 0 === a ? 0 : r[a - 1], r[a + 1] = r[a] + e.distanceTo(t) } return this } }() }), hn.prototype = Object.assign(Object.create(ln.prototype), { constructor: hn, isLineLoop: !0 }), un.prototype = Object.create(Oe.prototype), un.prototype.constructor = un, un.prototype.isPointsMaterial = !0, un.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this }, dn.prototype = Object.assign(Object.create(le.prototype), { constructor: dn, isPoints: !0, raycast: function () { var e = new B, t = new $e, i = new D; return function (n, r) { var a = this, s = this.geometry, o = this.matrixWorld, l = n.params.Points.threshold; if (null === s.boundingSphere && s.computeBoundingSphere(), i.copy(s.boundingSphere), i.applyMatrix4(o), i.radius += l, !1 !== n.ray.intersectsSphere(i)) { e.getInverse(o), t.copy(n.ray).applyMatrix4(e); var c = l / ((this.scale.x + this.scale.y + this.scale.z) / 3), u = c * c, d = new h, p = new h; if (s.isBufferGeometry) { var f = s.index, m = s.attributes.position.array; if (null !== f) for (var g = f.array, v = 0, y = g.length; v < y; v++) { var _ = g[v]; d.fromArray(m, 3 * _), w(d, _) } else { v = 0; for (var x = m.length / 3; v < x; v++)d.fromArray(m, 3 * v), w(d, v) } } else { var b = s.vertices; for (v = 0, x = b.length; v < x; v++)w(b[v], v) } } function w(e, i) { var s = t.distanceSqToPoint(e); if (s < u) { t.closestPointToPoint(e, p), p.applyMatrix4(o); var l = n.ray.origin.distanceTo(p); if (l < n.near || l > n.far) return; r.push({ distance: l, distanceToRay: Math.sqrt(s), point: p.clone(), index: i, face: null, object: a }) } } } }(), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), pn.prototype = Object.assign(Object.create(A.prototype), { constructor: pn, isVideoTexture: !0, update: function () { var e = this.image; e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }), fn.prototype = Object.create(A.prototype), fn.prototype.constructor = fn, fn.prototype.isCompressedTexture = !0, mn.prototype = Object.create(A.prototype), mn.prototype.constructor = mn, mn.prototype.isCanvasTexture = !0, gn.prototype = Object.create(A.prototype), gn.prototype.constructor = gn, gn.prototype.isDepthTexture = !0, vn.prototype = Object.create(Ee.prototype), vn.prototype.constructor = vn, yn.prototype = Object.create(de.prototype), yn.prototype.constructor = yn, _n.prototype = Object.create(Ee.prototype), _n.prototype.constructor = _n, xn.prototype = Object.create(de.prototype), xn.prototype.constructor = xn, bn.prototype = Object.create(Ee.prototype), bn.prototype.constructor = bn, wn.prototype = Object.create(de.prototype), wn.prototype.constructor = wn, Tn.prototype = Object.create(bn.prototype), Tn.prototype.constructor = Tn, Mn.prototype = Object.create(de.prototype), Mn.prototype.constructor = Mn, Sn.prototype = Object.create(bn.prototype), Sn.prototype.constructor = Sn, En.prototype = Object.create(de.prototype), En.prototype.constructor = En, Cn.prototype = Object.create(bn.prototype), Cn.prototype.constructor = Cn, An.prototype = Object.create(de.prototype), An.prototype.constructor = An, Pn.prototype = Object.create(bn.prototype), Pn.prototype.constructor = Pn, Ln.prototype = Object.create(de.prototype), Ln.prototype.constructor = Ln, Rn.prototype = Object.create(Ee.prototype), Rn.prototype.constructor = Rn, Rn.prototype.toJSON = function () { var e = Ee.prototype.toJSON.call(this); return e.path = this.parameters.path.toJSON(), e }, On.prototype = Object.create(de.prototype), On.prototype.constructor = On, In.prototype = Object.create(Ee.prototype), In.prototype.constructor = In, kn.prototype = Object.create(de.prototype), kn.prototype.constructor = kn, Dn.prototype = Object.create(Ee.prototype), Dn.prototype.constructor = Dn; var zn = function (e, t, i) { i = i || 2; var n, r, a, s, o, l, c, h = t && t.length, u = h ? t[0] * i : e.length, d = Nn(e, 0, u, i, !0), p = []; if (!d) return p; if (h && (d = function (e, t, i, n) { var r, a, s, o, l, c = []; for (r = 0, a = t.length; r < a; r++)s = t[r] * n, o = r < a - 1 ? t[r + 1] * n : e.length, (l = Nn(e, s, o, n, !1)) === l.next && (l.steiner = !0), c.push(Xn(l)); for (c.sort(jn), r = 0; r < c.length; r++)Wn(c[r], i), i = Bn(i, i.next); return i }(e, t, d, i)), e.length > 80 * i) { n = a = e[0], r = s = e[1]; for (var f = i; f < u; f += i)(o = e[f]) < n && (n = o), (l = e[f + 1]) < r && (r = l), o > a && (a = o), l > s && (s = l); c = 0 !== (c = Math.max(a - n, s - r)) ? 1 / c : 0 } return Fn(d, p, i, n, r, c), p }; function Nn(e, t, i, n, r) { var a, s; if (r === function (e, t, i, n) { for (var r = 0, a = t, s = i - n; a < i; a += n)r += (e[s] - e[a]) * (e[a + 1] + e[s + 1]), s = a; return r }(e, t, i, n) > 0) for (a = t; a < i; a += n)s = tr(a, e[a], e[a + 1], s); else for (a = i - n; a >= t; a -= n)s = tr(a, e[a], e[a + 1], s); return s && Zn(s, s.next) && (ir(s), s = s.next), s } function Bn(e, t) { if (!e) return e; t || (t = e); var i, n = e; do { if (i = !1, n.steiner || !Zn(n, n.next) && 0 !== Jn(n.prev, n, n.next)) n = n.next; else { if (ir(n), (n = t = n.prev) === n.next) break; i = !0 } } while (i || n !== t); return t } function Fn(e, t, i, n, r, a, s) { if (e) { !s && a && function (e, t, i, n) { var r = e; do { null === r.z && (r.z = $n(r.x, r.y, t, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next } while (r !== e); r.prevZ.nextZ = null, r.prevZ = null, function (e) { var t, i, n, r, a, s, o, l, c = 1; do { for (i = e, e = null, a = null, s = 0; i;) { for (s++, n = i, o = 0, t = 0; t < c && (o++, n = n.nextZ); t++); for (l = c; o > 0 || l > 0 && n;)0 !== o && (0 === l || !n || i.z <= n.z) ? (r = i, i = i.nextZ, o--) : (r = n, n = n.nextZ, l--), a ? a.nextZ = r : e = r, r.prevZ = a, a = r; i = n } a.nextZ = null, c *= 2 } while (s > 1) }(r) }(e, n, r, a); for (var o, l, c = e; e.prev !== e.next;)if (o = e.prev, l = e.next, a ? Un(e, n, r, a) : Gn(e)) t.push(o.i / i), t.push(e.i / i), t.push(l.i / i), ir(e), e = l.next, c = l.next; else if ((e = l) === c) { s ? 1 === s ? Fn(e = Hn(e, t, i), t, i, n, r, a, 2) : 2 === s && Vn(e, t, i, n, r, a) : Fn(Bn(e), t, i, n, r, a, 1); break } } } function Gn(e) { var t = e.prev, i = e, n = e.next; if (Jn(t, i, n) >= 0) return !1; for (var r = e.next.next; r !== e.prev;) { if (Yn(t.x, t.y, i.x, i.y, n.x, n.y, r.x, r.y) && Jn(r.prev, r, r.next) >= 0) return !1; r = r.next } return !0 } function Un(e, t, i, n) { var r = e.prev, a = e, s = e.next; if (Jn(r, a, s) >= 0) return !1; for (var o = r.x < a.x ? r.x < s.x ? r.x : s.x : a.x < s.x ? a.x : s.x, l = r.y < a.y ? r.y < s.y ? r.y : s.y : a.y < s.y ? a.y : s.y, c = r.x > a.x ? r.x > s.x ? r.x : s.x : a.x > s.x ? a.x : s.x, h = r.y > a.y ? r.y > s.y ? r.y : s.y : a.y > s.y ? a.y : s.y, u = $n(o, l, t, i, n), d = $n(c, h, t, i, n), p = e.nextZ; p && p.z <= d;) { if (p !== e.prev && p !== e.next && Yn(r.x, r.y, a.x, a.y, s.x, s.y, p.x, p.y) && Jn(p.prev, p, p.next) >= 0) return !1; p = p.nextZ } for (p = e.prevZ; p && p.z >= u;) { if (p !== e.prev && p !== e.next && Yn(r.x, r.y, a.x, a.y, s.x, s.y, p.x, p.y) && Jn(p.prev, p, p.next) >= 0) return !1; p = p.prevZ } return !0 } function Hn(e, t, i) { var n = e; do { var r = n.prev, a = n.next.next; !Zn(r, a) && Kn(r, n, n.next, a) && Qn(r, a) && Qn(a, r) && (t.push(r.i / i), t.push(n.i / i), t.push(a.i / i), ir(n), ir(n.next), n = e = a), n = n.next } while (n !== e); return n } function Vn(e, t, i, n, r, a) { var s = e; do { for (var o = s.next.next; o !== s.prev;) { if (s.i !== o.i && qn(s, o)) { var l = er(s, o); return s = Bn(s, s.next), l = Bn(l, l.next), Fn(s, t, i, n, r, a), void Fn(l, t, i, n, r, a) } o = o.next } s = s.next } while (s !== e) } function jn(e, t) { return e.x - t.x } function Wn(e, t) { if (t = function (e, t) { var i, n = t, r = e.x, a = e.y, s = -1 / 0; do { if (a <= n.y && a >= n.next.y && n.next.y !== n.y) { var o = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (o <= r && o > s) { if (s = o, o === r) { if (a === n.y) return n; if (a === n.next.y) return n.next } i = n.x < n.next.x ? n : n.next } } n = n.next } while (n !== t); if (!i) return null; if (r === s) return i.prev; var l, c = i, h = i.x, u = i.y, d = 1 / 0; n = i.next; for (; n !== c;)r >= n.x && n.x >= h && r !== n.x && Yn(a < u ? r : s, a, h, u, a < u ? s : r, a, n.x, n.y) && ((l = Math.abs(a - n.y) / (r - n.x)) < d || l === d && n.x > i.x) && Qn(n, e) && (i = n, d = l), n = n.next; return i }(e, t)) { var i = er(t, e); Bn(i, i.next) } } function $n(e, t, i, n, r) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 } function Xn(e) { var t = e, i = e; do { t.x < i.x && (i = t), t = t.next } while (t !== e); return i } function Yn(e, t, i, n, r, a, s, o) { return (r - s) * (t - o) - (e - s) * (a - o) >= 0 && (e - s) * (n - o) - (i - s) * (t - o) >= 0 && (i - s) * (a - o) - (r - s) * (n - o) >= 0 } function qn(e, t) { return e.next.i !== t.i && e.prev.i !== t.i && !function (e, t) { var i = e; do { if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && Kn(i, i.next, e, t)) return !0; i = i.next } while (i !== e); return !1 }(e, t) && Qn(e, t) && Qn(t, e) && function (e, t) { var i = e, n = !1, r = (e.x + t.x) / 2, a = (e.y + t.y) / 2; do { i.y > a != i.next.y > a && i.next.y !== i.y && r < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next } while (i !== e); return n }(e, t) } function Jn(e, t, i) { return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y) } function Zn(e, t) { return e.x === t.x && e.y === t.y } function Kn(e, t, i, n) { return !!(Zn(e, t) && Zn(i, n) || Zn(e, n) && Zn(i, t)) || Jn(e, t, i) > 0 != Jn(e, t, n) > 0 && Jn(i, n, e) > 0 != Jn(i, n, t) > 0 } function Qn(e, t) { return Jn(e.prev, e, e.next) < 0 ? Jn(e, t, e.next) >= 0 && Jn(e, e.prev, t) >= 0 : Jn(e, t, e.prev) < 0 || Jn(e, e.next, t) < 0 } function er(e, t) { var i = new nr(e.i, e.x, e.y), n = new nr(t.i, t.x, t.y), r = e.next, a = t.prev; return e.next = t, t.prev = e, i.next = r, r.prev = i, n.next = i, i.prev = n, a.next = n, n.prev = a, n } function tr(e, t, i, n) { var r = new nr(e, t, i); return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r } function ir(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) } function nr(e, t, i) { this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } var rr = { area: function (e) { for (var t = e.length, i = 0, n = t - 1, r = 0; r < t; n = r++)i += e[n].x * e[r].y - e[r].x * e[n].y; return .5 * i }, isClockWise: function (e) { return rr.area(e) < 0 }, triangulateShape: function (e, t) { var i = [], n = [], r = []; ar(e), sr(i, e); var a = e.length; t.forEach(ar); for (var s = 0; s < t.length; s++)n.push(a), a += t[s].length, sr(i, t[s]); var o = zn(i, n); for (s = 0; s < o.length; s += 3)r.push(o.slice(s, s + 3)); return r } }; function ar(e) { var t = e.length; t > 2 && e[t - 1].equals(e[0]) && e.pop() } function sr(e, t) { for (var i = 0; i < t.length; i++)e.push(t[i].x), e.push(t[i].y) } function or(e, t) { de.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, this.fromBufferGeometry(new lr(e, t)), this.mergeVertices() } function lr(e, t) { Ee.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e]; for (var i = this, n = [], r = [], a = 0, s = e.length; a < s; a++) { o(e[a]) } function o(e) { var a = [], s = void 0 !== t.curveSegments ? t.curveSegments : 12, o = void 0 !== t.steps ? t.steps : 1, c = void 0 !== t.depth ? t.depth : 100, u = void 0 === t.bevelEnabled || t.bevelEnabled, d = void 0 !== t.bevelThickness ? t.bevelThickness : 6, p = void 0 !== t.bevelSize ? t.bevelSize : d - 2, f = void 0 !== t.bevelOffset ? t.bevelOffset : 0, m = void 0 !== t.bevelSegments ? t.bevelSegments : 3, g = t.extrudePath, v = void 0 !== t.UVGenerator ? t.UVGenerator : cr; void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = t.amount); var y, _, x, b, w, T, M, S, E = !1; g && (y = g.getSpacedPoints(o), E = !0, u = !1, _ = g.computeFrenetFrames(o, !1), x = new h, b = new h, w = new h), u || (m = 0, d = 0, p = 0, f = 0); var C = e.extractPoints(s), A = C.shape, P = C.holes; if (!rr.isClockWise(A)) for (A = A.reverse(), M = 0, S = P.length; M < S; M++)T = P[M], rr.isClockWise(T) && (P[M] = T.reverse()); var L = rr.triangulateShape(A, P), R = A; for (M = 0, S = P.length; M < S; M++)T = P[M], A = A.concat(T); function O(e, t, i) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e) } var I, k, D, z, N, B, F = A.length, G = L.length; function U(e, t, i) { var n, r, a, s = e.x - t.x, o = e.y - t.y, c = i.x - e.x, h = i.y - e.y, u = s * s + o * o, d = s * h - o * c; if (Math.abs(d) > Number.EPSILON) { var p = Math.sqrt(u), f = Math.sqrt(c * c + h * h), m = t.x - o / p, g = t.y + s / p, v = ((i.x - h / f - m) * h - (i.y + c / f - g) * c) / (s * h - o * c), y = (n = m + s * v - e.x) * n + (r = g + o * v - e.y) * r; if (y <= 2) return new l(n, r); a = Math.sqrt(y / 2) } else { var _ = !1; s > Number.EPSILON ? c > Number.EPSILON && (_ = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (_ = !0) : Math.sign(o) === Math.sign(h) && (_ = !0), _ ? (n = -o, r = s, a = Math.sqrt(u)) : (n = s, r = o, a = Math.sqrt(u / 2)) } return new l(n / a, r / a) } for (var H = [], V = 0, j = R.length, W = j - 1, $ = V + 1; V < j; V++, W++, $++)W === j && (W = 0), $ === j && ($ = 0), H[V] = U(R[V], R[W], R[$]); var X, Y, q = [], J = H.concat(); for (M = 0, S = P.length; M < S; M++) { for (T = P[M], X = [], V = 0, W = (j = T.length) - 1, $ = V + 1; V < j; V++, W++, $++)W === j && (W = 0), $ === j && ($ = 0), X[V] = U(T[V], T[W], T[$]); q.push(X), J = J.concat(X) } for (I = 0; I < m; I++) { for (D = I / m, z = d * Math.cos(D * Math.PI / 2), k = p * Math.sin(D * Math.PI / 2) + f, V = 0, j = R.length; V < j; V++)K((N = O(R[V], H[V], k)).x, N.y, -z); for (M = 0, S = P.length; M < S; M++)for (T = P[M], X = q[M], V = 0, j = T.length; V < j; V++)K((N = O(T[V], X[V], k)).x, N.y, -z) } for (k = p + f, V = 0; V < F; V++)N = u ? O(A[V], J[V], k) : A[V], E ? (b.copy(_.normals[0]).multiplyScalar(N.x), x.copy(_.binormals[0]).multiplyScalar(N.y), w.copy(y[0]).add(b).add(x), K(w.x, w.y, w.z)) : K(N.x, N.y, 0); for (Y = 1; Y <= o; Y++)for (V = 0; V < F; V++)N = u ? O(A[V], J[V], k) : A[V], E ? (b.copy(_.normals[Y]).multiplyScalar(N.x), x.copy(_.binormals[Y]).multiplyScalar(N.y), w.copy(y[Y]).add(b).add(x), K(w.x, w.y, w.z)) : K(N.x, N.y, c / o * Y); for (I = m - 1; I >= 0; I--) { for (D = I / m, z = d * Math.cos(D * Math.PI / 2), k = p * Math.sin(D * Math.PI / 2) + f, V = 0, j = R.length; V < j; V++)K((N = O(R[V], H[V], k)).x, N.y, c + z); for (M = 0, S = P.length; M < S; M++)for (T = P[M], X = q[M], V = 0, j = T.length; V < j; V++)N = O(T[V], X[V], k), E ? K(N.x, N.y + y[o - 1].y, y[o - 1].x + z) : K(N.x, N.y, c + z) } function Z(e, t) { var i, n; for (V = e.length; --V >= 0;) { i = V, (n = V - 1) < 0 && (n = e.length - 1); var r = 0, a = o + 2 * m; for (r = 0; r < a; r++) { var s = F * r, l = F * (r + 1); ee(t + i + s, t + n + s, t + n + l, t + i + l) } } } function K(e, t, i) { a.push(e), a.push(t), a.push(i) } function Q(e, t, r) { te(e), te(t), te(r); var a = n.length / 3, s = v.generateTopUV(i, n, a - 3, a - 2, a - 1); ie(s[0]), ie(s[1]), ie(s[2]) } function ee(e, t, r, a) { te(e), te(t), te(a), te(t), te(r), te(a); var s = n.length / 3, o = v.generateSideWallUV(i, n, s - 6, s - 3, s - 2, s - 1); ie(o[0]), ie(o[1]), ie(o[3]), ie(o[1]), ie(o[2]), ie(o[3]) } function te(e) { n.push(a[3 * e + 0]), n.push(a[3 * e + 1]), n.push(a[3 * e + 2]) } function ie(e) { r.push(e.x), r.push(e.y) } !function () { var e = n.length / 3; if (u) { var t = 0, r = F * t; for (V = 0; V < G; V++)Q((B = L[V])[2] + r, B[1] + r, B[0] + r); for (r = F * (t = o + 2 * m), V = 0; V < G; V++)Q((B = L[V])[0] + r, B[1] + r, B[2] + r) } else { for (V = 0; V < G; V++)Q((B = L[V])[2], B[1], B[0]); for (V = 0; V < G; V++)Q((B = L[V])[0] + F * o, B[1] + F * o, B[2] + F * o) } i.addGroup(e, n.length / 3 - e, 0) }(), function () { var e = n.length / 3, t = 0; for (Z(R, t), t += R.length, M = 0, S = P.length; M < S; M++)Z(T = P[M], t), t += T.length; i.addGroup(e, n.length / 3 - e, 1) }() } this.addAttribute("position", new be(n, 3)), this.addAttribute("uv", new be(r, 2)), this.computeVertexNormals() } or.prototype = Object.create(de.prototype), or.prototype.constructor = or, or.prototype.toJSON = function () { var e = de.prototype.toJSON.call(this); return hr(this.parameters.shapes, this.parameters.options, e) }, lr.prototype = Object.create(Ee.prototype), lr.prototype.constructor = lr, lr.prototype.toJSON = function () { var e = Ee.prototype.toJSON.call(this); return hr(this.parameters.shapes, this.parameters.options, e) }; var cr = { generateTopUV: function (e, t, i, n, r) { var a = t[3 * i], s = t[3 * i + 1], o = t[3 * n], c = t[3 * n + 1], h = t[3 * r], u = t[3 * r + 1]; return [new l(a, s), new l(o, c), new l(h, u)] }, generateSideWallUV: function (e, t, i, n, r, a) { var s = t[3 * i], o = t[3 * i + 1], c = t[3 * i + 2], h = t[3 * n], u = t[3 * n + 1], d = t[3 * n + 2], p = t[3 * r], f = t[3 * r + 1], m = t[3 * r + 2], g = t[3 * a], v = t[3 * a + 1], y = t[3 * a + 2]; return Math.abs(o - u) < .01 ? [new l(s, 1 - c), new l(h, 1 - d), new l(p, 1 - m), new l(g, 1 - y)] : [new l(o, 1 - c), new l(u, 1 - d), new l(f, 1 - m), new l(v, 1 - y)] } }; function hr(e, t, i) { if (i.shapes = [], Array.isArray(e)) for (var n = 0, r = e.length; n < r; n++) { var a = e[n]; i.shapes.push(a.uuid) } else i.shapes.push(e.uuid); return void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()), i } function ur(e, t) { de.call(this), this.type = "TextGeometry", this.parameters = { text: e, parameters: t }, this.fromBufferGeometry(new dr(e, t)), this.mergeVertices() } function dr(e, t) { var i = (t = t || {}).font; if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new de; var n = i.generateShapes(e, t.size); t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), lr.call(this, n, t), this.type = "TextBufferGeometry" } function pr(e, t, i, n, r, a, s) { de.call(this), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: n, phiLength: r, thetaStart: a, thetaLength: s }, this.fromBufferGeometry(new fr(e, t, i, n, r, a, s)), this.mergeVertices() } function fr(e, t, i, n, r, a, s) { Ee.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: n, phiLength: r, thetaStart: a, thetaLength: s }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : Math.PI; var o, l, c = Math.min(a + s, Math.PI), u = 0, d = [], p = new h, f = new h, m = [], g = [], v = [], y = []; for (l = 0; l <= i; l++) { var _ = [], x = l / i, b = 0; for (0 == l && 0 == a ? b = .5 / t : l == i && c == Math.PI && (b = -.5 / t), o = 0; o <= t; o++) { var w = o / t; p.x = -e * Math.cos(n + w * r) * Math.sin(a + x * s), p.y = e * Math.cos(a + x * s), p.z = e * Math.sin(n + w * r) * Math.sin(a + x * s), g.push(p.x, p.y, p.z), f.copy(p).normalize(), v.push(f.x, f.y, f.z), y.push(w + b, 1 - x), _.push(u++) } d.push(_) } for (l = 0; l < i; l++)for (o = 0; o < t; o++) { var T = d[l][o + 1], M = d[l][o], S = d[l + 1][o], E = d[l + 1][o + 1]; (0 !== l || a > 0) && m.push(T, M, E), (l !== i - 1 || c < Math.PI) && m.push(M, S, E) } this.setIndex(m), this.addAttribute("position", new be(g, 3)), this.addAttribute("normal", new be(v, 3)), this.addAttribute("uv", new be(y, 2)) } function mr(e, t, i, n, r, a) { de.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: n, thetaStart: r, thetaLength: a }, this.fromBufferGeometry(new gr(e, t, i, n, r, a)), this.mergeVertices() } function gr(e, t, i, n, r, a) { Ee.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: n, thetaStart: r, thetaLength: a }, e = e || .5, t = t || 1, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8; var s, o, c, u = [], d = [], p = [], f = [], m = e, g = (t - e) / (n = void 0 !== n ? Math.max(1, n) : 1), v = new h, y = new l; for (o = 0; o <= n; o++) { for (c = 0; c <= i; c++)s = r + c / i * a, v.x = m * Math.cos(s), v.y = m * Math.sin(s), d.push(v.x, v.y, v.z), p.push(0, 0, 1), y.x = (v.x / t + 1) / 2, y.y = (v.y / t + 1) / 2, f.push(y.x, y.y); m += g } for (o = 0; o < n; o++) { var _ = o * (i + 1); for (c = 0; c < i; c++) { var x = s = c + _, b = s + i + 1, w = s + i + 2, T = s + 1; u.push(x, b, T), u.push(b, w, T) } } this.setIndex(u), this.addAttribute("position", new be(d, 3)), this.addAttribute("normal", new be(p, 3)), this.addAttribute("uv", new be(f, 2)) } function vr(e, t, i, n) { de.call(this), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: n }, this.fromBufferGeometry(new yr(e, t, i, n)), this.mergeVertices() } function yr(e, t, i, n) { Ee.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: n }, t = Math.floor(t) || 12, i = i || 0, n = n || 2 * Math.PI, n = o.clamp(n, 0, 2 * Math.PI); var r, a, s, c = [], u = [], d = [], p = 1 / t, f = new h, m = new l; for (a = 0; a <= t; a++) { var g = i + a * p * n, v = Math.sin(g), y = Math.cos(g); for (s = 0; s <= e.length - 1; s++)f.x = e[s].x * v, f.y = e[s].y, f.z = e[s].x * y, u.push(f.x, f.y, f.z), m.x = a / t, m.y = s / (e.length - 1), d.push(m.x, m.y) } for (a = 0; a < t; a++)for (s = 0; s < e.length - 1; s++) { var _ = r = s + a * e.length, x = r + e.length, b = r + e.length + 1, w = r + 1; c.push(_, x, w), c.push(x, b, w) } if (this.setIndex(c), this.addAttribute("position", new be(u, 3)), this.addAttribute("uv", new be(d, 2)), this.computeVertexNormals(), n === 2 * Math.PI) { var T = this.attributes.normal.array, M = new h, S = new h, E = new h; for (r = t * e.length * 3, a = 0, s = 0; a < e.length; a++, s += 3)M.x = T[s + 0], M.y = T[s + 1], M.z = T[s + 2], S.x = T[r + s + 0], S.y = T[r + s + 1], S.z = T[r + s + 2], E.addVectors(M, S).normalize(), T[s + 0] = T[r + s + 0] = E.x, T[s + 1] = T[r + s + 1] = E.y, T[s + 2] = T[r + s + 2] = E.z } } function _r(e, t) { de.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = { shapes: e, curveSegments: t }, this.fromBufferGeometry(new xr(e, t)), this.mergeVertices() } function xr(e, t) { Ee.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: e, curveSegments: t }, t = t || 12; var i = [], n = [], r = [], a = [], s = 0, o = 0; if (!1 === Array.isArray(e)) c(e); else for (var l = 0; l < e.length; l++)c(e[l]), this.addGroup(s, o, l), s += o, o = 0; function c(e) { var s, l, c, h = n.length / 3, u = e.extractPoints(t), d = u.shape, p = u.holes; for (!1 === rr.isClockWise(d) && (d = d.reverse()), s = 0, l = p.length; s < l; s++)c = p[s], !0 === rr.isClockWise(c) && (p[s] = c.reverse()); var f = rr.triangulateShape(d, p); for (s = 0, l = p.length; s < l; s++)c = p[s], d = d.concat(c); for (s = 0, l = d.length; s < l; s++) { var m = d[s]; n.push(m.x, m.y, 0), r.push(0, 0, 1), a.push(m.x, m.y) } for (s = 0, l = f.length; s < l; s++) { var g = f[s], v = g[0] + h, y = g[1] + h, _ = g[2] + h; i.push(v, y, _), o += 3 } } this.setIndex(i), this.addAttribute("position", new be(n, 3)), this.addAttribute("normal", new be(r, 3)), this.addAttribute("uv", new be(a, 2)) } function br(e, t) { if (t.shapes = [], Array.isArray(e)) for (var i = 0, n = e.length; i < n; i++) { var r = e[i]; t.shapes.push(r.uuid) } else t.shapes.push(e.uuid); return t } function wr(e, t) { Ee.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: t }, t = void 0 !== t ? t : 1; var i, n, r, a, s = [], l = Math.cos(o.DEG2RAD * t), c = [0, 0], h = {}, u = ["a", "b", "c"]; e.isBufferGeometry ? (a = new de).fromBufferGeometry(e) : a = e.clone(), a.mergeVertices(), a.computeFaceNormals(); for (var d = a.vertices, p = a.faces, f = 0, m = p.length; f < m; f++)for (var g = p[f], v = 0; v < 3; v++)i = g[u[v]], n = g[u[(v + 1) % 3]], c[0] = Math.min(i, n), c[1] = Math.max(i, n), void 0 === h[r = c[0] + "," + c[1]] ? h[r] = { index1: c[0], index2: c[1], face1: f, face2: void 0 } : h[r].face2 = f; for (r in h) { var y = h[r]; if (void 0 === y.face2 || p[y.face1].normal.dot(p[y.face2].normal) <= l) { var _ = d[y.index1]; s.push(_.x, _.y, _.z), _ = d[y.index2], s.push(_.x, _.y, _.z) } } this.addAttribute("position", new be(s, 3)) } function Tr(e, t, i, n, r, a, s, o) { de.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: n, heightSegments: r, openEnded: a, thetaStart: s, thetaLength: o }, this.fromBufferGeometry(new Mr(e, t, i, n, r, a, s, o)), this.mergeVertices() } function Mr(e, t, i, n, r, a, s, o) { Ee.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: n, heightSegments: r, openEnded: a, thetaStart: s, thetaLength: o }; var c = this; e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, i = i || 1, n = Math.floor(n) || 8, r = Math.floor(r) || 1, a = void 0 !== a && a, s = void 0 !== s ? s : 0, o = void 0 !== o ? o : 2 * Math.PI; var u = [], d = [], p = [], f = [], m = 0, g = [], v = i / 2, y = 0; function _(i) { var r, a, g, _ = new l, x = new h, b = 0, w = !0 === i ? e : t, T = !0 === i ? 1 : -1; for (a = m, r = 1; r <= n; r++)d.push(0, v * T, 0), p.push(0, T, 0), f.push(.5, .5), m++; for (g = m, r = 0; r <= n; r++) { var M = r / n * o + s, S = Math.cos(M), E = Math.sin(M); x.x = w * E, x.y = v * T, x.z = w * S, d.push(x.x, x.y, x.z), p.push(0, T, 0), _.x = .5 * S + .5, _.y = .5 * E * T + .5, f.push(_.x, _.y), m++ } for (r = 0; r < n; r++) { var C = a + r, A = g + r; !0 === i ? u.push(A, A + 1, C) : u.push(A + 1, A, C), b += 3 } c.addGroup(y, b, !0 === i ? 1 : 2), y += b } !function () { var a, l, _ = new h, x = new h, b = 0, w = (t - e) / i; for (l = 0; l <= r; l++) { var T = [], M = l / r, S = M * (t - e) + e; for (a = 0; a <= n; a++) { var E = a / n, C = E * o + s, A = Math.sin(C), P = Math.cos(C); x.x = S * A, x.y = -M * i + v, x.z = S * P, d.push(x.x, x.y, x.z), _.set(A, w, P).normalize(), p.push(_.x, _.y, _.z), f.push(E, 1 - M), T.push(m++) } g.push(T) } for (a = 0; a < n; a++)for (l = 0; l < r; l++) { var L = g[l][a], R = g[l + 1][a], O = g[l + 1][a + 1], I = g[l][a + 1]; u.push(L, R, I), u.push(R, O, I), b += 6 } c.addGroup(y, b, 0), y += b }(), !1 === a && (e > 0 && _(!0), t > 0 && _(!1)), this.setIndex(u), this.addAttribute("position", new be(d, 3)), this.addAttribute("normal", new be(p, 3)), this.addAttribute("uv", new be(f, 2)) } function Sr(e, t, i, n, r, a, s) { Tr.call(this, 0, e, t, i, n, r, a, s), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: n, openEnded: r, thetaStart: a, thetaLength: s } } function Er(e, t, i, n, r, a, s) { Mr.call(this, 0, e, t, i, n, r, a, s), this.type = "ConeBufferGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: n, openEnded: r, thetaStart: a, thetaLength: s } } function Cr(e, t, i, n) { de.call(this), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: n }, this.fromBufferGeometry(new Ar(e, t, i, n)), this.mergeVertices() } function Ar(e, t, i, n) { Ee.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: n }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI; var r, a, s = [], o = [], c = [], u = [], d = new h, p = new l; for (o.push(0, 0, 0), c.push(0, 0, 1), u.push(.5, .5), a = 0, r = 3; a <= t; a++, r += 3) { var f = i + a / t * n; d.x = e * Math.cos(f), d.y = e * Math.sin(f), o.push(d.x, d.y, d.z), c.push(0, 0, 1), p.x = (o[r] / e + 1) / 2, p.y = (o[r + 1] / e + 1) / 2, u.push(p.x, p.y) } for (r = 1; r <= t; r++)s.push(r, r + 1, 0); this.setIndex(s), this.addAttribute("position", new be(o, 3)), this.addAttribute("normal", new be(c, 3)), this.addAttribute("uv", new be(u, 2)) } ur.prototype = Object.create(de.prototype), ur.prototype.constructor = ur, dr.prototype = Object.create(lr.prototype), dr.prototype.constructor = dr, pr.prototype = Object.create(de.prototype), pr.prototype.constructor = pr, fr.prototype = Object.create(Ee.prototype), fr.prototype.constructor = fr, mr.prototype = Object.create(de.prototype), mr.prototype.constructor = mr, gr.prototype = Object.create(Ee.prototype), gr.prototype.constructor = gr, vr.prototype = Object.create(de.prototype), vr.prototype.constructor = vr, yr.prototype = Object.create(Ee.prototype), yr.prototype.constructor = yr, _r.prototype = Object.create(de.prototype), _r.prototype.constructor = _r, _r.prototype.toJSON = function () { var e = de.prototype.toJSON.call(this); return br(this.parameters.shapes, e) }, xr.prototype = Object.create(Ee.prototype), xr.prototype.constructor = xr, xr.prototype.toJSON = function () { var e = Ee.prototype.toJSON.call(this); return br(this.parameters.shapes, e) }, wr.prototype = Object.create(Ee.prototype), wr.prototype.constructor = wr, Tr.prototype = Object.create(de.prototype), Tr.prototype.constructor = Tr, Mr.prototype = Object.create(Ee.prototype), Mr.prototype.constructor = Mr, Sr.prototype = Object.create(Tr.prototype), Sr.prototype.constructor = Sr, Er.prototype = Object.create(Mr.prototype), Er.prototype.constructor = Er, Cr.prototype = Object.create(de.prototype), Cr.prototype.constructor = Cr, Ar.prototype = Object.create(Ee.prototype), Ar.prototype.constructor = Ar; var Pr = Object.freeze({ WireframeGeometry: vn, ParametricGeometry: yn, ParametricBufferGeometry: _n, TetrahedronGeometry: wn, TetrahedronBufferGeometry: Tn, OctahedronGeometry: Mn, OctahedronBufferGeometry: Sn, IcosahedronGeometry: En, IcosahedronBufferGeometry: Cn, DodecahedronGeometry: An, DodecahedronBufferGeometry: Pn, PolyhedronGeometry: xn, PolyhedronBufferGeometry: bn, TubeGeometry: Ln, TubeBufferGeometry: Rn, TorusKnotGeometry: On, TorusKnotBufferGeometry: In, TorusGeometry: kn, TorusBufferGeometry: Dn, TextGeometry: ur, TextBufferGeometry: dr, SphereGeometry: pr, SphereBufferGeometry: fr, RingGeometry: mr, RingBufferGeometry: gr, PlaneGeometry: Pe, PlaneBufferGeometry: Le, LatheGeometry: vr, LatheBufferGeometry: yr, ShapeGeometry: _r, ShapeBufferGeometry: xr, ExtrudeGeometry: or, ExtrudeBufferGeometry: lr, EdgesGeometry: wr, ConeGeometry: Sr, ConeBufferGeometry: Er, CylinderGeometry: Tr, CylinderBufferGeometry: Mr, CircleGeometry: Cr, CircleBufferGeometry: Ar, BoxGeometry: Ce, BoxBufferGeometry: Ae }); function Lr(e) { Oe.call(this), this.type = "ShadowMaterial", this.color = new X(0), this.transparent = !0, this.setValues(e) } function Rr(e) { We.call(this, e), this.type = "RawShaderMaterial" } function Or(e) { Oe.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new X(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new X(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } function Ir(e) { Or.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e) } function kr(e) { Oe.call(this), this.type = "MeshPhongMaterial", this.color = new X(16777215), this.specular = new X(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new X(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } function Dr(e) { kr.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e) } function zr(e) { Oe.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } function Nr(e) { Oe.call(this), this.type = "MeshLambertMaterial", this.color = new X(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new X(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) } function Br(e) { Oe.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new X(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new l(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(e) } function Fr(e) { on.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) } Lr.prototype = Object.create(Oe.prototype), Lr.prototype.constructor = Lr, Lr.prototype.isShadowMaterial = !0, Lr.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.color.copy(e.color), this }, Rr.prototype = Object.create(We.prototype), Rr.prototype.constructor = Rr, Rr.prototype.isRawShaderMaterial = !0, Or.prototype = Object.create(Oe.prototype), Or.prototype.constructor = Or, Or.prototype.isMeshStandardMaterial = !0, Or.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, Ir.prototype = Object.create(Or.prototype), Ir.prototype.constructor = Ir, Ir.prototype.isMeshPhysicalMaterial = !0, Ir.prototype.copy = function (e) { return Or.prototype.copy.call(this, e), this.defines = { PHYSICAL: "" }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this }, kr.prototype = Object.create(Oe.prototype), kr.prototype.constructor = kr, kr.prototype.isMeshPhongMaterial = !0, kr.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, Dr.prototype = Object.create(kr.prototype), Dr.prototype.constructor = Dr, Dr.prototype.isMeshToonMaterial = !0, Dr.prototype.copy = function (e) { return kr.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this }, zr.prototype = Object.create(Oe.prototype), zr.prototype.constructor = zr, zr.prototype.isMeshNormalMaterial = !0, zr.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, Nr.prototype = Object.create(Oe.prototype), Nr.prototype.constructor = Nr, Nr.prototype.isMeshLambertMaterial = !0, Nr.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, Br.prototype = Object.create(Oe.prototype), Br.prototype.constructor = Br, Br.prototype.isMeshMatcapMaterial = !0, Br.prototype.copy = function (e) { return Oe.prototype.copy.call(this, e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, Fr.prototype = Object.create(on.prototype), Fr.prototype.constructor = Fr, Fr.prototype.isLineDashedMaterial = !0, Fr.prototype.copy = function (e) { return on.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this }; var Gr = Object.freeze({ ShadowMaterial: Lr, SpriteMaterial: en, RawShaderMaterial: Rr, ShaderMaterial: We, PointsMaterial: un, MeshPhysicalMaterial: Ir, MeshStandardMaterial: Or, MeshPhongMaterial: kr, MeshToonMaterial: Dr, MeshNormalMaterial: zr, MeshLambertMaterial: Nr, MeshDepthMaterial: Ci, MeshDistanceMaterial: Ai, MeshBasicMaterial: Ye, MeshMatcapMaterial: Br, LineDashedMaterial: Fr, LineBasicMaterial: on, Material: Oe }), Ur = { arraySlice: function (e, t, i) { return Ur.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i) }, convertArray: function (e, t, i) { return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) }, isTypedArray: function (e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) }, getKeyframeOrder: function (e) { for (var t = e.length, i = new Array(t), n = 0; n !== t; ++n)i[n] = n; return i.sort((function (t, i) { return e[t] - e[i] })), i }, sortedArray: function (e, t, i) { for (var n = e.length, r = new e.constructor(n), a = 0, s = 0; s !== n; ++a)for (var o = i[a] * t, l = 0; l !== t; ++l)r[s++] = e[o + l]; return r }, flattenJSON: function (e, t, i, n) { for (var r = 1, a = e[0]; void 0 !== a && void 0 === a[n];)a = e[r++]; if (void 0 !== a) { var s = a[n]; if (void 0 !== s) if (Array.isArray(s)) do { void 0 !== (s = a[n]) && (t.push(a.time), i.push.apply(i, s)), a = e[r++] } while (void 0 !== a); else if (void 0 !== s.toArray) do { void 0 !== (s = a[n]) && (t.push(a.time), s.toArray(i, i.length)), a = e[r++] } while (void 0 !== a); else do { void 0 !== (s = a[n]) && (t.push(a.time), i.push(s)), a = e[r++] } while (void 0 !== a) } } }; function Hr(e, t, i, n) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i } function Vr(e, t, i, n) { Hr.call(this, e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 } function jr(e, t, i, n) { Hr.call(this, e, t, i, n) } function Wr(e, t, i, n) { Hr.call(this, e, t, i, n) } function $r(e, t, i, n) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e); this.name = e, this.times = Ur.convertArray(t, this.TimeBufferType), this.values = Ur.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation) } function Xr(e, t, i) { $r.call(this, e, t, i) } function Yr(e, t, i, n) { $r.call(this, e, t, i, n) } function qr(e, t, i, n) { $r.call(this, e, t, i, n) } function Jr(e, t, i, n) { Hr.call(this, e, t, i, n) } function Zr(e, t, i, n) { $r.call(this, e, t, i, n) } function Kr(e, t, i, n) { $r.call(this, e, t, i, n) } function Qr(e, t, i, n) { $r.call(this, e, t, i, n) } function ea(e, t, i) { this.name = e, this.tracks = i, this.duration = void 0 !== t ? t : -1, this.uuid = o.generateUUID(), this.duration < 0 && this.resetDuration() } function ta(e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); var t = function (e) { switch (e.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return qr; case "vector": case "vector2": case "vector3": case "vector4": return Qr; case "color": return Yr; case "quaternion": return Zr; case "bool": case "boolean": return Xr; case "string": return Kr }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { var i = [], n = []; Ur.flattenJSON(e.keys, i, n, "value"), e.times = i, e.values = n } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) } Object.assign(Hr.prototype, { evaluate: function (e) { var t = this.parameterPositions, i = this._cachedIndex, n = t[i], r = t[i - 1]; e: { t: { var a; i: { n: if (!(e < n)) { for (var s = i + 2; ;) { if (void 0 === n) { if (e < r) break n; return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, e, r) } if (i === s) break; if (r = n, e < (n = t[++i])) break t } a = t.length; break i } if (e >= r) break e; var o = t[1]; e < o && (i = 2, r = o); for (s = i - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, n); if (i === s) break; if (n = r, e >= (r = t[--i - 1])) break t } a = i, i = 0 } for (; i < a;) { var l = i + a >>> 1; e < t[l] ? a = l : i = l + 1 } if (n = t[i], void 0 === (r = t[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, n); if (void 0 === n) return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, e) } this._cachedIndex = i, this.intervalChanged_(i, r, n) } return this.interpolate_(i, r, e, n) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (e) { for (var t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n, a = 0; a !== n; ++a)t[a] = i[r + a]; return t }, interpolate_: function () { throw new Error("call to abstract method") }, intervalChanged_: function () { } }),
        //!\ DECLARE ALIAS AFTER assign prototype !
        Object.assign(Hr.prototype, { beforeStart_: Hr.prototype.copySampleValue_, afterEnd_: Hr.prototype.copySampleValue_ }), Vr.prototype = Object.assign(Object.create(Hr.prototype), { constructor: Vr, DefaultSettings_: { endingStart: 2400, endingEnd: 2400 }, intervalChanged_: function (e, t, i) { var n = this.parameterPositions, r = e - 2, a = e + 1, s = n[r], o = n[a]; if (void 0 === s) switch (this.getSettings_().endingStart) { case 2401: r = e, s = 2 * t - i; break; case 2402: s = t + n[r = n.length - 2] - n[r + 1]; break; default: r = e, s = i }if (void 0 === o) switch (this.getSettings_().endingEnd) { case 2401: a = e, o = 2 * i - t; break; case 2402: a = 1, o = i + n[1] - n[0]; break; default: a = e - 1, o = t }var l = .5 * (i - t), c = this.valueSize; this._weightPrev = l / (t - s), this._weightNext = l / (o - i), this._offsetPrev = r * c, this._offsetNext = a * c }, interpolate_: function (e, t, i, n) { for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, l = o - s, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (i - t) / (n - t), f = p * p, m = f * p, g = -u * m + 2 * u * f - u * p, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, _ = d * m - d * f, x = 0; x !== s; ++x)r[x] = g * a[c + x] + v * a[l + x] + y * a[o + x] + _ * a[h + x]; return r } }), jr.prototype = Object.assign(Object.create(Hr.prototype), { constructor: jr, interpolate_: function (e, t, i, n) { for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, l = o - s, c = (i - t) / (n - t), h = 1 - c, u = 0; u !== s; ++u)r[u] = a[l + u] * h + a[o + u] * c; return r } }), Wr.prototype = Object.assign(Object.create(Hr.prototype), { constructor: Wr, interpolate_: function (e) { return this.copySampleValue_(e - 1) } }), Object.assign($r, { toJSON: function (e) { var t, i = e.constructor; if (void 0 !== i.toJSON) t = i.toJSON(e); else { t = { name: e.name, times: Ur.convertArray(e.times, Array), values: Ur.convertArray(e.values, Array) }; var n = e.getInterpolation(); n !== e.DefaultInterpolation && (t.interpolation = n) } return t.type = e.ValueTypeName, t } }), Object.assign($r.prototype, { constructor: $r, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function (e) { return new Wr(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodLinear: function (e) { return new jr(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodSmooth: function (e) { return new Vr(this.times, this.values, this.getValueSize(), e) }, setInterpolation: function (e) { var t; switch (e) { case 2300: t = this.InterpolantFactoryMethodDiscrete; break; case 2301: t = this.InterpolantFactoryMethodLinear; break; case 2302: t = this.InterpolantFactoryMethodSmooth }if (void 0 === t) { var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(i); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", i), this } return this.createInterpolant = t, this }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return 2300; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302 } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (e) { if (0 !== e) for (var t = this.times, i = 0, n = t.length; i !== n; ++i)t[i] += e; return this }, scale: function (e) { if (1 !== e) for (var t = this.times, i = 0, n = t.length; i !== n; ++i)t[i] *= e; return this }, trim: function (e, t) { for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < e;)++r; for (; -1 !== a && i[a] > t;)--a; if (++a, 0 !== r || a !== n) { r >= a && (r = (a = Math.max(a, 1)) - 1); var s = this.getValueSize(); this.times = Ur.arraySlice(i, r, a), this.values = Ur.arraySlice(this.values, r * s, a * s) } return this }, validate: function () { var e = !0, t = this.getValueSize(); t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); var i = this.times, n = this.values, r = i.length; 0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); for (var a = null, s = 0; s !== r; s++) { var o = i[s]; if ("number" == typeof o && isNaN(o)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, s, o), e = !1; break } if (null !== a && a > o) { console.error("THREE.KeyframeTrack: Out of order keys.", this, s, o, a), e = !1; break } a = o } if (void 0 !== n && Ur.isTypedArray(n)) { s = 0; for (var l = n.length; s !== l; ++s) { var c = n[s]; if (isNaN(c)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, s, c), e = !1; break } } } return e }, optimize: function () { for (var e = this.times, t = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, a = e.length - 1, s = 1; s < a; ++s) { var o = !1, l = e[s]; if (l !== e[s + 1] && (1 !== s || l !== l[0])) if (n) o = !0; else for (var c = s * i, h = c - i, u = c + i, d = 0; d !== i; ++d) { var p = t[c + d]; if (p !== t[h + d] || p !== t[u + d]) { o = !0; break } } if (o) { if (s !== r) { e[r] = e[s]; var f = s * i, m = r * i; for (d = 0; d !== i; ++d)t[m + d] = t[f + d] } ++r } } if (a > 0) { e[r] = e[a]; for (f = a * i, m = r * i, d = 0; d !== i; ++d)t[m + d] = t[f + d]; ++r } return r !== e.length && (this.times = Ur.arraySlice(e, 0, r), this.values = Ur.arraySlice(t, 0, r * i)), this }, clone: function () { var e = Ur.arraySlice(this.times, 0), t = Ur.arraySlice(this.values, 0), i = new (0, this.constructor)(this.name, e, t); return i.createInterpolant = this.createInterpolant, i } }), Xr.prototype = Object.assign(Object.create($r.prototype), { constructor: Xr, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Yr.prototype = Object.assign(Object.create($r.prototype), { constructor: Yr, ValueTypeName: "color" }), qr.prototype = Object.assign(Object.create($r.prototype), { constructor: qr, ValueTypeName: "number" }), Jr.prototype = Object.assign(Object.create(Hr.prototype), { constructor: Jr, interpolate_: function (e, t, i, n) { for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = e * s, l = (i - t) / (n - t), h = o + s; o !== h; o += 4)c.slerpFlat(r, 0, a, o - s, a, o, l); return r } }), Zr.prototype = Object.assign(Object.create($r.prototype), { constructor: Zr, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function (e) { return new Jr(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodSmooth: void 0 }), Kr.prototype = Object.assign(Object.create($r.prototype), { constructor: Kr, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Qr.prototype = Object.assign(Object.create($r.prototype), { constructor: Qr, ValueTypeName: "vector" }), Object.assign(ea, { parse: function (e) { for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), r = 0, a = i.length; r !== a; ++r)t.push(ta(i[r]).scale(n)); return new ea(e.name, e.duration, t) }, toJSON: function (e) { for (var t = [], i = e.tracks, n = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid }, r = 0, a = i.length; r !== a; ++r)t.push($r.toJSON(i[r])); return n }, CreateFromMorphTargetSequence: function (e, t, i, n) { for (var r = t.length, a = [], s = 0; s < r; s++) { var o = [], l = []; o.push((s + r - 1) % r, s, (s + 1) % r), l.push(0, 1, 0); var c = Ur.getKeyframeOrder(o); o = Ur.sortedArray(o, 1, c), l = Ur.sortedArray(l, 1, c), n || 0 !== o[0] || (o.push(r), l.push(l[0])), a.push(new qr(".morphTargetInfluences[" + t[s].name + "]", o, l).scale(1 / i)) } return new ea(e, -1, a) }, findByName: function (e, t) { var i = e; if (!Array.isArray(e)) { var n = e; i = n.geometry && n.geometry.animations || n.animations } for (var r = 0; r < i.length; r++)if (i[r].name === t) return i[r]; return null }, CreateClipsFromMorphTargetSequences: function (e, t, i) { for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, s = e.length; a < s; a++) { var o = e[a], l = o.name.match(r); if (l && l.length > 1) { var c = n[u = l[1]]; c || (n[u] = c = []), c.push(o) } } var h = []; for (var u in n) h.push(ea.CreateFromMorphTargetSequence(u, n[u], t, i)); return h }, parseAnimation: function (e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; for (var i = function (e, t, i, n, r) { if (0 !== i.length) { var a = [], s = []; Ur.flattenJSON(i, a, s, n), 0 !== a.length && r.push(new e(t, a, s)) } }, n = [], r = e.name || "default", a = e.length || -1, s = e.fps || 30, o = e.hierarchy || [], l = 0; l < o.length; l++) { var c = o[l].keys; if (c && 0 !== c.length) if (c[0].morphTargets) { for (var h = {}, u = 0; u < c.length; u++)if (c[u].morphTargets) for (var d = 0; d < c[u].morphTargets.length; d++)h[c[u].morphTargets[d]] = -1; for (var p in h) { var f = [], m = []; for (d = 0; d !== c[u].morphTargets.length; ++d) { var g = c[u]; f.push(g.time), m.push(g.morphTarget === p ? 1 : 0) } n.push(new qr(".morphTargetInfluence[" + p + "]", f, m)) } a = h.length * (s || 1) } else { var v = ".bones[" + t[l].name + "]"; i(Qr, v + ".position", c, "pos", n), i(Zr, v + ".quaternion", c, "rot", n), i(Qr, v + ".scale", c, "scl", n) } } return 0 === n.length ? null : new ea(r, a, n) } }), Object.assign(ea.prototype, { resetDuration: function () { for (var e = 0, t = 0, i = this.tracks.length; t !== i; ++t) { var n = this.tracks[t]; e = Math.max(e, n.times[n.times.length - 1]) } return this.duration = e, this }, trim: function () { for (var e = 0; e < this.tracks.length; e++)this.tracks[e].trim(0, this.duration); return this }, validate: function () { for (var e = !0, t = 0; t < this.tracks.length; t++)e = e && this.tracks[t].validate(); return e }, optimize: function () { for (var e = 0; e < this.tracks.length; e++)this.tracks[e].optimize(); return this }, clone: function () { for (var e = [], t = 0; t < this.tracks.length; t++)e.push(this.tracks[t].clone()); return new ea(this.name, this.duration, e) } }); var ia = { enabled: !1, files: {}, add: function (e, t) { !1 !== this.enabled && (this.files[e] = t) }, get: function (e) { if (!1 !== this.enabled) return this.files[e] }, remove: function (e) { delete this.files[e] }, clear: function () { this.files = {} } }; function na(e, t, i) { var n = this, r = !1, a = 0, s = 0, o = void 0; this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (e) { s++, !1 === r && void 0 !== n.onStart && n.onStart(e, a, s), r = !0 }, this.itemEnd = function (e) { a++, void 0 !== n.onProgress && n.onProgress(e, a, s), a === s && (r = !1, void 0 !== n.onLoad && n.onLoad()) }, this.itemError = function (e) { void 0 !== n.onError && n.onError(e) }, this.resolveURL = function (e) { return o ? o(e) : e }, this.setURLModifier = function (e) { return o = e, this } } var ra = new na, aa = {}; function sa(e) { this.manager = void 0 !== e ? e : ra } function oa(e) { this.manager = void 0 !== e ? e : ra, this._parser = null } function la(e) { this.manager = void 0 !== e ? e : ra } function ca(e) { this.manager = void 0 !== e ? e : ra } function ha(e) { this.manager = void 0 !== e ? e : ra } function ua() { this.type = "Curve", this.arcLengthDivisions = 200 } function da(e, t, i, n, r, a, s, o) { ua.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = s || !1, this.aRotation = o || 0 } function pa(e, t, i, n, r, a) { da.call(this, e, t, i, i, n, r, a), this.type = "ArcCurve" } function fa() { var e = 0, t = 0, i = 0, n = 0; function r(r, a, s, o) { e = r, t = s, i = -3 * r + 3 * a - 2 * s - o, n = 2 * r - 2 * a + s + o } return { initCatmullRom: function (e, t, i, n, a) { r(t, i, a * (i - e), a * (n - t)) }, initNonuniformCatmullRom: function (e, t, i, n, a, s, o) { var l = (t - e) / a - (i - e) / (a + s) + (i - t) / s, c = (i - t) / s - (n - t) / (s + o) + (n - i) / o; r(t, i, l *= s, c *= s) }, calc: function (r) { var a = r * r; return e + t * r + i * a + n * (a * r) } } } Object.assign(sa.prototype, { load: function (e, t, i, n) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); var r = this, a = ia.get(e); if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function () { t && t(a), r.manager.itemEnd(e) }), 0), a; if (void 0 === aa[e]) { var s = e.match(/^data:(.*?)(;base64)?,(.*)$/); if (s) { var o = s[1], l = !!s[2], c = s[3]; c = decodeURIComponent(c), l && (c = atob(c)); try { var h, u = (this.responseType || "").toLowerCase(); switch (u) { case "arraybuffer": case "blob": for (var d = new Uint8Array(c.length), p = 0; p < c.length; p++)d[p] = c.charCodeAt(p); h = "blob" === u ? new Blob([d.buffer], { type: o }) : d.buffer; break; case "document": var f = new DOMParser; h = f.parseFromString(c, o); break; case "json": h = JSON.parse(c); break; default: h = c }setTimeout((function () { t && t(h), r.manager.itemEnd(e) }), 0) } catch (t) { setTimeout((function () { n && n(t), r.manager.itemError(e), r.manager.itemEnd(e) }), 0) } } else { aa[e] = [], aa[e].push({ onLoad: t, onProgress: i, onError: n }); var m = new XMLHttpRequest; for (var g in m.open("GET", e, !0), m.addEventListener("load", (function (t) { var i = this.response; ia.add(e, i); var n = aa[e]; if (delete aa[e], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."); for (var a = 0, s = n.length; a < s; a++) { (o = n[a]).onLoad && o.onLoad(i) } r.manager.itemEnd(e) } else { for (a = 0, s = n.length; a < s; a++) { var o; (o = n[a]).onError && o.onError(t) } r.manager.itemError(e), r.manager.itemEnd(e) } }), !1), m.addEventListener("progress", (function (t) { for (var i = aa[e], n = 0, r = i.length; n < r; n++) { var a = i[n]; a.onProgress && a.onProgress(t) } }), !1), m.addEventListener("error", (function (t) { var i = aa[e]; delete aa[e]; for (var n = 0, a = i.length; n < a; n++) { var s = i[n]; s.onError && s.onError(t) } r.manager.itemError(e), r.manager.itemEnd(e) }), !1), m.addEventListener("abort", (function (t) { var i = aa[e]; delete aa[e]; for (var n = 0, a = i.length; n < a; n++) { var s = i[n]; s.onError && s.onError(t) } r.manager.itemError(e), r.manager.itemEnd(e) }), !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(g, this.requestHeader[g]); m.send(null) } return r.manager.itemStart(e), m } aa[e].push({ onLoad: t, onProgress: i, onError: n }) }, setPath: function (e) { return this.path = e, this }, setResponseType: function (e) { return this.responseType = e, this }, setWithCredentials: function (e) { return this.withCredentials = e, this }, setMimeType: function (e) { return this.mimeType = e, this }, setRequestHeader: function (e) { return this.requestHeader = e, this } }), Object.assign(function (e) { this.manager = void 0 !== e ? e : ra }.prototype, { load: function (e, t, i, n) { var r = this, a = new sa(r.manager); a.setPath(r.path), a.load(e, (function (e) { t(r.parse(JSON.parse(e))) }), i, n) }, parse: function (e) { for (var t = [], i = 0; i < e.length; i++) { var n = ea.parse(e[i]); t.push(n) } return t }, setPath: function (e) { return this.path = e, this } }), Object.assign(function (e) { this.manager = void 0 !== e ? e : ra, this._parser = null }.prototype, { load: function (e, t, i, n) { var r = this, a = [], s = new fn; s.image = a; var o = new sa(this.manager); function l(l) { o.load(e[l], (function (e) { var i = r._parser(e, !0); a[l] = { width: i.width, height: i.height, format: i.format, mipmaps: i.mipmaps }, 6 === (c += 1) && (1 === i.mipmapCount && (s.minFilter = 1006), s.format = i.format, s.needsUpdate = !0, t && t(s)) }), i, n) } if (o.setPath(this.path), o.setResponseType("arraybuffer"), Array.isArray(e)) for (var c = 0, h = 0, u = e.length; h < u; ++h)l(h); else o.load(e, (function (e) { var i = r._parser(e, !0); if (i.isCubemap) for (var n = i.mipmaps.length / i.mipmapCount, o = 0; o < n; o++) { a[o] = { mipmaps: [] }; for (var l = 0; l < i.mipmapCount; l++)a[o].mipmaps.push(i.mipmaps[o * i.mipmapCount + l]), a[o].format = i.format, a[o].width = i.width, a[o].height = i.height } else s.image.width = i.width, s.image.height = i.height, s.mipmaps = i.mipmaps; 1 === i.mipmapCount && (s.minFilter = 1006), s.format = i.format, s.needsUpdate = !0, t && t(s) }), i, n); return s }, setPath: function (e) { return this.path = e, this } }), Object.assign(oa.prototype, { load: function (e, t, i, n) { var r = this, a = new I, s = new sa(this.manager); return s.setResponseType("arraybuffer"), s.setPath(this.path), s.load(e, (function (e) { var i = r._parser(e); i && (void 0 !== i.image ? a.image = i.image : void 0 !== i.data && (a.image.width = i.width, a.image.height = i.height, a.image.data = i.data), a.wrapS = void 0 !== i.wrapS ? i.wrapS : 1001, a.wrapT = void 0 !== i.wrapT ? i.wrapT : 1001, a.magFilter = void 0 !== i.magFilter ? i.magFilter : 1006, a.minFilter = void 0 !== i.minFilter ? i.minFilter : 1008, a.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.format && (a.format = i.format), void 0 !== i.type && (a.type = i.type), void 0 !== i.mipmaps && (a.mipmaps = i.mipmaps), 1 === i.mipmapCount && (a.minFilter = 1006), a.needsUpdate = !0, t && t(a, i)) }), i, n), a }, setPath: function (e) { return this.path = e, this } }), Object.assign(la.prototype, { crossOrigin: "anonymous", load: function (e, t, i, n) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); var r = this, a = ia.get(e); if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function () { t && t(a), r.manager.itemEnd(e) }), 0), a; var s = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); function o() { s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1), ia.add(e, this), t && t(this), r.manager.itemEnd(e) } function l(t) { s.removeEventListener("load", o, !1), s.removeEventListener("error", l, !1), n && n(t), r.manager.itemError(e), r.manager.itemEnd(e) } return s.addEventListener("load", o, !1), s.addEventListener("error", l, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(e), s.src = e, s }, setCrossOrigin: function (e) { return this.crossOrigin = e, this }, setPath: function (e) { return this.path = e, this } }), Object.assign(ca.prototype, { crossOrigin: "anonymous", load: function (e, t, i, n) { var r = new ot, a = new la(this.manager); a.setCrossOrigin(this.crossOrigin), a.setPath(this.path); var s = 0; function o(i) { a.load(e[i], (function (e) { r.images[i] = e, 6 === ++s && (r.needsUpdate = !0, t && t(r)) }), void 0, n) } for (var l = 0; l < e.length; ++l)o(l); return r }, setCrossOrigin: function (e) { return this.crossOrigin = e, this }, setPath: function (e) { return this.path = e, this } }), Object.assign(ha.prototype, { crossOrigin: "anonymous", load: function (e, t, i, n) { var r = new A, a = new la(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, (function (i) { r.image = i; var n = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/); r.format = n ? 1022 : 1023, r.needsUpdate = !0, void 0 !== t && t(r) }), i, n), r }, setCrossOrigin: function (e) { return this.crossOrigin = e, this }, setPath: function (e) { return this.path = e, this } }), Object.assign(ua.prototype, { getPoint: function () { return console.warn("THREE.Curve: .getPoint() not implemented."), null }, getPointAt: function (e, t) { var i = this.getUtoTmapping(e); return this.getPoint(i, t) }, getPoints: function (e) { void 0 === e && (e = 5); for (var t = [], i = 0; i <= e; i++)t.push(this.getPoint(i / e)); return t }, getSpacedPoints: function (e) { void 0 === e && (e = 5); for (var t = [], i = 0; i <= e; i++)t.push(this.getPointAt(i / e)); return t }, getLength: function () { var e = this.getLengths(); return e[e.length - 1] }, getLengths: function (e) { if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; var t, i, n = [], r = this.getPoint(0), a = 0; for (n.push(0), i = 1; i <= e; i++)a += (t = this.getPoint(i / e)).distanceTo(r), n.push(a), r = t; return this.cacheArcLengths = n, n }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function (e, t) { var i, n = this.getLengths(), r = 0, a = n.length; i = t || e * n[a - 1]; for (var s, o = 0, l = a - 1; o <= l;)if ((s = n[r = Math.floor(o + (l - o) / 2)] - i) < 0) o = r + 1; else { if (!(s > 0)) { l = r; break } l = r - 1 } if (n[r = l] === i) return r / (a - 1); var c = n[r]; return (r + (i - c) / (n[r + 1] - c)) / (a - 1) }, getTangent: function (e) { var t = e - 1e-4, i = e + 1e-4; t < 0 && (t = 0), i > 1 && (i = 1); var n = this.getPoint(t); return this.getPoint(i).clone().sub(n).normalize() }, getTangentAt: function (e) { var t = this.getUtoTmapping(e); return this.getTangent(t) }, computeFrenetFrames: function (e, t) { var i, n, r, a = new h, s = [], l = [], c = [], u = new h, d = new B; for (i = 0; i <= e; i++)n = i / e, s[i] = this.getTangentAt(n), s[i].normalize(); l[0] = new h, c[0] = new h; var p = Number.MAX_VALUE, f = Math.abs(s[0].x), m = Math.abs(s[0].y), g = Math.abs(s[0].z); for (f <= p && (p = f, a.set(1, 0, 0)), m <= p && (p = m, a.set(0, 1, 0)), g <= p && a.set(0, 0, 1), u.crossVectors(s[0], a).normalize(), l[0].crossVectors(s[0], u), c[0].crossVectors(s[0], l[0]), i = 1; i <= e; i++)l[i] = l[i - 1].clone(), c[i] = c[i - 1].clone(), u.crossVectors(s[i - 1], s[i]), u.length() > Number.EPSILON && (u.normalize(), r = Math.acos(o.clamp(s[i - 1].dot(s[i]), -1, 1)), l[i].applyMatrix4(d.makeRotationAxis(u, r))), c[i].crossVectors(s[i], l[i]); if (!0 === t) for (r = Math.acos(o.clamp(l[0].dot(l[e]), -1, 1)), r /= e, s[0].dot(u.crossVectors(l[0], l[e])) > 0 && (r = -r), i = 1; i <= e; i++)l[i].applyMatrix4(d.makeRotationAxis(s[i], r * i)), c[i].crossVectors(s[i], l[i]); return { tangents: s, normals: l, binormals: c } }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.arcLengthDivisions = e.arcLengthDivisions, this }, toJSON: function () { var e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e }, fromJSON: function (e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } }), da.prototype = Object.create(ua.prototype), da.prototype.constructor = da, da.prototype.isEllipseCurve = !0, da.prototype.getPoint = function (e, t) { for (var i = t || new l, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; r < 0;)r += n; for (; r > n;)r -= n; r < Number.EPSILON && (r = a ? 0 : n), !0 !== this.aClockwise || a || (r === n ? r = -n : r -= n); var s = this.aStartAngle + e * r, o = this.aX + this.xRadius * Math.cos(s), c = this.aY + this.yRadius * Math.sin(s); if (0 !== this.aRotation) { var h = Math.cos(this.aRotation), u = Math.sin(this.aRotation), d = o - this.aX, p = c - this.aY; o = d * h - p * u + this.aX, c = d * u + p * h + this.aY } return i.set(o, c) }, da.prototype.copy = function (e) { return ua.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this }, da.prototype.toJSON = function () { var e = ua.prototype.toJSON.call(this); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e }, da.prototype.fromJSON = function (e) { return ua.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this }, pa.prototype = Object.create(da.prototype), pa.prototype.constructor = pa, pa.prototype.isArcCurve = !0; var ma = new h, ga = new fa, va = new fa, ya = new fa; function _a(e, t, i, n) { ua.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = i || "centripetal", this.tension = n || .5 } function xa(e, t, i, n, r) { var a = .5 * (n - t), s = .5 * (r - i), o = e * e; return (2 * i - 2 * n + a + s) * (e * o) + (-3 * i + 3 * n - 2 * a - s) * o + a * e + i } function ba(e, t, i, n) { return function (e, t) { var i = 1 - e; return i * i * t }(e, t) + function (e, t) { return 2 * (1 - e) * e * t }(e, i) + function (e, t) { return e * e * t }(e, n) } function wa(e, t, i, n, r) { return function (e, t) { var i = 1 - e; return i * i * i * t }(e, t) + function (e, t) { var i = 1 - e; return 3 * i * i * e * t }(e, i) + function (e, t) { return 3 * (1 - e) * e * e * t }(e, n) + function (e, t) { return e * e * e * t }(e, r) } function Ta(e, t, i, n) { ua.call(this), this.type = "CubicBezierCurve", this.v0 = e || new l, this.v1 = t || new l, this.v2 = i || new l, this.v3 = n || new l } function Ma(e, t, i, n) { ua.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new h, this.v1 = t || new h, this.v2 = i || new h, this.v3 = n || new h } function Sa(e, t) { ua.call(this), this.type = "LineCurve", this.v1 = e || new l, this.v2 = t || new l } function Ea(e, t) { ua.call(this), this.type = "LineCurve3", this.v1 = e || new h, this.v2 = t || new h } function Ca(e, t, i) { ua.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new l, this.v1 = t || new l, this.v2 = i || new l } function Aa(e, t, i) { ua.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new h, this.v1 = t || new h, this.v2 = i || new h } function Pa(e) { ua.call(this), this.type = "SplineCurve", this.points = e || [] } _a.prototype = Object.create(ua.prototype), _a.prototype.constructor = _a, _a.prototype.isCatmullRomCurve3 = !0, _a.prototype.getPoint = function (e, t) { var i, n, r, a, s = t || new h, o = this.points, l = o.length, c = (l - (this.closed ? 0 : 1)) * e, u = Math.floor(c), d = c - u; if (this.closed ? u += u > 0 ? 0 : (Math.floor(Math.abs(u) / l) + 1) * l : 0 === d && u === l - 1 && (u = l - 2, d = 1), this.closed || u > 0 ? i = o[(u - 1) % l] : (ma.subVectors(o[0], o[1]).add(o[0]), i = ma), n = o[u % l], r = o[(u + 1) % l], this.closed || u + 2 < l ? a = o[(u + 2) % l] : (ma.subVectors(o[l - 1], o[l - 2]).add(o[l - 1]), a = ma), "centripetal" === this.curveType || "chordal" === this.curveType) { var p = "chordal" === this.curveType ? .5 : .25, f = Math.pow(i.distanceToSquared(n), p), m = Math.pow(n.distanceToSquared(r), p), g = Math.pow(r.distanceToSquared(a), p); m < 1e-4 && (m = 1), f < 1e-4 && (f = m), g < 1e-4 && (g = m), ga.initNonuniformCatmullRom(i.x, n.x, r.x, a.x, f, m, g), va.initNonuniformCatmullRom(i.y, n.y, r.y, a.y, f, m, g), ya.initNonuniformCatmullRom(i.z, n.z, r.z, a.z, f, m, g) } else "catmullrom" === this.curveType && (ga.initCatmullRom(i.x, n.x, r.x, a.x, this.tension), va.initCatmullRom(i.y, n.y, r.y, a.y, this.tension), ya.initCatmullRom(i.z, n.z, r.z, a.z, this.tension)); return s.set(ga.calc(d), va.calc(d), ya.calc(d)), s }, _a.prototype.copy = function (e) { ua.prototype.copy.call(this, e), this.points = []; for (var t = 0, i = e.points.length; t < i; t++) { var n = e.points[t]; this.points.push(n.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this }, _a.prototype.toJSON = function () { var e = ua.prototype.toJSON.call(this); e.points = []; for (var t = 0, i = this.points.length; t < i; t++) { var n = this.points[t]; e.points.push(n.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e }, _a.prototype.fromJSON = function (e) { ua.prototype.fromJSON.call(this, e), this.points = []; for (var t = 0, i = e.points.length; t < i; t++) { var n = e.points[t]; this.points.push((new h).fromArray(n)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this }, Ta.prototype = Object.create(ua.prototype), Ta.prototype.constructor = Ta, Ta.prototype.isCubicBezierCurve = !0, Ta.prototype.getPoint = function (e, t) { var i = t || new l, n = this.v0, r = this.v1, a = this.v2, s = this.v3; return i.set(wa(e, n.x, r.x, a.x, s.x), wa(e, n.y, r.y, a.y, s.y)), i }, Ta.prototype.copy = function (e) { return ua.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this }, Ta.prototype.toJSON = function () { var e = ua.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e }, Ta.prototype.fromJSON = function (e) { return ua.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this }, Ma.prototype = Object.create(ua.prototype), Ma.prototype.constructor = Ma, Ma.prototype.isCubicBezierCurve3 = !0, Ma.prototype.getPoint = function (e, t) { var i = t || new h, n = this.v0, r = this.v1, a = this.v2, s = this.v3; return i.set(wa(e, n.x, r.x, a.x, s.x), wa(e, n.y, r.y, a.y, s.y), wa(e, n.z, r.z, a.z, s.z)), i }, Ma.prototype.copy = function (e) { return ua.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this }, Ma.prototype.toJSON = function () { var e = ua.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e }, Ma.prototype.fromJSON = function (e) { return ua.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this }, Sa.prototype = Object.create(ua.prototype), Sa.prototype.constructor = Sa, Sa.prototype.isLineCurve = !0, Sa.prototype.getPoint = function (e, t) { var i = t || new l; return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i }, Sa.prototype.getPointAt = function (e, t) { return this.getPoint(e, t) }, Sa.prototype.getTangent = function () { return this.v2.clone().sub(this.v1).normalize() }, Sa.prototype.copy = function (e) { return ua.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, Sa.prototype.toJSON = function () { var e = ua.prototype.toJSON.call(this); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, Sa.prototype.fromJSON = function (e) { return ua.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, Ea.prototype = Object.create(ua.prototype), Ea.prototype.constructor = Ea, Ea.prototype.isLineCurve3 = !0, Ea.prototype.getPoint = function (e, t) { var i = t || new h; return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i }, Ea.prototype.getPointAt = function (e, t) { return this.getPoint(e, t) }, Ea.prototype.copy = function (e) { return ua.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, Ea.prototype.toJSON = function () { var e = ua.prototype.toJSON.call(this); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, Ea.prototype.fromJSON = function (e) { return ua.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, Ca.prototype = Object.create(ua.prototype), Ca.prototype.constructor = Ca, Ca.prototype.isQuadraticBezierCurve = !0, Ca.prototype.getPoint = function (e, t) { var i = t || new l, n = this.v0, r = this.v1, a = this.v2; return i.set(ba(e, n.x, r.x, a.x), ba(e, n.y, r.y, a.y)), i }, Ca.prototype.copy = function (e) { return ua.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, Ca.prototype.toJSON = function () { var e = ua.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, Ca.prototype.fromJSON = function (e) { return ua.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, Aa.prototype = Object.create(ua.prototype), Aa.prototype.constructor = Aa, Aa.prototype.isQuadraticBezierCurve3 = !0, Aa.prototype.getPoint = function (e, t) { var i = t || new h, n = this.v0, r = this.v1, a = this.v2; return i.set(ba(e, n.x, r.x, a.x), ba(e, n.y, r.y, a.y), ba(e, n.z, r.z, a.z)), i }, Aa.prototype.copy = function (e) { return ua.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, Aa.prototype.toJSON = function () { var e = ua.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, Aa.prototype.fromJSON = function (e) { return ua.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, Pa.prototype = Object.create(ua.prototype), Pa.prototype.constructor = Pa, Pa.prototype.isSplineCurve = !0, Pa.prototype.getPoint = function (e, t) { var i = t || new l, n = this.points, r = (n.length - 1) * e, a = Math.floor(r), s = r - a, o = n[0 === a ? a : a - 1], c = n[a], h = n[a > n.length - 2 ? n.length - 1 : a + 1], u = n[a > n.length - 3 ? n.length - 1 : a + 2]; return i.set(xa(s, o.x, c.x, h.x, u.x), xa(s, o.y, c.y, h.y, u.y)), i }, Pa.prototype.copy = function (e) { ua.prototype.copy.call(this, e), this.points = []; for (var t = 0, i = e.points.length; t < i; t++) { var n = e.points[t]; this.points.push(n.clone()) } return this }, Pa.prototype.toJSON = function () { var e = ua.prototype.toJSON.call(this); e.points = []; for (var t = 0, i = this.points.length; t < i; t++) { var n = this.points[t]; e.points.push(n.toArray()) } return e }, Pa.prototype.fromJSON = function (e) { ua.prototype.fromJSON.call(this, e), this.points = []; for (var t = 0, i = e.points.length; t < i; t++) { var n = e.points[t]; this.points.push((new l).fromArray(n)) } return this }; var La = Object.freeze({ ArcCurve: pa, CatmullRomCurve3: _a, CubicBezierCurve: Ta, CubicBezierCurve3: Ma, EllipseCurve: da, LineCurve: Sa, LineCurve3: Ea, QuadraticBezierCurve: Ca, QuadraticBezierCurve3: Aa, SplineCurve: Pa }); function Ra() { ua.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } function Oa(e) { Ra.call(this), this.type = "Path", this.currentPoint = new l, e && this.setFromPoints(e) } function Ia(e) { Oa.call(this, e), this.uuid = o.generateUUID(), this.type = "Shape", this.holes = [] } function ka(e, t) { le.call(this), this.type = "Light", this.color = new X(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0 } function Da(e, t, i) { ka.call(this, e, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(le.DefaultUp), this.updateMatrix(), this.groundColor = new X(t) } function za(e) { this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new l(512, 512), this.map = null, this.matrix = new B } function Na() { za.call(this, new Di(50, 1, .5, 500)) } function Ba(e, t, i, n, r, a) { ka.call(this, e, t), this.type = "SpotLight", this.position.copy(le.DefaultUp), this.updateMatrix(), this.target = new le, Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (e) { this.intensity = e / Math.PI } }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new Na } function Fa(e, t, i, n) { ka.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI }, set: function (e) { this.intensity = e / (4 * Math.PI) } }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new za(new Di(90, 1, .5, 500)) } function Ga(e, t, i, n, r, a) { ki.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix() } function Ua() { za.call(this, new Ga(-5, 5, 5, -5, .5, 500)) } function Ha(e, t) { ka.call(this, e, t), this.type = "DirectionalLight", this.position.copy(le.DefaultUp), this.updateMatrix(), this.target = new le, this.shadow = new Ua } function Va(e, t) { ka.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0 } function ja(e, t, i, n) { ka.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10 } function Wa(e) { this.manager = void 0 !== e ? e : ra, this.textures = {} } Ra.prototype = Object.assign(Object.create(ua.prototype), { constructor: Ra, add: function (e) { this.curves.push(e) }, closePath: function () { var e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1); e.equals(t) || this.curves.push(new Sa(t, e)) }, getPoint: function (e) { for (var t = e * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) { if (i[n] >= t) { var r = i[n] - t, a = this.curves[n], s = a.getLength(), o = 0 === s ? 0 : 1 - r / s; return a.getPointAt(o) } n++ } return null }, getLength: function () { var e = this.getCurveLengths(); return e[e.length - 1] }, updateArcLengths: function () { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var e = [], t = 0, i = 0, n = this.curves.length; i < n; i++)t += this.curves[i].getLength(), e.push(t); return this.cacheLengths = e, e }, getSpacedPoints: function (e) { void 0 === e && (e = 40); for (var t = [], i = 0; i <= e; i++)t.push(this.getPoint(i / e)); return this.autoClose && t.push(t[0]), t }, getPoints: function (e) { e = e || 12; for (var t, i = [], n = 0, r = this.curves; n < r.length; n++)for (var a = r[n], s = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e, o = a.getPoints(s), l = 0; l < o.length; l++) { var c = o[l]; t && t.equals(c) || (i.push(c), t = c) } return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i }, copy: function (e) { ua.prototype.copy.call(this, e), this.curves = []; for (var t = 0, i = e.curves.length; t < i; t++) { var n = e.curves[t]; this.curves.push(n.clone()) } return this.autoClose = e.autoClose, this }, toJSON: function () { var e = ua.prototype.toJSON.call(this); e.autoClose = this.autoClose, e.curves = []; for (var t = 0, i = this.curves.length; t < i; t++) { var n = this.curves[t]; e.curves.push(n.toJSON()) } return e }, fromJSON: function (e) { ua.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = []; for (var t = 0, i = e.curves.length; t < i; t++) { var n = e.curves[t]; this.curves.push((new La[n.type]).fromJSON(n)) } return this } }), Oa.prototype = Object.assign(Object.create(Ra.prototype), { constructor: Oa, setFromPoints: function (e) { this.moveTo(e[0].x, e[0].y); for (var t = 1, i = e.length; t < i; t++)this.lineTo(e[t].x, e[t].y) }, moveTo: function (e, t) { this.currentPoint.set(e, t) }, lineTo: function (e, t) { var i = new Sa(this.currentPoint.clone(), new l(e, t)); this.curves.push(i), this.currentPoint.set(e, t) }, quadraticCurveTo: function (e, t, i, n) { var r = new Ca(this.currentPoint.clone(), new l(e, t), new l(i, n)); this.curves.push(r), this.currentPoint.set(i, n) }, bezierCurveTo: function (e, t, i, n, r, a) { var s = new Ta(this.currentPoint.clone(), new l(e, t), new l(i, n), new l(r, a)); this.curves.push(s), this.currentPoint.set(r, a) }, splineThru: function (e) { var t = new Pa([this.currentPoint.clone()].concat(e)); this.curves.push(t), this.currentPoint.copy(e[e.length - 1]) }, arc: function (e, t, i, n, r, a) { var s = this.currentPoint.x, o = this.currentPoint.y; this.absarc(e + s, t + o, i, n, r, a) }, absarc: function (e, t, i, n, r, a) { this.absellipse(e, t, i, i, n, r, a) }, ellipse: function (e, t, i, n, r, a, s, o) { var l = this.currentPoint.x, c = this.currentPoint.y; this.absellipse(e + l, t + c, i, n, r, a, s, o) }, absellipse: function (e, t, i, n, r, a, s, o) { var l = new da(e, t, i, n, r, a, s, o); if (this.curves.length > 0) { var c = l.getPoint(0); c.equals(this.currentPoint) || this.lineTo(c.x, c.y) } this.curves.push(l); var h = l.getPoint(1); this.currentPoint.copy(h) }, copy: function (e) { return Ra.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this }, toJSON: function () { var e = Ra.prototype.toJSON.call(this); return e.currentPoint = this.currentPoint.toArray(), e }, fromJSON: function (e) { return Ra.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this } }), Ia.prototype = Object.assign(Object.create(Oa.prototype), { constructor: Ia, getPointsHoles: function (e) { for (var t = [], i = 0, n = this.holes.length; i < n; i++)t[i] = this.holes[i].getPoints(e); return t }, extractPoints: function (e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } }, copy: function (e) { Oa.prototype.copy.call(this, e), this.holes = []; for (var t = 0, i = e.holes.length; t < i; t++) { var n = e.holes[t]; this.holes.push(n.clone()) } return this }, toJSON: function () { var e = Oa.prototype.toJSON.call(this); e.uuid = this.uuid, e.holes = []; for (var t = 0, i = this.holes.length; t < i; t++) { var n = this.holes[t]; e.holes.push(n.toJSON()) } return e }, fromJSON: function (e) { Oa.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = []; for (var t = 0, i = e.holes.length; t < i; t++) { var n = e.holes[t]; this.holes.push((new Oa).fromJSON(n)) } return this } }), ka.prototype = Object.assign(Object.create(le.prototype), { constructor: ka, isLight: !0, copy: function (e) { return le.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this }, toJSON: function (e) { var t = le.prototype.toJSON.call(this, e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } }), Da.prototype = Object.assign(Object.create(ka.prototype), { constructor: Da, isHemisphereLight: !0, copy: function (e) { return ka.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this } }), Object.assign(za.prototype, { copy: function (e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { var e = {}; return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } }), Na.prototype = Object.assign(Object.create(za.prototype), { constructor: Na, isSpotLightShadow: !0, update: function (e) { var t = this.camera, i = 2 * o.RAD2DEG * e.angle, n = this.mapSize.width / this.mapSize.height, r = e.distance || t.far; i === t.fov && n === t.aspect && r === t.far || (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix()) } }), Ba.prototype = Object.assign(Object.create(ka.prototype), { constructor: Ba, isSpotLight: !0, copy: function (e) { return ka.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } }), Fa.prototype = Object.assign(Object.create(ka.prototype), { constructor: Fa, isPointLight: !0, copy: function (e) { return ka.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } }), Ga.prototype = Object.assign(Object.create(ki.prototype), { constructor: Ga, isOrthographicCamera: !0, copy: function (e, t) { return ki.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this }, setViewOffset: function (e, t, i, n, r, a) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, r = i - e, a = i + e, s = n + t, o = n - t; if (null !== this.view && this.view.enabled) { var l = this.zoom / (this.view.width / this.view.fullWidth), c = this.zoom / (this.view.height / this.view.fullHeight), h = (this.right - this.left) / this.view.width, u = (this.top - this.bottom) / this.view.height; a = (r += h * (this.view.offsetX / l)) + h * (this.view.width / l), o = (s -= u * (this.view.offsetY / c)) - u * (this.view.height / c) } this.projectionMatrix.makeOrthographic(r, a, s, o, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (e) { var t = le.prototype.toJSON.call(this, e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } }), Ua.prototype = Object.assign(Object.create(za.prototype), { constructor: Ua }), Ha.prototype = Object.assign(Object.create(ka.prototype), { constructor: Ha, isDirectionalLight: !0, copy: function (e) { return ka.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } }), Va.prototype = Object.assign(Object.create(ka.prototype), { constructor: Va, isAmbientLight: !0 }), ja.prototype = Object.assign(Object.create(ka.prototype), { constructor: ja, isRectAreaLight: !0, copy: function (e) { return ka.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this }, toJSON: function (e) { var t = ka.prototype.toJSON.call(this, e); return t.object.width = this.width, t.object.height = this.height, t } }), Object.assign(Wa.prototype, { load: function (e, t, i, n) { var r = this, a = new sa(r.manager); a.setPath(r.path), a.load(e, (function (e) { t(r.parse(JSON.parse(e))) }), i, n) }, parse: function (e) { var t = this.textures; function i(e) { return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e] } var n = new Gr[e.type]; if (void 0 !== e.uuid && (n.uuid = e.uuid), void 0 !== e.name && (n.name = e.name), void 0 !== e.color && n.color.setHex(e.color), void 0 !== e.roughness && (n.roughness = e.roughness), void 0 !== e.metalness && (n.metalness = e.metalness), void 0 !== e.emissive && n.emissive.setHex(e.emissive), void 0 !== e.specular && n.specular.setHex(e.specular), void 0 !== e.shininess && (n.shininess = e.shininess), void 0 !== e.clearCoat && (n.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (n.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.vertexColors && (n.vertexColors = e.vertexColors), void 0 !== e.fog && (n.fog = e.fog), void 0 !== e.flatShading && (n.flatShading = e.flatShading), void 0 !== e.blending && (n.blending = e.blending), void 0 !== e.combine && (n.combine = e.combine), void 0 !== e.side && (n.side = e.side), void 0 !== e.opacity && (n.opacity = e.opacity), void 0 !== e.transparent && (n.transparent = e.transparent), void 0 !== e.alphaTest && (n.alphaTest = e.alphaTest), void 0 !== e.depthTest && (n.depthTest = e.depthTest), void 0 !== e.depthWrite && (n.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (n.colorWrite = e.colorWrite), void 0 !== e.wireframe && (n.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (n.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (n.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (n.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (n.rotation = e.rotation), 1 !== e.linewidth && (n.linewidth = e.linewidth), void 0 !== e.dashSize && (n.dashSize = e.dashSize), void 0 !== e.gapSize && (n.gapSize = e.gapSize), void 0 !== e.scale && (n.scale = e.scale), void 0 !== e.polygonOffset && (n.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (n.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (n.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (n.skinning = e.skinning), void 0 !== e.morphTargets && (n.morphTargets = e.morphTargets), void 0 !== e.dithering && (n.dithering = e.dithering), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.uniforms) for (var r in e.uniforms) { var a = e.uniforms[r]; switch (n.uniforms[r] = {}, a.type) { case "t": n.uniforms[r].value = i(a.value); break; case "c": n.uniforms[r].value = (new X).setHex(a.value); break; case "v2": n.uniforms[r].value = (new l).fromArray(a.value); break; case "v3": n.uniforms[r].value = (new h).fromArray(a.value); break; case "v4": n.uniforms[r].value = (new P).fromArray(a.value); break; case "m3": n.uniforms[r].value = (new u).fromArray(a.value); case "m4": n.uniforms[r].value = (new B).fromArray(a.value); break; default: n.uniforms[r].value = a.value } } if (void 0 !== e.defines && (n.defines = e.defines), void 0 !== e.vertexShader && (n.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (n.fragmentShader = e.fragmentShader), void 0 !== e.extensions) for (var s in e.extensions) n.extensions[s] = e.extensions[s]; if (void 0 !== e.shading && (n.flatShading = 1 === e.shading), void 0 !== e.size && (n.size = e.size), void 0 !== e.sizeAttenuation && (n.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (n.map = i(e.map)), void 0 !== e.matcap && (n.matcap = i(e.matcap)), void 0 !== e.alphaMap && (n.alphaMap = i(e.alphaMap), n.transparent = !0), void 0 !== e.bumpMap && (n.bumpMap = i(e.bumpMap)), void 0 !== e.bumpScale && (n.bumpScale = e.bumpScale), void 0 !== e.normalMap && (n.normalMap = i(e.normalMap)), void 0 !== e.normalMapType && (n.normalMapType = e.normalMapType), void 0 !== e.normalScale) { var o = e.normalScale; !1 === Array.isArray(o) && (o = [o, o]), n.normalScale = (new l).fromArray(o) } return void 0 !== e.displacementMap && (n.displacementMap = i(e.displacementMap)), void 0 !== e.displacementScale && (n.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (n.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (n.roughnessMap = i(e.roughnessMap)), void 0 !== e.metalnessMap && (n.metalnessMap = i(e.metalnessMap)), void 0 !== e.emissiveMap && (n.emissiveMap = i(e.emissiveMap)), void 0 !== e.emissiveIntensity && (n.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (n.specularMap = i(e.specularMap)), void 0 !== e.envMap && (n.envMap = i(e.envMap)), void 0 !== e.envMapIntensity && (n.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (n.reflectivity = e.reflectivity), void 0 !== e.lightMap && (n.lightMap = i(e.lightMap)), void 0 !== e.lightMapIntensity && (n.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (n.aoMap = i(e.aoMap)), void 0 !== e.aoMapIntensity && (n.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (n.gradientMap = i(e.gradientMap)), n }, setPath: function (e) { return this.path = e, this }, setTextures: function (e) { return this.textures = e, this } }); var $a = function (e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); for (var t = "", i = 0, n = e.length; i < n; i++)t += String.fromCharCode(e[i]); try { return decodeURIComponent(escape(t)) } catch (e) { return t } }, Xa = function (e) { var t = e.lastIndexOf("/"); return -1 === t ? "./" : e.substr(0, t + 1) }; function Ya() { Ee.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0 } function qa(e, t, i, n) { "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), pe.call(this, e, t, i), this.meshPerAttribute = n || 1 } function Ja(e) { this.manager = void 0 !== e ? e : ra } Ya.prototype = Object.assign(Object.create(Ee.prototype), { constructor: Ya, isInstancedBufferGeometry: !0, copy: function (e) { return Ee.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { var e = Ee.prototype.toJSON.call(this); return e.maxInstancedCount = this.maxInstancedCount, e.isInstancedBufferGeometry = !0, e } }), qa.prototype = Object.assign(Object.create(pe.prototype), { constructor: qa, isInstancedBufferAttribute: !0, copy: function (e) { return pe.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this }, toJSON: function () { var e = pe.prototype.toJSON.call(this); return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e } }), Object.assign(Ja.prototype, { load: function (e, t, i, n) { var r = this, a = new sa(r.manager); a.setPath(r.path), a.load(e, (function (e) { t(r.parse(JSON.parse(e))) }), i, n) }, parse: function (e) { var t = e.isInstancedBufferGeometry ? new Ya : new Ee, i = e.data.index; if (void 0 !== i) { var n = new Za[i.type](i.array); t.setIndex(new pe(n, 1)) } var r = e.data.attributes; for (var a in r) { var s = r[a], o = (n = new Za[s.type](s.array), new (s.isInstancedBufferAttribute ? qa : pe)(n, s.itemSize, s.normalized)); void 0 !== s.name && (o.name = s.name), t.addAttribute(a, o) } var l = e.data.morphAttributes; if (l) for (var a in l) { for (var c = l[a], u = [], d = 0, p = c.length; d < p; d++) { s = c[d], o = new pe(n = new Za[s.type](s.array), s.itemSize, s.normalized); void 0 !== s.name && (o.name = s.name), u.push(o) } t.morphAttributes[a] = u } var f = e.data.groups || e.data.drawcalls || e.data.offsets; if (void 0 !== f) { d = 0; for (var m = f.length; d !== m; ++d) { var g = f[d]; t.addGroup(g.start, g.count, g.materialIndex) } } var v = e.data.boundingSphere; if (void 0 !== v) { var y = new h; void 0 !== v.center && y.fromArray(v.center), t.boundingSphere = new D(y, v.radius) } return e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t }, setPath: function (e) { return this.path = e, this } }); var Za = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; function Ka(e) { this.manager = void 0 !== e ? e : ra, this.resourcePath = "" } Object.assign(Ka.prototype, { crossOrigin: "anonymous", load: function (e, t, i, n) { var r = this, a = void 0 === this.path ? Xa(e) : this.path; this.resourcePath = this.resourcePath || a; var s = new sa(r.manager); s.setPath(this.path), s.load(e, (function (i) { var a = null; try { a = JSON.parse(i) } catch (t) { return void 0 !== n && n(t), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message) } var s = a.metadata; void 0 !== s && void 0 !== s.type && "geometry" !== s.type.toLowerCase() ? r.parse(a, t) : console.error("THREE.ObjectLoader: Can't load " + e) }), i, n) }, setPath: function (e) { return this.path = e, this }, setResourcePath: function (e) { return this.resourcePath = e, this }, setCrossOrigin: function (e) { return this.crossOrigin = e, this }, parse: function (e, t) { var i = this.parseShape(e.shapes), n = this.parseGeometries(e.geometries, i), r = this.parseImages(e.images, (function () { void 0 !== t && t(o) })), a = this.parseTextures(e.textures, r), s = this.parseMaterials(e.materials, a), o = this.parseObject(e.object, n, s); return e.animations && (o.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(o), o }, parseShape: function (e) { var t = {}; if (void 0 !== e) for (var i = 0, n = e.length; i < n; i++) { var r = (new Ia).fromJSON(e[i]); t[r.uuid] = r } return t }, parseGeometries: function (e, t) { var i = {}; if (void 0 !== e) for (var n = new Ja, r = 0, a = e.length; r < a; r++) { var s, o = e[r]; switch (o.type) { case "PlaneGeometry": case "PlaneBufferGeometry": s = new Pr[o.type](o.width, o.height, o.widthSegments, o.heightSegments); break; case "BoxGeometry": case "BoxBufferGeometry": case "CubeGeometry": s = new Pr[o.type](o.width, o.height, o.depth, o.widthSegments, o.heightSegments, o.depthSegments); break; case "CircleGeometry": case "CircleBufferGeometry": s = new Pr[o.type](o.radius, o.segments, o.thetaStart, o.thetaLength); break; case "CylinderGeometry": case "CylinderBufferGeometry": s = new Pr[o.type](o.radiusTop, o.radiusBottom, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength); break; case "ConeGeometry": case "ConeBufferGeometry": s = new Pr[o.type](o.radius, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength); break; case "SphereGeometry": case "SphereBufferGeometry": s = new Pr[o.type](o.radius, o.widthSegments, o.heightSegments, o.phiStart, o.phiLength, o.thetaStart, o.thetaLength); break; case "DodecahedronGeometry": case "DodecahedronBufferGeometry": case "IcosahedronGeometry": case "IcosahedronBufferGeometry": case "OctahedronGeometry": case "OctahedronBufferGeometry": case "TetrahedronGeometry": case "TetrahedronBufferGeometry": s = new Pr[o.type](o.radius, o.detail); break; case "RingGeometry": case "RingBufferGeometry": s = new Pr[o.type](o.innerRadius, o.outerRadius, o.thetaSegments, o.phiSegments, o.thetaStart, o.thetaLength); break; case "TorusGeometry": case "TorusBufferGeometry": s = new Pr[o.type](o.radius, o.tube, o.radialSegments, o.tubularSegments, o.arc); break; case "TorusKnotGeometry": case "TorusKnotBufferGeometry": s = new Pr[o.type](o.radius, o.tube, o.tubularSegments, o.radialSegments, o.p, o.q); break; case "TubeGeometry": case "TubeBufferGeometry": s = new Pr[o.type]((new La[o.path.type]).fromJSON(o.path), o.tubularSegments, o.radius, o.radialSegments, o.closed); break; case "LatheGeometry": case "LatheBufferGeometry": s = new Pr[o.type](o.points, o.segments, o.phiStart, o.phiLength); break; case "PolyhedronGeometry": case "PolyhedronBufferGeometry": s = new Pr[o.type](o.vertices, o.indices, o.radius, o.details); break; case "ShapeGeometry": case "ShapeBufferGeometry": for (var l = [], c = 0, h = o.shapes.length; c < h; c++) { var u = t[o.shapes[c]]; l.push(u) } s = new Pr[o.type](l, o.curveSegments); break; case "ExtrudeGeometry": case "ExtrudeBufferGeometry": for (l = [], c = 0, h = o.shapes.length; c < h; c++) { u = t[o.shapes[c]]; l.push(u) } var d = o.options.extrudePath; void 0 !== d && (o.options.extrudePath = (new La[d.type]).fromJSON(d)), s = new Pr[o.type](l, o.options); break; case "BufferGeometry": case "InstancedBufferGeometry": s = n.parse(o); break; case "Geometry": if ("THREE" in window && "LegacyJSONLoader" in THREE) s = (new THREE.LegacyJSONLoader).parse(o, this.resourcePath).geometry; else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'); break; default: console.warn('THREE.ObjectLoader: Unsupported geometry type "' + o.type + '"'); continue }s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), !0 === s.isBufferGeometry && void 0 !== o.userData && (s.userData = o.userData), i[o.uuid] = s } return i }, parseMaterials: function (e, t) { var i = {}, n = {}; if (void 0 !== e) { var r = new Wa; r.setTextures(t); for (var a = 0, s = e.length; a < s; a++) { var o = e[a]; if ("MultiMaterial" === o.type) { for (var l = [], c = 0; c < o.materials.length; c++) { var h = o.materials[c]; void 0 === i[h.uuid] && (i[h.uuid] = r.parse(h)), l.push(i[h.uuid]) } n[o.uuid] = l } else void 0 === i[o.uuid] && (i[o.uuid] = r.parse(o)), n[o.uuid] = i[o.uuid] } } return n }, parseAnimations: function (e) { for (var t = [], i = 0; i < e.length; i++) { var n = e[i], r = ea.parse(n); void 0 !== n.uuid && (r.uuid = n.uuid), t.push(r) } return t }, parseImages: function (e, t) { var i = this, n = {}; function r(e) { return i.manager.itemStart(e), a.load(e, (function () { i.manager.itemEnd(e) }), void 0, (function () { i.manager.itemError(e), i.manager.itemEnd(e) })) } if (void 0 !== e && e.length > 0) { var a = new la(new na(t)); a.setCrossOrigin(this.crossOrigin); for (var s = 0, o = e.length; s < o; s++) { var l = e[s], c = l.url; if (Array.isArray(c)) { n[l.uuid] = []; for (var h = 0, u = c.length; h < u; h++) { var d = c[h], p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : i.resourcePath + d; n[l.uuid].push(r(p)) } } else { p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : i.resourcePath + l.url; n[l.uuid] = r(p) } } } return n }, parseTextures: function (e, t) { function i(e, t) { return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]) } var n = {}; if (void 0 !== e) for (var r = 0, a = e.length; r < a; r++) { var s, o = e[r]; void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === t[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image), (s = Array.isArray(t[o.image]) ? new ot(t[o.image]) : new A(t[o.image])).needsUpdate = !0, s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), void 0 !== o.mapping && (s.mapping = i(o.mapping, rs)), void 0 !== o.offset && s.offset.fromArray(o.offset), void 0 !== o.repeat && s.repeat.fromArray(o.repeat), void 0 !== o.center && s.center.fromArray(o.center), void 0 !== o.rotation && (s.rotation = o.rotation), void 0 !== o.wrap && (s.wrapS = i(o.wrap[0], as), s.wrapT = i(o.wrap[1], as)), void 0 !== o.format && (s.format = o.format), void 0 !== o.type && (s.type = o.type), void 0 !== o.encoding && (s.encoding = o.encoding), void 0 !== o.minFilter && (s.minFilter = i(o.minFilter, ss)), void 0 !== o.magFilter && (s.magFilter = i(o.magFilter, ss)), void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy), void 0 !== o.flipY && (s.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (s.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (s.unpackAlignment = o.unpackAlignment), n[o.uuid] = s } return n }, parseObject: function (e, t, i) { var n; function r(e) { return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e] } function a(e) { if (void 0 !== e) { if (Array.isArray(e)) { for (var t = [], n = 0, r = e.length; n < r; n++) { var a = e[n]; void 0 === i[a] && console.warn("THREE.ObjectLoader: Undefined material", a), t.push(i[a]) } return t } return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined material", e), i[e] } } switch (e.type) { case "Scene": n = new Zi, void 0 !== e.background && Number.isInteger(e.background) && (n.background = new X(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? n.fog = new Ji(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (n.fog = new qi(e.fog.color, e.fog.density))); break; case "PerspectiveCamera": n = new Di(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (n.focus = e.focus), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.filmGauge && (n.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (n.filmOffset = e.filmOffset), void 0 !== e.view && (n.view = Object.assign({}, e.view)); break; case "OrthographicCamera": n = new Ga(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (n.zoom = e.zoom), void 0 !== e.view && (n.view = Object.assign({}, e.view)); break; case "AmbientLight": n = new Va(e.color, e.intensity); break; case "DirectionalLight": n = new Ha(e.color, e.intensity); break; case "PointLight": n = new Fa(e.color, e.intensity, e.distance, e.decay); break; case "RectAreaLight": n = new ja(e.color, e.intensity, e.width, e.height); break; case "SpotLight": n = new Ba(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break; case "HemisphereLight": n = new Da(e.color, e.groundColor, e.intensity); break; case "SkinnedMesh": console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."); case "Mesh": var s = r(e.geometry), o = a(e.material); n = s.bones && s.bones.length > 0 ? new rn(s, o) : new qe(s, o), void 0 !== e.drawMode && n.setDrawMode(e.drawMode); break; case "LOD": n = new nn; break; case "Line": n = new ln(r(e.geometry), a(e.material), e.mode); break; case "LineLoop": n = new hn(r(e.geometry), a(e.material)); break; case "LineSegments": n = new cn(r(e.geometry), a(e.material)); break; case "PointCloud": case "Points": n = new dn(r(e.geometry), a(e.material)); break; case "Sprite": n = new tn(a(e.material)); break; case "Group": n = new Ii; break; default: n = new le }if (n.uuid = e.uuid, void 0 !== e.name && (n.name = e.name), void 0 !== e.matrix ? (n.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (n.matrixAutoUpdate = e.matrixAutoUpdate), n.matrixAutoUpdate && n.matrix.decompose(n.position, n.quaternion, n.scale)) : (void 0 !== e.position && n.position.fromArray(e.position), void 0 !== e.rotation && n.rotation.fromArray(e.rotation), void 0 !== e.quaternion && n.quaternion.fromArray(e.quaternion), void 0 !== e.scale && n.scale.fromArray(e.scale)), void 0 !== e.castShadow && (n.castShadow = e.castShadow), void 0 !== e.receiveShadow && (n.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (n.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (n.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && n.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (n.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.frustumCulled && (n.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (n.renderOrder = e.renderOrder), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.layers && (n.layers.mask = e.layers), void 0 !== e.children) for (var l = e.children, c = 0; c < l.length; c++)n.add(this.parseObject(l[c], t, i)); if ("LOD" === e.type) for (var h = e.levels, u = 0; u < h.length; u++) { var d = h[u], p = n.getObjectByProperty("uuid", d.object); void 0 !== p && n.addLevel(p, d.distance) } return n } }); var Qa, es, ts, is, ns, rs = { UVMapping: 300, CubeReflectionMapping: 301, CubeRefractionMapping: 302, EquirectangularReflectionMapping: 303, EquirectangularRefractionMapping: 304, SphericalReflectionMapping: 305, CubeUVReflectionMapping: 306, CubeUVRefractionMapping: 307 }, as = { RepeatWrapping: 1e3, ClampToEdgeWrapping: 1001, MirroredRepeatWrapping: 1002 }, ss = { NearestFilter: 1003, NearestMipMapNearestFilter: 1004, NearestMipMapLinearFilter: 1005, LinearFilter: 1006, LinearMipMapNearestFilter: 1007, LinearMipMapLinearFilter: 1008 }; function os(e) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e ? e : ra, this.options = void 0 } function ls() { this.type = "ShapePath", this.color = new X, this.subPaths = [], this.currentPath = null } function cs(e) { this.type = "Font", this.data = e } function hs(e, t, i, n, r) { var a = r.glyphs[e] || r.glyphs["?"]; if (a) { var s, o, l, c, h, u, d, p, f = new ls; if (a.o) for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), g = 0, v = m.length; g < v;) { switch (m[g++]) { case "m": s = m[g++] * t + i, o = m[g++] * t + n, f.moveTo(s, o); break; case "l": s = m[g++] * t + i, o = m[g++] * t + n, f.lineTo(s, o); break; case "q": l = m[g++] * t + i, c = m[g++] * t + n, h = m[g++] * t + i, u = m[g++] * t + n, f.quadraticCurveTo(h, u, l, c); break; case "b": l = m[g++] * t + i, c = m[g++] * t + n, h = m[g++] * t + i, u = m[g++] * t + n, d = m[g++] * t + i, p = m[g++] * t + n, f.bezierCurveTo(h, u, d, p, l, c) } } return { offsetX: a.ha * t, path: f } } } function us() { } os.prototype = { constructor: os, setOptions: function (e) { return this.options = e, this }, load: function (e, t, i, n) { void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e); var r = this, a = ia.get(e); if (void 0 !== a) return r.manager.itemStart(e), setTimeout((function () { t && t(a), r.manager.itemEnd(e) }), 0), a; fetch(e).then((function (e) { return e.blob() })).then((function (e) { return void 0 === r.options ? createImageBitmap(e) : createImageBitmap(e, r.options) })).then((function (i) { ia.add(e, i), t && t(i), r.manager.itemEnd(e) })).catch((function (t) { n && n(t), r.manager.itemError(e), r.manager.itemEnd(e) })), r.manager.itemStart(e) }, setCrossOrigin: function () { return this }, setPath: function (e) { return this.path = e, this } }, Object.assign(ls.prototype, { moveTo: function (e, t) { this.currentPath = new Oa, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t) }, lineTo: function (e, t) { this.currentPath.lineTo(e, t) }, quadraticCurveTo: function (e, t, i, n) { this.currentPath.quadraticCurveTo(e, t, i, n) }, bezierCurveTo: function (e, t, i, n, r, a) { this.currentPath.bezierCurveTo(e, t, i, n, r, a) }, splineThru: function (e) { this.currentPath.splineThru(e) }, toShapes: function (e, t) { function i(e) { for (var t = [], i = 0, n = e.length; i < n; i++) { var r = e[i], a = new Ia; a.curves = r.curves, t.push(a) } return t } function n(e, t) { for (var i = t.length, n = !1, r = i - 1, a = 0; a < i; r = a++) { var s = t[r], o = t[a], l = o.x - s.x, c = o.y - s.y; if (Math.abs(c) > Number.EPSILON) { if (c < 0 && (s = t[a], l = -l, o = t[r], c = -c), e.y < s.y || e.y > o.y) continue; if (e.y === s.y) { if (e.x === s.x) return !0 } else { var h = c * (e.x - s.x) - l * (e.y - s.y); if (0 === h) return !0; if (h < 0) continue; n = !n } } else { if (e.y !== s.y) continue; if (o.x <= e.x && e.x <= s.x || s.x <= e.x && e.x <= o.x) return !0 } } return n } var r = rr.isClockWise, a = this.subPaths; if (0 === a.length) return []; if (!0 === t) return i(a); var s, o, l, c = []; if (1 === a.length) return o = a[0], (l = new Ia).curves = o.curves, c.push(l), c; var h = !r(a[0].getPoints()); h = e ? !h : h; var u, d, p = [], f = [], m = [], g = 0; f[g] = void 0, m[g] = []; for (var v = 0, y = a.length; v < y; v++)s = r(u = (o = a[v]).getPoints()), (s = e ? !s : s) ? (!h && f[g] && g++, f[g] = { s: new Ia, p: u }, f[g].s.curves = o.curves, h && g++, m[g] = []) : m[g].push({ h: o, p: u[0] }); if (!f[0]) return i(a); if (f.length > 1) { for (var _ = !1, x = [], b = 0, w = f.length; b < w; b++)p[b] = []; for (b = 0, w = f.length; b < w; b++)for (var T = m[b], M = 0; M < T.length; M++) { for (var S = T[M], E = !0, C = 0; C < f.length; C++)n(S.p, f[C].p) && (b !== C && x.push({ froms: b, tos: C, hole: M }), E ? (E = !1, p[C].push(S)) : _ = !0); E && p[b].push(S) } x.length > 0 && (_ || (m = p)) } v = 0; for (var A = f.length; v < A; v++) { l = f[v].s, c.push(l); for (var P = 0, L = (d = m[v]).length; P < L; P++)l.holes.push(d[P].h) } return c } }), Object.assign(cs.prototype, { isFont: !0, generateShapes: function (e, t) { void 0 === t && (t = 100); for (var i = [], n = function (e, t, i) { for (var n = Array.from ? Array.from(e) : String(e).split(""), r = t / i.resolution, a = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, s = [], o = 0, l = 0, c = 0; c < n.length; c++) { var h = n[c]; if ("\n" === h) o = 0, l -= a; else { var u = hs(h, r, o, l, i); o += u.offsetX, s.push(u.path) } } return s }(e, t, this.data), r = 0, a = n.length; r < a; r++)Array.prototype.push.apply(i, n[r].toShapes()); return i } }), Object.assign(function (e) { this.manager = void 0 !== e ? e : ra }.prototype, { load: function (e, t, i, n) { var r = this, a = new sa(this.manager); a.setPath(this.path), a.load(e, (function (e) { var i; try { i = JSON.parse(e) } catch (t) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(e.substring(65, e.length - 2)) } var n = r.parse(i); t && t(n) }), i, n) }, parse: function (e) { return new cs(e) }, setPath: function (e) { return this.path = e, this } }), us.Handlers = { handlers: [], add: function (e, t) { this.handlers.push(e, t) }, get: function (e) { for (var t = this.handlers, i = 0, n = t.length; i < n; i += 2) { var r = t[i], a = t[i + 1]; if (r.test(e)) return a } return null } }, Object.assign(us.prototype, { crossOrigin: "anonymous", onLoadStart: function () { }, onLoadProgress: function () { }, onLoadComplete: function () { }, initMaterials: function (e, t, i) { for (var n = [], r = 0; r < e.length; ++r)n[r] = this.createMaterial(e[r], t, i); return n }, createMaterial: (Qa = { NoBlending: 0, NormalBlending: 1, AdditiveBlending: 2, SubtractiveBlending: 3, MultiplyBlending: 4, CustomBlending: 5 }, es = new X, ts = new ha, is = new Wa, function (e, t, i) { var n = {}; function r(e, r, a, s, l) { var c, h = t + e, u = us.Handlers.get(h); null !== u ? c = u.load(h) : (ts.setCrossOrigin(i), c = ts.load(h)), void 0 !== r && (c.repeat.fromArray(r), 1 !== r[0] && (c.wrapS = 1e3), 1 !== r[1] && (c.wrapT = 1e3)), void 0 !== a && c.offset.fromArray(a), void 0 !== s && ("repeat" === s[0] && (c.wrapS = 1e3), "mirror" === s[0] && (c.wrapS = 1002), "repeat" === s[1] && (c.wrapT = 1e3), "mirror" === s[1] && (c.wrapT = 1002)), void 0 !== l && (c.anisotropy = l); var d = o.generateUUID(); return n[d] = c, d } var a = { uuid: o.generateUUID(), type: "MeshLambertMaterial" }; for (var s in e) { var l = e[s]; switch (s) { case "DbgColor": case "DbgIndex": case "opticalDensity": case "illumination": break; case "DbgName": a.name = l; break; case "blending": a.blending = Qa[l]; break; case "colorAmbient": case "mapAmbient": console.warn("THREE.Loader.createMaterial:", s, "is no longer supported."); break; case "colorDiffuse": a.color = es.fromArray(l).getHex(); break; case "colorSpecular": a.specular = es.fromArray(l).getHex(); break; case "colorEmissive": a.emissive = es.fromArray(l).getHex(); break; case "specularCoef": a.shininess = l; break; case "shading": "basic" === l.toLowerCase() && (a.type = "MeshBasicMaterial"), "phong" === l.toLowerCase() && (a.type = "MeshPhongMaterial"), "standard" === l.toLowerCase() && (a.type = "MeshStandardMaterial"); break; case "mapDiffuse": a.map = r(l, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy); break; case "mapDiffuseRepeat": case "mapDiffuseOffset": case "mapDiffuseWrap": case "mapDiffuseAnisotropy": break; case "mapEmissive": a.emissiveMap = r(l, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy); break; case "mapEmissiveRepeat": case "mapEmissiveOffset": case "mapEmissiveWrap": case "mapEmissiveAnisotropy": break; case "mapLight": a.lightMap = r(l, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy); break; case "mapLightRepeat": case "mapLightOffset": case "mapLightWrap": case "mapLightAnisotropy": break; case "mapAO": a.aoMap = r(l, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy); break; case "mapAORepeat": case "mapAOOffset": case "mapAOWrap": case "mapAOAnisotropy": break; case "mapBump": a.bumpMap = r(l, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy); break; case "mapBumpScale": a.bumpScale = l; break; case "mapBumpRepeat": case "mapBumpOffset": case "mapBumpWrap": case "mapBumpAnisotropy": break; case "mapNormal": a.normalMap = r(l, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy); break; case "mapNormalFactor": a.normalScale = l; break; case "mapNormalRepeat": case "mapNormalOffset": case "mapNormalWrap": case "mapNormalAnisotropy": break; case "mapSpecular": a.specularMap = r(l, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy); break; case "mapSpecularRepeat": case "mapSpecularOffset": case "mapSpecularWrap": case "mapSpecularAnisotropy": break; case "mapMetalness": a.metalnessMap = r(l, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy); break; case "mapMetalnessRepeat": case "mapMetalnessOffset": case "mapMetalnessWrap": case "mapMetalnessAnisotropy": break; case "mapRoughness": a.roughnessMap = r(l, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy); break; case "mapRoughnessRepeat": case "mapRoughnessOffset": case "mapRoughnessWrap": case "mapRoughnessAnisotropy": break; case "mapAlpha": a.alphaMap = r(l, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy); break; case "mapAlphaRepeat": case "mapAlphaOffset": case "mapAlphaWrap": case "mapAlphaAnisotropy": break; case "flipSided": a.side = 1; break; case "doubleSided": a.side = 2; break; case "transparency": console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), a.opacity = l; break; case "depthTest": case "depthWrite": case "colorWrite": case "opacity": case "reflectivity": case "transparent": case "visible": case "wireframe": a[s] = l; break; case "vertexColors": !0 === l && (a.vertexColors = 2), "face" === l && (a.vertexColors = 1); break; default: console.error("THREE.Loader.createMaterial: Unsupported", s, l) } } return "MeshBasicMaterial" === a.type && delete a.emissive, "MeshPhongMaterial" !== a.type && delete a.specular, a.opacity < 1 && (a.transparent = !0), is.setTextures(n), is.parse(a) }) }); var ds = function () { return void 0 === ns && (ns = new (window.AudioContext || window.webkitAudioContext)), ns }; function ps(e) { this.manager = void 0 !== e ? e : ra } function fs() { this.coefficients = []; for (var e = 0; e < 9; e++)this.coefficients.push(new h) } function ms(e, t) { ka.call(this, void 0, t), this.sh = void 0 !== e ? e : new fs } function gs(e, t, i) { ms.call(this, void 0, i); var n = (new X).set(e), r = (new X).set(t), a = new h(n.r, n.g, n.b), s = new h(r.r, r.g, r.b), o = Math.sqrt(Math.PI), l = o * Math.sqrt(.75); this.sh.coefficients[0].copy(a).add(s).multiplyScalar(o), this.sh.coefficients[1].copy(a).sub(s).multiplyScalar(l) } function vs(e, t) { ms.call(this, void 0, t); var i = (new X).set(e); this.sh.coefficients[0].set(i.r, i.g, i.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } Object.assign(ps.prototype, { load: function (e, t, i, n) { var r = new sa(this.manager); r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(e, (function (e) { var i = e.slice(0); ds().decodeAudioData(i, (function (e) { t(e) })) }), i, n) }, setPath: function (e) { return this.path = e, this } }), Object.assign(fs.prototype, { isSphericalHarmonics3: !0, set: function (e) { for (var t = 0; t < 9; t++)this.coefficients[t].copy(e[t]); return this }, zero: function () { for (var e = 0; e < 9; e++)this.coefficients[e].set(0, 0, 0); return this }, getAt: function (e, t) { var i = e.x, n = e.y, r = e.z, a = this.coefficients; return t = .282095 * a[0], t += .488603 * a[1] * n, t += .488603 * a[2] * r, t += .488603 * a[3] * i, t += 1.092548 * a[4] * (i * n), t += 1.092548 * a[5] * (n * r), t += .315392 * a[6] * (3 * r * r - 1), t += 1.092548 * a[7] * (i * r), t += .546274 * a[8] * (i * i - n * n) }, getIrradianceAt: function (e, t) { var i = e.x, n = e.y, r = e.z, a = this.coefficients; return t = .886227 * a[0], t += 2 * a[1] * .511664 * n, t += 2 * a[2] * .511664 * r, t += 2 * a[3] * .511664 * i, t += 2 * a[4] * .429043 * i * n, t += 2 * a[5] * .429043 * n * r, t += a[6] * (.743125 * r * r - .247708), t += 2 * a[7] * .429043 * i * r, t += .429043 * a[8] * (i * i - n * n) }, add: function (e) { for (var t = 0; t < 9; t++)this.coefficients[t].add(e.coefficients[t]); return this }, scale: function (e) { for (var t = 0; t < 9; t++)this.coefficients[t].multiplyScalar(e); return this }, lerp: function (e, t) { for (var i = 0; i < 9; i++)this.coefficients[i].lerp(e.coefficients[i], t); return this }, equals: function (e) { for (var t = 0; t < 9; t++)if (!this.coefficients[t].equals(e.coefficients[t])) return !1; return !0 }, copy: function (e) { return this.set(e.coefficients) }, clone: function () { return (new this.constructor).copy(this) }, fromArray: function (e) { for (var t = this.coefficients, i = 0; i < 9; i++)t[i].fromArray(e, 3 * i); return this }, toArray: function () { for (var e = [], t = this.coefficients, i = 0; i < 9; i++)t[i].toArray(e, 3 * i); return e } }), Object.assign(fs, { getBasisAt: function (e, t) { var i = e.x, n = e.y, r = e.z; t[0] = .282095, t[1] = .488603 * n, t[2] = .488603 * r, t[3] = .488603 * i, t[4] = 1.092548 * i * n, t[5] = 1.092548 * n * r, t[6] = .315392 * (3 * r * r - 1), t[7] = 1.092548 * i * r, t[8] = .546274 * (i * i - n * n) } }), ms.prototype = Object.assign(Object.create(ka.prototype), { constructor: ms, isLightProbe: !0, copy: function (e) { return ka.prototype.copy.call(this, e), this.sh.copy(e.sh), this.intensity = e.intensity, this }, toJSON: function (e) { return ka.prototype.toJSON.call(this, e) } }), gs.prototype = Object.assign(Object.create(ms.prototype), { constructor: gs, isHemisphereLightProbe: !0, copy: function (e) { return ms.prototype.copy.call(this, e), this }, toJSON: function (e) { return ms.prototype.toJSON.call(this, e) } }), vs.prototype = Object.assign(Object.create(ms.prototype), { constructor: vs, isAmbientLightProbe: !0, copy: function (e) { return ms.prototype.copy.call(this, e), this }, toJSON: function (e) { return ms.prototype.toJSON.call(this, e) } }), Object.assign(function () { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Di, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Di, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1 }.prototype, { update: function () { var e, t, i, n, r, a, s, l, c = new B, h = new B; return function (u) { if (e !== this || t !== u.focus || i !== u.fov || n !== u.aspect * this.aspect || r !== u.near || a !== u.far || s !== u.zoom || l !== this.eyeSep) { e = this, t = u.focus, i = u.fov, n = u.aspect * this.aspect, r = u.near, a = u.far, s = u.zoom; var d, p, f = u.projectionMatrix.clone(), m = (l = this.eyeSep / 2) * r / t, g = r * Math.tan(o.DEG2RAD * i * .5) / s; h.elements[12] = -l, c.elements[12] = l, d = -g * n + m, p = g * n + m, f.elements[0] = 2 * r / (p - d), f.elements[8] = (p + d) / (p - d), this.cameraL.projectionMatrix.copy(f), d = -g * n - m, p = g * n - m, f.elements[0] = 2 * r / (p - d), f.elements[8] = (p + d) / (p - d), this.cameraR.projectionMatrix.copy(f) } this.cameraL.matrixWorld.copy(u.matrixWorld).multiply(h), this.cameraR.matrixWorld.copy(u.matrixWorld).multiply(c) } }() }); function ys(e, t, i, n) { le.call(this), this.type = "CubeCamera"; var r = new Di(90, 1, e, t); r.up.set(0, -1, 0), r.lookAt(new h(1, 0, 0)), this.add(r); var a = new Di(90, 1, e, t); a.up.set(0, -1, 0), a.lookAt(new h(-1, 0, 0)), this.add(a); var s = new Di(90, 1, e, t); s.up.set(0, 0, 1), s.lookAt(new h(0, 1, 0)), this.add(s); var o = new Di(90, 1, e, t); o.up.set(0, 0, -1), o.lookAt(new h(0, -1, 0)), this.add(o); var l = new Di(90, 1, e, t); l.up.set(0, -1, 0), l.lookAt(new h(0, 0, 1)), this.add(l); var c = new Di(90, 1, e, t); c.up.set(0, -1, 0), c.lookAt(new h(0, 0, -1)), this.add(c), n = n || { format: 1022, magFilter: 1006, minFilter: 1006 }, this.renderTarget = new O(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function (e, t) { null === this.parent && this.updateMatrixWorld(); var i = e.getRenderTarget(), n = this.renderTarget, h = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, r), e.setRenderTarget(n, 1), e.render(t, a), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, o), e.setRenderTarget(n, 4), e.render(t, l), n.texture.generateMipmaps = h, e.setRenderTarget(n, 5), e.render(t, c), e.setRenderTarget(i) }, this.clear = function (e, t, i, n) { for (var r = e.getRenderTarget(), a = this.renderTarget, s = 0; s < 6; s++)e.setRenderTarget(a, s), e.clear(t, i, n); e.setRenderTarget(r) } } function _s(e) { this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } function xs() { le.call(this), this.type = "AudioListener", this.context = ds(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0 } function bs(e) { le.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [] } function ws(e) { bs.call(this, e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } function Ts(e, t) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) } function Ms(e, t, i) { this.binding = e, this.valueSize = i; var n, r = Float64Array; switch (t) { case "quaternion": n = this._slerp; break; case "string": case "bool": r = Array, n = this._select; break; default: n = this._lerp }this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0 } ys.prototype = Object.create(le.prototype), ys.prototype.constructor = ys, Object.assign(_s.prototype, { start: function () { this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 }, stop: function () { this.getElapsedTime(), this.running = !1, this.autoStart = !1 }, getElapsedTime: function () { return this.getDelta(), this.elapsedTime }, getDelta: function () { var e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { var t = ("undefined" == typeof performance ? Date : performance).now(); e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } }), xs.prototype = Object.assign(Object.create(le.prototype), { constructor: xs, getInput: function () { return this.gain }, removeFilter: function () { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this }, getFilter: function () { return this.filter }, setFilter: function (e) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this }, getMasterVolume: function () { return this.gain.gain.value }, setMasterVolume: function (e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this }, updateMatrixWorld: function () { var e = new h, t = new c, i = new h, n = new h, r = new _s; return function (a) { le.prototype.updateMatrixWorld.call(this, a); var s = this.context.listener, o = this.up; if (this.timeDelta = r.getDelta(), this.matrixWorld.decompose(e, t, i), n.set(0, 0, -1).applyQuaternion(t), s.positionX) { var l = this.context.currentTime + this.timeDelta; s.positionX.linearRampToValueAtTime(e.x, l), s.positionY.linearRampToValueAtTime(e.y, l), s.positionZ.linearRampToValueAtTime(e.z, l), s.forwardX.linearRampToValueAtTime(n.x, l), s.forwardY.linearRampToValueAtTime(n.y, l), s.forwardZ.linearRampToValueAtTime(n.z, l), s.upX.linearRampToValueAtTime(o.x, l), s.upY.linearRampToValueAtTime(o.y, l), s.upZ.linearRampToValueAtTime(o.z, l) } else s.setPosition(e.x, e.y, e.z), s.setOrientation(n.x, n.y, n.z, o.x, o.y, o.z) } }() }), bs.prototype = Object.assign(Object.create(le.prototype), { constructor: bs, getOutput: function () { return this.gain }, setNodeSource: function (e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this }, setMediaElementSource: function (e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this }, setBuffer: function (e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this }, play: function () { if (!0 !== this.isPlaying) { if (!1 !== this.hasPlaybackControl) { var e = this.context.createBufferSource(); return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } console.warn("THREE.Audio: this Audio has no playback control.") } else console.warn("THREE.Audio: Audio is already playing.") }, pause: function () { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") }, stop: function () { if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") }, connect: function () { if (this.filters.length > 0) { this.source.connect(this.filters[0]); for (var e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].connect(this.filters[e]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this }, disconnect: function () { if (this.filters.length > 0) { this.source.disconnect(this.filters[0]); for (var e = 1, t = this.filters.length; e < t; e++)this.filters[e - 1].disconnect(this.filters[e]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function () { return this.filters }, setFilters: function (e) { return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this }, setDetune: function (e) { if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }, getDetune: function () { return this.detune }, getFilter: function () { return this.getFilters()[0] }, setFilter: function (e) { return this.setFilters(e ? [e] : []) }, setPlaybackRate: function (e) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") }, getPlaybackRate: function () { return this.playbackRate }, onEnded: function () { this.isPlaying = !1 }, getLoop: function () { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }, setLoop: function (e) { if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") }, getVolume: function () { return this.gain.gain.value }, setVolume: function (e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } }), ws.prototype = Object.assign(Object.create(bs.prototype), { constructor: ws, getOutput: function () { return this.panner }, getRefDistance: function () { return this.panner.refDistance }, setRefDistance: function (e) { return this.panner.refDistance = e, this }, getRolloffFactor: function () { return this.panner.rolloffFactor }, setRolloffFactor: function (e) { return this.panner.rolloffFactor = e, this }, getDistanceModel: function () { return this.panner.distanceModel }, setDistanceModel: function (e) { return this.panner.distanceModel = e, this }, getMaxDistance: function () { return this.panner.maxDistance }, setMaxDistance: function (e) { return this.panner.maxDistance = e, this }, setDirectionalCone: function (e, t, i) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this }, updateMatrixWorld: function () { var e = new h, t = new c, i = new h, n = new h; return function (r) { if (le.prototype.updateMatrixWorld.call(this, r), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) { this.matrixWorld.decompose(e, t, i), n.set(0, 0, 1).applyQuaternion(t); var a = this.panner; if (a.positionX) { var s = this.context.currentTime + this.listener.timeDelta; a.positionX.linearRampToValueAtTime(e.x, s), a.positionY.linearRampToValueAtTime(e.y, s), a.positionZ.linearRampToValueAtTime(e.z, s), a.orientationX.linearRampToValueAtTime(n.x, s), a.orientationY.linearRampToValueAtTime(n.y, s), a.orientationZ.linearRampToValueAtTime(n.z, s) } else a.setPosition(e.x, e.y, e.z), a.setOrientation(n.x, n.y, n.z) } } }() }), Object.assign(Ts.prototype, { getFrequencyData: function () { return this.analyser.getByteFrequencyData(this.data), this.data }, getAverageFrequency: function () { for (var e = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++)e += t[i]; return e / t.length } }), Object.assign(Ms.prototype, { accumulate: function (e, t) { var i = this.buffer, n = this.valueSize, r = e * n + n, a = this.cumulativeWeight; if (0 === a) { for (var s = 0; s !== n; ++s)i[r + s] = i[s]; a = t } else { var o = t / (a += t); this._mixBufferRegion(i, r, 0, o, n) } this.cumulativeWeight = a }, apply: function (e) { var t = this.valueSize, i = this.buffer, n = e * t + t, r = this.cumulativeWeight, a = this.binding; if (this.cumulativeWeight = 0, r < 1) { var s = 3 * t; this._mixBufferRegion(i, n, s, 1 - r, t) } for (var o = t, l = t + t; o !== l; ++o)if (i[o] !== i[o + t]) { a.setValue(i, n); break } }, saveOriginalState: function () { var e = this.binding, t = this.buffer, i = this.valueSize, n = 3 * i; e.getValue(t, n); for (var r = i, a = n; r !== a; ++r)t[r] = t[n + r % i]; this.cumulativeWeight = 0 }, restoreOriginalState: function () { var e = 3 * this.valueSize; this.binding.setValue(this.buffer, e) }, _select: function (e, t, i, n, r) { if (n >= .5) for (var a = 0; a !== r; ++a)e[t + a] = e[i + a] }, _slerp: function (e, t, i, n) { c.slerpFlat(e, t, e, t, e, i, n) }, _lerp: function (e, t, i, n, r) { for (var a = 1 - n, s = 0; s !== r; ++s) { var o = t + s; e[o] = e[o] * a + e[i + s] * n } } }); var Ss, Es, Cs, As, Ps, Ls, Rs, Os, Is, ks, Ds, zs, Ns, Bs; function Fs(e, t, i) { var n = i || Gs.parseTrackName(t); this._targetGroup = e, this._bindings = e.subscribe_(t, n) } function Gs(e, t, i) { this.path = t, this.parsedPath = i || Gs.parseTrackName(t), this.node = Gs.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e } function Us(e, t, i) { this._mixer = e, this._clip = t, this._localRoot = i || null; for (var n = t.tracks, r = n.length, a = new Array(r), s = { endingStart: 2400, endingEnd: 2400 }, o = 0; o !== r; ++o) { var l = n[o].createInterpolant(null); a[o] = l, l.settings = s } this._interpolantSettings = s, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } function Hs(e) { this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } function Vs(e) { "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e } function js(e, t, i) { Ki.call(this, e, t), this.meshPerAttribute = i || 1 } function Ws(e, t) { return e.distance - t.distance } function $s(e, t, i, n) { if (!1 !== e.visible && (e.raycast(t, i), !0 === n)) for (var r = e.children, a = 0, s = r.length; a < s; a++)$s(r[a], t, i, !0) } function Xs(e, t) { this.min = void 0 !== e ? e : new l(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new l(-1 / 0, -1 / 0) } function Ys(e, t) { this.start = void 0 !== e ? e : new h, this.end = void 0 !== t ? t : new h } function qs(e) { le.call(this), this.material = e, this.render = function () { } } function Js(e, t, i, n) { this.object = e, this.size = void 0 !== t ? t : 1; var r = void 0 !== i ? i : 16711680, a = void 0 !== n ? n : 1, s = 0, o = this.object.geometry; o && o.isGeometry ? s = 3 * o.faces.length : o && o.isBufferGeometry && (s = o.attributes.normal.count); var l = new Ee, c = new be(2 * s * 3, 3); l.addAttribute("position", c), cn.call(this, l, new on({ color: r, linewidth: a })), this.matrixAutoUpdate = !1, this.update() } function Zs(e, t) { le.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t; for (var i = new Ee, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, a = 1; r < 32; r++, a++) { var s = r / 32 * Math.PI * 2, o = a / 32 * Math.PI * 2; n.push(Math.cos(s), Math.sin(s), 1, Math.cos(o), Math.sin(o), 1) } i.addAttribute("position", new be(n, 3)); var l = new on({ fog: !1 }); this.cone = new cn(i, l), this.add(this.cone), this.update() } function Ks(e) { for (var t = function e(t) { var i = []; t && t.isBone && i.push(t); for (var n = 0; n < t.children.length; n++)i.push.apply(i, e(t.children[n])); return i }(e), i = new Ee, n = [], r = [], a = new X(0, 0, 1), s = new X(0, 1, 0), o = 0; o < t.length; o++) { var l = t[o]; l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(s.r, s.g, s.b)) } i.addAttribute("position", new be(n, 3)), i.addAttribute("color", new be(r, 3)); var c = new on({ vertexColors: 2, depthTest: !1, depthWrite: !1, transparent: !0 }); cn.call(this, i, c), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 } function Qs(e, t, i) { this.light = e, this.light.updateMatrixWorld(), this.color = i; var n = new fr(t, 4, 2), r = new Ye({ wireframe: !0, fog: !1 }); qe.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } function eo(e, t) { this.type = "RectAreaLightHelper", this.light = e, this.color = t; var i = new Ee; i.addAttribute("position", new be([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), i.computeBoundingSphere(); var n = new on({ fog: !1 }); ln.call(this, i, n); var r = new Ee; r.addAttribute("position", new be([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), r.computeBoundingSphere(), this.add(new qe(r, new Ye({ side: 1, fog: !1 }))), this.update() } function to(e, t, i) { le.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i; var n = new Sn(t); n.rotateY(.5 * Math.PI), this.material = new Ye({ wireframe: !0, fog: !1 }), void 0 === this.color && (this.material.vertexColors = 2); var r = n.getAttribute("position"), a = new Float32Array(3 * r.count); n.addAttribute("color", new pe(a, 3)), this.add(new qe(n, this.material)), this.update() } function io(e, t) { this.lightProbe = e, this.size = t; var i = { GAMMA_OUTPUT: "" }, n = new We({ defines: i, uniforms: { sh: { value: this.lightProbe.sh.coefficients }, intensity: { value: this.lightProbe.intensity } }, vertexShader: ["varying vec3 vNormal;", "void main() {", "\tvNormal = normalize( normalMatrix * normal );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"), fragmentShader: ["#define RECIPROCAL_PI 0.318309886", "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {", "\t// matrix is assumed to be orthogonal", "\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );", "}", "vec3 linearToOutput( in vec3 a ) {", "\t#ifdef GAMMA_OUTPUT", "\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );", "\t#else", "\t\treturn a;", "\t#endif", "}", "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf", "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {", "\t// normal is assumed to have unit length", "\tfloat x = normal.x, y = normal.y, z = normal.z;", "\t// band 0", "\tvec3 result = shCoefficients[ 0 ] * 0.886227;", "\t// band 1", "\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;", "\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;", "\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;", "\t// band 2", "\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;", "\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;", "\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );", "\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;", "\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );", "\treturn result;", "}", "uniform vec3 sh[ 9 ]; // sh coefficients", "uniform float intensity; // light probe intensity", "varying vec3 vNormal;", "void main() {", "\tvec3 normal = normalize( vNormal );", "\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", "\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );", "\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;", "\toutgoingLight = linearToOutput( outgoingLight );", "\tgl_FragColor = vec4( outgoingLight, 1.0 );", "}"].join("\n") }), r = new fr(1, 32, 16); qe.call(this, r, n), this.onBeforeRender() } function no(e, t, i, n) { e = e || 10, t = t || 10, i = new X(void 0 !== i ? i : 4473924), n = new X(void 0 !== n ? n : 8947848); for (var r = t / 2, a = e / t, s = e / 2, o = [], l = [], c = 0, h = 0, u = -s; c <= t; c++, u += a) { o.push(-s, 0, u, s, 0, u), o.push(u, 0, -s, u, 0, s); var d = c === r ? i : n; d.toArray(l, h), h += 3, d.toArray(l, h), h += 3, d.toArray(l, h), h += 3, d.toArray(l, h), h += 3 } var p = new Ee; p.addAttribute("position", new be(o, 3)), p.addAttribute("color", new be(l, 3)); var f = new on({ vertexColors: 2 }); cn.call(this, p, f) } function ro(e, t, i, n, r, a) { e = e || 10, t = t || 16, i = i || 8, n = n || 64, r = new X(void 0 !== r ? r : 4473924), a = new X(void 0 !== a ? a : 8947848); var s, o, l, c, h, u, d, p = [], f = []; for (c = 0; c <= t; c++)l = c / t * (2 * Math.PI), s = Math.sin(l) * e, o = Math.cos(l) * e, p.push(0, 0, 0), p.push(s, 0, o), d = 1 & c ? r : a, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b); for (c = 0; c <= i; c++)for (d = 1 & c ? r : a, u = e - e / i * c, h = 0; h < n; h++)l = h / n * (2 * Math.PI), s = Math.sin(l) * u, o = Math.cos(l) * u, p.push(s, 0, o), f.push(d.r, d.g, d.b), l = (h + 1) / n * (2 * Math.PI), s = Math.sin(l) * u, o = Math.cos(l) * u, p.push(s, 0, o), f.push(d.r, d.g, d.b); var m = new Ee; m.addAttribute("position", new be(p, 3)), m.addAttribute("color", new be(f, 3)); var g = new on({ vertexColors: 2 }); cn.call(this, m, g) } function ao(e, t, i, n) { this.audio = e, this.range = t || 1, this.divisionsInnerAngle = i || 16, this.divisionsOuterAngle = n || 2; var r = new Ee, a = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle, s = new Float32Array(3 * (3 * a + 3)); r.addAttribute("position", new pe(s, 3)); var o = new on({ color: 65280 }), l = new on({ color: 16776960 }); ln.call(this, r, [l, o]), this.update() } function so(e, t, i, n) { this.object = e, this.size = void 0 !== t ? t : 1; var r = void 0 !== i ? i : 16776960, a = void 0 !== n ? n : 1, s = 0, o = this.object.geometry; o && o.isGeometry ? s = o.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."); var l = new Ee, c = new be(2 * s * 3, 3); l.addAttribute("position", c), cn.call(this, l, new on({ color: r, linewidth: a })), this.matrixAutoUpdate = !1, this.update() } function oo(e, t, i) { le.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === t && (t = 1); var n = new Ee; n.addAttribute("position", new be([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); var r = new on({ fog: !1 }); this.lightPlane = new ln(n, r), this.add(this.lightPlane), (n = new Ee).addAttribute("position", new be([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ln(n, r), this.add(this.targetLine), this.update() } function lo(e) { var t = new Ee, i = new on({ color: 16777215, vertexColors: 1 }), n = [], r = [], a = {}, s = new X(16755200), o = new X(16711680), l = new X(43775), c = new X(16777215), h = new X(3355443); function u(e, t, i) { d(e, i), d(t, i) } function d(e, t) { n.push(0, 0, 0), r.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(n.length / 3 - 1) } u("n1", "n2", s), u("n2", "n4", s), u("n4", "n3", s), u("n3", "n1", s), u("f1", "f2", s), u("f2", "f4", s), u("f4", "f3", s), u("f3", "f1", s), u("n1", "f1", s), u("n2", "f2", s), u("n3", "f3", s), u("n4", "f4", s), u("p", "n1", o), u("p", "n2", o), u("p", "n3", o), u("p", "n4", o), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), t.addAttribute("position", new be(n, 3)), t.addAttribute("color", new be(r, 3)), cn.call(this, t, i), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update() } function co(e, t) { this.object = e, void 0 === t && (t = 16776960); var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), n = new Float32Array(24), r = new Ee; r.setIndex(new pe(i, 1)), r.addAttribute("position", new pe(n, 3)), cn.call(this, r, new on({ color: t })), this.matrixAutoUpdate = !1, this.update() } function ho(e, t) { this.type = "Box3Helper", this.box = e; var i = void 0 !== t ? t : 16776960, n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Ee; r.setIndex(new pe(n, 1)), r.addAttribute("position", new be([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), cn.call(this, r, new on({ color: i })), this.geometry.computeBoundingSphere() } function uo(e, t, i) { this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t; var n = void 0 !== i ? i : 16776960, r = new Ee; r.addAttribute("position", new be([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), ln.call(this, r, new on({ color: n })); var a = new Ee; a.addAttribute("position", new be([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new qe(a, new Ye({ color: n, opacity: .2, transparent: !0, depthWrite: !1 }))) } function po(e, t, i, n, r, a) { le.call(this), void 0 === e && (e = new h(0, 0, 1)), void 0 === t && (t = new h(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === r && (r = .2 * i), void 0 === a && (a = .2 * r), void 0 === Ds && ((Ds = new Ee).addAttribute("position", new be([0, 0, 0, 0, 1, 0], 3)), (zs = new Mr(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new ln(Ds, new on({ color: n })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new qe(zs, new Ye({ color: n })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, r, a) } function fo(e) { var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], i = new Ee; i.addAttribute("position", new be(t, 3)), i.addAttribute("color", new be([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)); var n = new on({ vertexColors: 2 }); cn.call(this, i, n) } Object.assign(Fs.prototype, { getValue: function (e, t) { this.bind(); var i = this._targetGroup.nCachedObjects_, n = this._bindings[i]; void 0 !== n && n.getValue(e, t) }, setValue: function (e, t) { for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)i[n].setValue(e, t) }, bind: function () { for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].bind() }, unbind: function () { for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)e[t].unbind() } }), Object.assign(Gs, { Composite: Fs, create: function (e, t, i) { return e && e.isAnimationObjectGroup ? new Gs.Composite(e, t, i) : new Gs(e, t, i) }, sanitizeNodeName: (Os = new RegExp("[\\[\\]\\.:\\/]", "g"), function (e) { return e.replace(/\s/g, "_").replace(Os, "") }), parseTrackName: (Ss = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", Es = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Cs = /(WCOD+)?/.source.replace("WCOD", Ss), As = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Ps = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), Ls = new RegExp("^" + Es + Cs + As + Ps + "$"), Rs = ["material", "materials", "bones"], function (e) { var t = Ls.exec(e); if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); var i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, n = i.nodeName && i.nodeName.lastIndexOf("."); if (void 0 !== n && -1 !== n) { var r = i.nodeName.substring(n + 1); -1 !== Rs.indexOf(r) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r) } if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return i }), findNode: function (e, t) { if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e; if (e.skeleton) { var i = e.skeleton.getBoneByName(t); if (void 0 !== i) return i } if (e.children) { var n = function (e) { for (var i = 0; i < e.length; i++) { var r = e[i]; if (r.name === t || r.uuid === t) return r; var a = n(r.children); if (a) return a } return null }, r = n(e.children); if (r) return r } return null } }), Object.assign(Gs.prototype, { _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (e, t) { e[t] = this.node[this.propertyName] }, function (e, t) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)e[t++] = i[n] }, function (e, t) { e[t] = this.resolvedProperty[this.propertyIndex] }, function (e, t) { this.resolvedProperty.toArray(e, t) }], SetterByBindingTypeAndVersioning: [[function (e, t) { this.targetObject[this.propertyName] = e[t] }, function (e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 }, function (e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (e, t) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)i[n] = e[t++] }, function (e, t) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)i[n] = e[t++]; this.targetObject.needsUpdate = !0 }, function (e, t) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)i[n] = e[t++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (e, t) { this.resolvedProperty[this.propertyIndex] = e[t] }, function (e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 }, function (e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (e, t) { this.resolvedProperty.fromArray(e, t) }, function (e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 }, function (e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 }]], getValue: function (e, t) { this.bind(), this.getValue(e, t) }, setValue: function (e, t) { this.bind(), this.setValue(e, t) }, bind: function () { var e = this.node, t = this.parsedPath, i = t.objectName, n = t.propertyName, r = t.propertyIndex; if (e || (e = Gs.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) { if (i) { var a = t.objectIndex; switch (i) { case "materials": if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); e = e.material.materials; break; case "bones": if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); e = e.skeleton.bones; for (var s = 0; s < e.length; s++)if (e[s].name === a) { a = s; break } break; default: if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); e = e[i] }if (void 0 !== a) { if (void 0 === e[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e); e = e[a] } } var o = e[n]; if (void 0 !== o) { var l = this.Versioning.None; this.targetObject = e, void 0 !== e.needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate); var c = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === n) { if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (e.geometry.isBufferGeometry) { if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); for (s = 0; s < this.node.geometry.morphAttributes.position.length; s++)if (e.geometry.morphAttributes.position[s].name === r) { r = s; break } } else { if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this); for (s = 0; s < this.node.geometry.morphTargets.length; s++)if (e.geometry.morphTargets[s].name === r) { r = s; break } } } c = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r } else void 0 !== o.fromArray && void 0 !== o.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (c = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n; this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l] } else { var h = t.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + n + " but it wasn't found.", e) } } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.") }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }),
            //!\ DECLARE ALIAS AFTER assign prototype !
            Object.assign(Gs.prototype, { _getValue_unbound: Gs.prototype.getValue, _setValue_unbound: Gs.prototype.setValue }), Object.assign(function () { this.uuid = o.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; var e = {}; this._indicesByUUID = e; for (var t = 0, i = arguments.length; t !== i; ++t)e[arguments[t].uuid] = t; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; var n = this; this.stats = { objects: { get total() { return n._objects.length }, get inUse() { return this.total - n.nCachedObjects_ } }, get bindingsPerObject() { return n._bindings.length } } }.prototype, { isAnimationObjectGroup: !0, add: function () { for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, a = this._parsedPaths, s = this._bindings, o = s.length, l = void 0, c = 0, h = arguments.length; c !== h; ++c) { var u = arguments[c], d = u.uuid, p = n[d]; if (void 0 === p) { p = t++, n[d] = p, e.push(u); for (var f = 0, m = o; f !== m; ++f)s[f].push(new Gs(u, r[f], a[f])) } else if (p < i) { l = e[p]; var g = --i, v = e[g]; n[v.uuid] = p, e[p] = v, n[d] = g, e[g] = u; for (f = 0, m = o; f !== m; ++f) { var y = s[f], _ = y[g], x = y[p]; y[p] = _, void 0 === x && (x = new Gs(u, r[f], a[f])), y[g] = x } } else e[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = i }, remove: function () { for (var e = this._objects, t = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, a = 0, s = arguments.length; a !== s; ++a) { var o = arguments[a], l = o.uuid, c = i[l]; if (void 0 !== c && c >= t) { var h = t++, u = e[h]; i[u.uuid] = c, e[c] = u, i[l] = h, e[h] = o; for (var d = 0, p = r; d !== p; ++d) { var f = n[d], m = f[h], g = f[c]; f[c] = m, f[h] = g } } } this.nCachedObjects_ = t }, uncache: function () { for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, a = r.length, s = 0, o = arguments.length; s !== o; ++s) { var l = arguments[s], c = l.uuid, h = n[c]; if (void 0 !== h) if (delete n[c], h < i) { var u = --i, d = e[u], p = e[y = --t]; n[d.uuid] = h, e[h] = d, n[p.uuid] = u, e[u] = p, e.pop(); for (var f = 0, m = a; f !== m; ++f) { var g = (_ = r[f])[u], v = _[y]; _[h] = g, _[u] = v, _.pop() } } else { var y; n[(p = e[y = --t]).uuid] = h, e[h] = p, e.pop(); for (f = 0, m = a; f !== m; ++f) { var _; (_ = r[f])[h] = _[y], _.pop() } } } this.nCachedObjects_ = i }, subscribe_: function (e, t) { var i = this._bindingsIndicesByPath, n = i[e], r = this._bindings; if (void 0 !== n) return r[n]; var a = this._paths, s = this._parsedPaths, o = this._objects, l = o.length, c = this.nCachedObjects_, h = new Array(l); n = r.length, i[e] = n, a.push(e), s.push(t), r.push(h); for (var u = c, d = o.length; u !== d; ++u) { var p = o[u]; h[u] = new Gs(p, e, t) } return h }, unsubscribe_: function (e) { var t = this._bindingsIndicesByPath, i = t[e]; if (void 0 !== i) { var n = this._paths, r = this._parsedPaths, a = this._bindings, s = a.length - 1, o = a[s]; t[e[s]] = i, a[i] = o, a.pop(), r[i] = r[s], r.pop(), n[i] = n[s], n.pop() } } }), Object.assign(Us.prototype, { play: function () { return this._mixer._activateAction(this), this }, stop: function () { return this._mixer._deactivateAction(this), this.reset() }, reset: function () { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }, isRunning: function () { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }, isScheduled: function () { return this._mixer._isActiveAction(this) }, startAt: function (e) { return this._startTime = e, this }, setLoop: function (e, t) { return this.loop = e, this.repetitions = t, this }, setEffectiveWeight: function (e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() }, getEffectiveWeight: function () { return this._effectiveWeight }, fadeIn: function (e) { return this._scheduleFading(e, 0, 1) }, fadeOut: function (e) { return this._scheduleFading(e, 1, 0) }, crossFadeFrom: function (e, t, i) { if (e.fadeOut(t), this.fadeIn(t), i) { var n = this._clip.duration, r = e._clip.duration, a = r / n, s = n / r; e.warp(1, a, t), this.warp(s, 1, t) } return this }, crossFadeTo: function (e, t, i) { return e.crossFadeFrom(this, t, i) }, stopFading: function () { var e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this }, setEffectiveTimeScale: function (e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() }, getEffectiveTimeScale: function () { return this._effectiveTimeScale }, setDuration: function (e) { return this.timeScale = this._clip.duration / e, this.stopWarping() }, syncWith: function (e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() }, halt: function (e) { return this.warp(this._effectiveTimeScale, 0, e) }, warp: function (e, t, i) { var n = this._mixer, r = n.time, a = this._timeScaleInterpolant, s = this.timeScale; null === a && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a); var o = a.parameterPositions, l = a.sampleValues; return o[0] = r, o[1] = r + i, l[0] = e / s, l[1] = t / s, this }, stopWarping: function () { var e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this }, getMixer: function () { return this._mixer }, getClip: function () { return this._clip }, getRoot: function () { return this._localRoot || this._mixer._root }, _update: function (e, t, i, n) { if (this.enabled) { var r = this._startTime; if (null !== r) { var a = (e - r) * i; if (a < 0 || 0 === i) return; this._startTime = null, t = i * a } t *= this._updateTimeScale(e); var s = this._updateTime(t), o = this._updateWeight(e); if (o > 0) for (var l = this._interpolants, c = this._propertyBindings, h = 0, u = l.length; h !== u; ++h)l[h].evaluate(s), c[h].accumulate(n, o) } else this._updateWeight(e) }, _updateWeight: function (e) { var t = 0; if (this.enabled) { t = this.weight; var i = this._weightInterpolant; if (null !== i) { var n = i.evaluate(e)[0]; t *= n, e > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1)) } } return this._effectiveWeight = t, t }, _updateTimeScale: function (e) { var t = 0; if (!this.paused) { t = this.timeScale; var i = this._timeScaleInterpolant; if (null !== i) t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t) } return this._effectiveTimeScale = t, t }, _updateTime: function (e) { var t = this.time + e, i = this._clip.duration, n = this.loop, r = this._loopCount, a = 2202 === n; if (0 === e) return -1 === r ? t : a && 1 == (1 & r) ? i - t : t; if (2200 === n) { -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (t >= i) t = i; else { if (!(t < 0)) { this.time = t; break e } t = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = t, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), t >= i || t < 0) { var s = Math.floor(t / i); t -= i * s, r += Math.abs(s); var o = this.repetitions - r; if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? i : 0, this.time = t, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 }); else { if (1 === o) { var l = e < 0; this._setEndings(l, !l, a) } else this._setEndings(!1, !1, a); this._loopCount = r, this.time = t, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: s }) } } else this.time = t; if (a && 1 == (1 & r)) return i - t } return t }, _setEndings: function (e, t, i) { var n = this._interpolantSettings; i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402) }, _scheduleFading: function (e, t, i) { var n = this._mixer, r = n.time, a = this._weightInterpolant; null === a && (a = n._lendControlInterpolant(), this._weightInterpolant = a); var s = a.parameterPositions, o = a.sampleValues; return s[0] = r, o[0] = t, s[1] = r + e, o[1] = i, this } }), Hs.prototype = Object.assign(Object.create(n.prototype), { constructor: Hs, _bindAction: function (e, t) { var i = e._localRoot || this._root, n = e._clip.tracks, r = n.length, a = e._propertyBindings, s = e._interpolants, o = i.uuid, l = this._bindingsByRootAndName, c = l[o]; void 0 === c && (c = {}, l[o] = c); for (var h = 0; h !== r; ++h) { var u = n[h], d = u.name, p = c[d]; if (void 0 !== p) a[h] = p; else { if (void 0 !== (p = a[h])) { null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, o, d)); continue } var f = t && t._propertyBindings[h].binding.parsedPath; ++(p = new Ms(Gs.create(i, d, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(p, o, d), a[h] = p } s[h].resultBuffer = p.buffer } }, _activateAction: function (e) { if (!this._isActiveAction(e)) { if (null === e._cacheIndex) { var t = (e._localRoot || this._root).uuid, i = e._clip.uuid, n = this._actionsByClip[i]; this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, i, t) } for (var r = e._propertyBindings, a = 0, s = r.length; a !== s; ++a) { var o = r[a]; 0 == o.useCount++ && (this._lendBinding(o), o.saveOriginalState()) } this._lendAction(e) } }, _deactivateAction: function (e) { if (this._isActiveAction(e)) { for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) { var r = t[i]; 0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r)) } this._takeBackAction(e) } }, _initMemoryManager: function () { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; var e = this; this.stats = { actions: { get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: { get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: { get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } }, _isActiveAction: function (e) { var t = e._cacheIndex; return null !== t && t < this._nActiveActions }, _addInactiveAction: function (e, t, i) { var n = this._actions, r = this._actionsByClip, a = r[t]; if (void 0 === a) a = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, r[t] = a; else { var s = a.knownActions; e._byClipCacheIndex = s.length, s.push(e) } e._cacheIndex = n.length, n.push(e), a.actionByRoot[i] = e }, _removeInactiveAction: function (e) { var t = this._actions, i = t[t.length - 1], n = e._cacheIndex; i._cacheIndex = n, t[n] = i, t.pop(), e._cacheIndex = null; var r = e._clip.uuid, a = this._actionsByClip, s = a[r], o = s.knownActions, l = o[o.length - 1], c = e._byClipCacheIndex; l._byClipCacheIndex = c, o[c] = l, o.pop(), e._byClipCacheIndex = null, delete s.actionByRoot[(e._localRoot || this._root).uuid], 0 === o.length && delete a[r], this._removeInactiveBindingsForAction(e) }, _removeInactiveBindingsForAction: function (e) { for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) { var r = t[i]; 0 == --r.referenceCount && this._removeInactiveBinding(r) } }, _lendAction: function (e) { var t = this._actions, i = e._cacheIndex, n = this._nActiveActions++, r = t[n]; e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r }, _takeBackAction: function (e) { var t = this._actions, i = e._cacheIndex, n = --this._nActiveActions, r = t[n]; e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r }, _addInactiveBinding: function (e, t, i) { var n = this._bindingsByRootAndName, r = n[t], a = this._bindings; void 0 === r && (r = {}, n[t] = r), r[i] = e, e._cacheIndex = a.length, a.push(e) }, _removeInactiveBinding: function (e) { var t = this._bindings, i = e.binding, n = i.rootNode.uuid, r = i.path, a = this._bindingsByRootAndName, s = a[n], o = t[t.length - 1], l = e._cacheIndex; o._cacheIndex = l, t[l] = o, t.pop(), delete s[r]; e: { for (var c in s) break e; delete a[n] } }, _lendBinding: function (e) { var t = this._bindings, i = e._cacheIndex, n = this._nActiveBindings++, r = t[n]; e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r }, _takeBackBinding: function (e) { var t = this._bindings, i = e._cacheIndex, n = --this._nActiveBindings, r = t[n]; e._cacheIndex = n, t[n] = e, r._cacheIndex = i, t[i] = r }, _lendControlInterpolant: function () { var e = this._controlInterpolants, t = this._nActiveControlInterpolants++, i = e[t]; return void 0 === i && ((i = new jr(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t, e[t] = i), i }, _takeBackControlInterpolant: function (e) { var t = this._controlInterpolants, i = e.__cacheIndex, n = --this._nActiveControlInterpolants, r = t[n]; e.__cacheIndex = n, t[n] = e, r.__cacheIndex = i, t[i] = r }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (e, t) { var i = t || this._root, n = i.uuid, r = "string" == typeof e ? ea.findByName(i, e) : e, a = null !== r ? r.uuid : e, s = this._actionsByClip[a], o = null; if (void 0 !== s) { var l = s.actionByRoot[n]; if (void 0 !== l) return l; o = s.knownActions[0], null === r && (r = o._clip) } if (null === r) return null; var c = new Us(this, r, t); return this._bindAction(c, o), this._addInactiveAction(c, a, n), c }, existingAction: function (e, t) { var i = t || this._root, n = i.uuid, r = "string" == typeof e ? ea.findByName(i, e) : e, a = r ? r.uuid : e, s = this._actionsByClip[a]; return void 0 !== s && s.actionByRoot[n] || null }, stopAllAction: function () { var e = this._actions, t = this._nActiveActions, i = this._bindings, n = this._nActiveBindings; this._nActiveActions = 0, this._nActiveBindings = 0; for (var r = 0; r !== t; ++r)e[r].reset(); for (r = 0; r !== n; ++r)i[r].useCount = 0; return this }, update: function (e) { e *= this.timeScale; for (var t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1, s = 0; s !== i; ++s) { t[s]._update(n, e, r, a) } var o = this._bindings, l = this._nActiveBindings; for (s = 0; s !== l; ++s)o[s].apply(a); return this }, getRoot: function () { return this._root }, uncacheClip: function (e) { var t = this._actions, i = e.uuid, n = this._actionsByClip, r = n[i]; if (void 0 !== r) { for (var a = r.knownActions, s = 0, o = a.length; s !== o; ++s) { var l = a[s]; this._deactivateAction(l); var c = l._cacheIndex, h = t[t.length - 1]; l._cacheIndex = null, l._byClipCacheIndex = null, h._cacheIndex = c, t[c] = h, t.pop(), this._removeInactiveBindingsForAction(l) } delete n[i] } }, uncacheRoot: function (e) { var t = e.uuid, i = this._actionsByClip; for (var n in i) { var r = i[n].actionByRoot[t]; void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r)) } var a = this._bindingsByRootAndName[t]; if (void 0 !== a) for (var s in a) { var o = a[s]; o.restoreOriginalState(), this._removeInactiveBinding(o) } }, uncacheAction: function (e, t) { var i = this.existingAction(e, t); null !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } }), Vs.prototype.clone = function () { return new Vs(void 0 === this.value.clone ? this.value : this.value.clone()) }, js.prototype = Object.assign(Object.create(Ki.prototype), { constructor: js, isInstancedInterleavedBuffer: !0, copy: function (e) { return Ki.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this } }), Object.assign(function (e, t, i, n) { this.ray = new $e(e, t), this.near = i || 0, this.far = n || 1 / 0, this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function () { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) }.prototype, { linePrecision: 1, set: function (e, t) { this.ray.set(e, t) }, setFromCamera: function (e, t) { t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function (e, t, i) { var n = i || []; return $s(e, this, n, t), n.sort(Ws), n }, intersectObjects: function (e, t, i) { var n = i || []; if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n; for (var r = 0, a = e.length; r < a; r++)$s(e[r], this, n, t); return n.sort(Ws), n } }), Object.assign(function (e, t, i) { return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== i ? i : 0, this }.prototype, { set: function (e, t, i) { return this.radius = e, this.phi = t, this.theta = i, this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this }, makeSafe: function () { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this }, setFromVector3: function (e) { return this.setFromCartesianCoords(e.x, e.y, e.z) }, setFromCartesianCoords: function (e, t, i) { return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(o.clamp(t / this.radius, -1, 1))), this } }), Object.assign(function (e, t, i) { return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== i ? i : 0, this }.prototype, { set: function (e, t, i) { return this.radius = e, this.theta = t, this.y = i, this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this }, setFromVector3: function (e) { return this.setFromCartesianCoords(e.x, e.y, e.z) }, setFromCartesianCoords: function (e, t, i) { return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this } }), Object.assign(Xs.prototype, { set: function (e, t) { return this.min.copy(e), this.max.copy(t), this }, setFromPoints: function (e) { this.makeEmpty(); for (var t = 0, i = e.length; t < i; t++)this.expandByPoint(e[t]); return this }, setFromCenterAndSize: function () { var e = new l; return function (t, i) { var n = e.copy(i).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this } }(), clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.min.copy(e.min), this.max.copy(e.max), this }, makeEmpty: function () { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function (e) { return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new l), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (e) { return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new l), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) }, expandByPoint: function (e) { return this.min.min(e), this.max.max(e), this }, expandByVector: function (e) { return this.min.sub(e), this.max.add(e), this }, expandByScalar: function (e) { return this.min.addScalar(-e), this.max.addScalar(e), this }, containsPoint: function (e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) }, containsBox: function (e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y }, getParameter: function (e, t) { return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new l), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function (e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) }, clampPoint: function (e, t) { return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new l), t.copy(e).clamp(this.min, this.max) }, distanceToPoint: function () { var e = new l; return function (t) { return e.copy(t).clamp(this.min, this.max).sub(t).length() } }(), intersect: function (e) { return this.min.max(e.min), this.max.min(e.max), this }, union: function (e) { return this.min.min(e.min), this.max.max(e.max), this }, translate: function (e) { return this.min.add(e), this.max.add(e), this }, equals: function (e) { return e.min.equals(this.min) && e.max.equals(this.max) } }), Object.assign(Ys.prototype, { set: function (e, t) { return this.start.copy(e), this.end.copy(t), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (e) { return this.start.copy(e.start), this.end.copy(e.end), this }, getCenter: function (e) { return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new h), e.addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function (e) { return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new h), e.subVectors(this.end, this.start) }, distanceSq: function () { return this.start.distanceToSquared(this.end) }, distance: function () { return this.start.distanceTo(this.end) }, at: function (e, t) { return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new h), this.delta(t).multiplyScalar(e).add(this.start) }, closestPointToPointParameter: (Is = new h, ks = new h, function (e, t) { Is.subVectors(e, this.start), ks.subVectors(this.end, this.start); var i = ks.dot(ks), n = ks.dot(Is) / i; return t && (n = o.clamp(n, 0, 1)), n }), closestPointToPoint: function (e, t, i) { var n = this.closestPointToPointParameter(e, t); return void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new h), this.delta(i).multiplyScalar(n).add(this.start) }, applyMatrix4: function (e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this }, equals: function (e) { return e.start.equals(this.start) && e.end.equals(this.end) } }), qs.prototype = Object.create(le.prototype), qs.prototype.constructor = qs, qs.prototype.isImmediateRenderObject = !0, Js.prototype = Object.create(cn.prototype), Js.prototype.constructor = Js, Js.prototype.update = function () { var e = new h, t = new h, i = new u; return function () { var n = ["a", "b", "c"]; this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld); var r = this.object.matrixWorld, a = this.geometry.attributes.position, s = this.object.geometry; if (s && s.isGeometry) for (var o = s.vertices, l = s.faces, c = 0, h = 0, u = l.length; h < u; h++)for (var d = l[h], p = 0, f = d.vertexNormals.length; p < f; p++) { var m = o[d[n[p]]], g = d.vertexNormals[p]; e.copy(m).applyMatrix4(r), t.copy(g).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), a.setXYZ(c, e.x, e.y, e.z), c += 1, a.setXYZ(c, t.x, t.y, t.z), c += 1 } else if (s && s.isBufferGeometry) { var v = s.attributes.position, y = s.attributes.normal; for (c = 0, p = 0, f = v.count; p < f; p++)e.set(v.getX(p), v.getY(p), v.getZ(p)).applyMatrix4(r), t.set(y.getX(p), y.getY(p), y.getZ(p)), t.applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), a.setXYZ(c, e.x, e.y, e.z), c += 1, a.setXYZ(c, t.x, t.y, t.z), c += 1 } a.needsUpdate = !0 } }(), Zs.prototype = Object.create(le.prototype), Zs.prototype.constructor = Zs, Zs.prototype.dispose = function () { this.cone.geometry.dispose(), this.cone.material.dispose() }, Zs.prototype.update = function () { var e = new h; return function () { this.light.updateMatrixWorld(); var t = this.light.distance ? this.light.distance : 1e3, i = t * Math.tan(this.light.angle); this.cone.scale.set(i, i, t), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } }(), Ks.prototype = Object.create(cn.prototype), Ks.prototype.constructor = Ks, Ks.prototype.updateMatrixWorld = function () { var e = new h, t = new B, i = new B; return function (n) { var r = this.bones, a = this.geometry, s = a.getAttribute("position"); i.getInverse(this.root.matrixWorld); for (var o = 0, l = 0; o < r.length; o++) { var c = r[o]; c.parent && c.parent.isBone && (t.multiplyMatrices(i, c.matrixWorld), e.setFromMatrixPosition(t), s.setXYZ(l, e.x, e.y, e.z), t.multiplyMatrices(i, c.parent.matrixWorld), e.setFromMatrixPosition(t), s.setXYZ(l + 1, e.x, e.y, e.z), l += 2) } a.getAttribute("position").needsUpdate = !0, le.prototype.updateMatrixWorld.call(this, n) } }(), Qs.prototype = Object.create(qe.prototype), Qs.prototype.constructor = Qs, Qs.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, Qs.prototype.update = function () { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }, eo.prototype = Object.create(ln.prototype), eo.prototype.constructor = eo, eo.prototype.update = function () { if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color); else { this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity); var e = this.material.color, t = Math.max(e.r, e.g, e.b); t > 1 && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color) } }, eo.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() }, to.prototype = Object.create(le.prototype), to.prototype.constructor = to, to.prototype.dispose = function () { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, to.prototype.update = function () { var e = new h, t = new X, i = new X; return function () { var n = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { var r = n.geometry.getAttribute("color"); t.copy(this.light.color), i.copy(this.light.groundColor); for (var a = 0, s = r.count; a < s; a++) { var o = a < s / 2 ? t : i; r.setXYZ(a, o.r, o.g, o.b) } r.needsUpdate = !0 } n.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate()) } }(), io.prototype = Object.create(qe.prototype), io.prototype.constructor = io, io.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, io.prototype.onBeforeRender = function () { this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity }, no.prototype = Object.assign(Object.create(cn.prototype), { constructor: no, copy: function (e) { return cn.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this }, clone: function () { return (new this.constructor).copy(this) } }), ro.prototype = Object.create(cn.prototype), ro.prototype.constructor = ro, ao.prototype = Object.create(ln.prototype), ao.prototype.constructor = ao, ao.prototype.update = function () { var e, t, i = this.audio, n = this.range, r = this.divisionsInnerAngle, a = this.divisionsOuterAngle, s = o.degToRad(i.panner.coneInnerAngle), l = o.degToRad(i.panner.coneOuterAngle), c = s / 2, h = l / 2, u = 0, d = 0, p = this.geometry, f = p.attributes.position; function m(i, r, a, s) { var o = (r - i) / a; for (f.setXYZ(u, 0, 0, 0), d++, e = i; e < r; e += o)t = u + d, f.setXYZ(t, Math.sin(e) * n, 0, Math.cos(e) * n), f.setXYZ(t + 1, Math.sin(Math.min(e + o, r)) * n, 0, Math.cos(Math.min(e + o, r)) * n), f.setXYZ(t + 2, 0, 0, 0), d += 3; p.addGroup(u, d, s), u += d, d = 0 } p.clearGroups(), m(-h, -c, a, 0), m(-c, c, r, 1), m(c, h, a, 0), f.needsUpdate = !0, s === l && (this.material[0].visible = !1) }, ao.prototype.dispose = function () { this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose() }, so.prototype = Object.create(cn.prototype), so.prototype.constructor = so, so.prototype.update = function () { var e = new h, t = new h, i = new u; return function () { this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld); for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, a = this.object.geometry, s = a.vertices, o = a.faces, l = 0, c = 0, h = o.length; c < h; c++) { var u = o[c], d = u.normal; e.copy(s[u.a]).add(s[u.b]).add(s[u.c]).divideScalar(3).applyMatrix4(n), t.copy(d).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), r.setXYZ(l, e.x, e.y, e.z), l += 1, r.setXYZ(l, t.x, t.y, t.z), l += 1 } r.needsUpdate = !0 } }(), oo.prototype = Object.create(le.prototype), oo.prototype.constructor = oo, oo.prototype.dispose = function () { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }, oo.prototype.update = function () { var e = new h, t = new h, i = new h; return function () { e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(t, e), this.lightPlane.lookAt(t), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(t), this.targetLine.scale.z = i.length() } }(), lo.prototype = Object.create(cn.prototype), lo.prototype.constructor = lo, lo.prototype.update = function () { var e, t, i = new h, n = new ki; function r(r, a, s, o) { i.set(a, s, o).unproject(n); var l = t[r]; if (void 0 !== l) for (var c = e.getAttribute("position"), h = 0, u = l.length; h < u; h++)c.setXYZ(l[h], i.x, i.y, i.z) } return function () { e = this.geometry, t = this.pointMap; n.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), r("c", 0, 0, -1), r("t", 0, 0, 1), r("n1", -1, -1, -1), r("n2", 1, -1, -1), r("n3", -1, 1, -1), r("n4", 1, 1, -1), r("f1", -1, -1, 1), r("f2", 1, -1, 1), r("f3", -1, 1, 1), r("f4", 1, 1, 1), r("u1", .7, 1.1, -1), r("u2", -.7, 1.1, -1), r("u3", 0, 2, -1), r("cf1", -1, 0, 1), r("cf2", 1, 0, 1), r("cf3", 0, -1, 1), r("cf4", 0, 1, 1), r("cn1", -1, 0, -1), r("cn2", 1, 0, -1), r("cn3", 0, -1, -1), r("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0 } }(), co.prototype = Object.create(cn.prototype), co.prototype.constructor = co, co.prototype.update = function () { var e = new k; return function (t) { if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e.setFromObject(this.object), !e.isEmpty()) { var i = e.min, n = e.max, r = this.geometry.attributes.position, a = r.array; a[0] = n.x, a[1] = n.y, a[2] = n.z, a[3] = i.x, a[4] = n.y, a[5] = n.z, a[6] = i.x, a[7] = i.y, a[8] = n.z, a[9] = n.x, a[10] = i.y, a[11] = n.z, a[12] = n.x, a[13] = n.y, a[14] = i.z, a[15] = i.x, a[16] = n.y, a[17] = i.z, a[18] = i.x, a[19] = i.y, a[20] = i.z, a[21] = n.x, a[22] = i.y, a[23] = i.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere() } } }(), co.prototype.setFromObject = function (e) { return this.object = e, this.update(), this }, co.prototype.copy = function (e) { return cn.prototype.copy.call(this, e), this.object = e.object, this }, co.prototype.clone = function () { return (new this.constructor).copy(this) }, ho.prototype = Object.create(cn.prototype), ho.prototype.constructor = ho, ho.prototype.updateMatrixWorld = function (e) { var t = this.box; t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), le.prototype.updateMatrixWorld.call(this, e)) }, uo.prototype = Object.create(ln.prototype), uo.prototype.constructor = uo, uo.prototype.updateMatrixWorld = function (e) { var t = -this.plane.constant; Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? 1 : 0, this.lookAt(this.plane.normal), le.prototype.updateMatrixWorld.call(this, e) }, po.prototype = Object.create(le.prototype), po.prototype.constructor = po, po.prototype.setDirection = (Bs = new h, function (e) { e.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (Bs.set(e.z, 0, -e.x).normalize(), Ns = Math.acos(e.y), this.quaternion.setFromAxisAngle(Bs, Ns)) }), po.prototype.setLength = function (e, t, i) { void 0 === t && (t = .2 * e), void 0 === i && (i = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix() }, po.prototype.setColor = function (e) { this.line.material.color.copy(e), this.cone.material.color.copy(e) }, po.prototype.copy = function (e) { return le.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this }, po.prototype.clone = function () { return (new this.constructor).copy(this) }, fo.prototype = Object.create(cn.prototype), fo.prototype.constructor = fo; function mo(e) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), _a.call(this, e), this.type = "catmullrom" } ua.create = function (e, t) { return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(ua.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e }, Object.assign(Ra.prototype, { createPointsGeometry: function (e) { console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); var t = this.getPoints(e); return this.createGeometry(t) }, createSpacedPointsGeometry: function (e) { console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); var t = this.getSpacedPoints(e); return this.createGeometry(t) }, createGeometry: function (e) { console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); for (var t = new de, i = 0, n = e.length; i < n; i++) { var r = e[i]; t.vertices.push(new h(r.x, r.y, r.z || 0)) } return t } }), Object.assign(Oa.prototype, { fromPoints: function (e) { console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e) } }), Object.create(_a.prototype), Object.create(_a.prototype), mo.prototype = Object.create(_a.prototype), Object.assign(mo.prototype, { initFromArray: function () { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function () { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function () { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), no.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, Ks.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(us.prototype, { extractUrlBase: function (e) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Xa(e) } }), Object.assign(Ka.prototype, { setTexturePath: function (e) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e) } }), Object.assign(Xs.prototype, { center: function (e) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e) }, empty: function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (e) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, size: function (e) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e) } }), Object.assign(k.prototype, { center: function (e) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, empty: function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (e) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, isIntersectionSphere: function (e) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, size: function (e) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e) } }), Ys.prototype.center = function (e) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, Object.assign(o, { random16: function () { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function (e) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), o.floorPowerOfTwo(e) }, nextPowerOfTwo: function (e) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), o.ceilPowerOfTwo(e) } }), Object.assign(u.prototype, { flattenToArrayOffset: function (e, t) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, multiplyVector3: function (e) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBuffer: function (e) { return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e) }, applyToVector3Array: function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }), Object.assign(B.prototype, { extractPosition: function (e) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e) }, flattenToArrayOffset: function (e, t) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, getPosition: function () { var e; return function () { return void 0 === e && (e = new h), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3) } }(), setRotationFromQuaternion: function (e) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e) }, multiplyToArray: function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function (e) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, multiplyVector4: function (e) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function (e) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this) }, crossVector: function (e) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, translate: function () { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBuffer: function (e) { return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e) }, applyToVector3Array: function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function (e, t, i, n, r, a) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, i, r, a) } }), z.prototype.isIntersectionLine = function (e) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e) }, c.prototype.multiplyVector3 = function (e) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this) }, Object.assign($e.prototype, { isIntersectionBox: function (e) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, isIntersectionPlane: function (e) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e) }, isIntersectionSphere: function (e) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) } }), Object.assign(Xe.prototype, { area: function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function (e, t) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t) }, midpoint: function (e) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e) }, normal: function (e) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e) }, plane: function (e) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e) } }), Object.assign(Xe, { barycoordFromPoint: function (e, t, i, n, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Xe.getBarycoord(e, t, i, n, r) }, normal: function (e, t, i, n) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Xe.getNormal(e, t, i, n) } }), Object.assign(Ia.prototype, { extractAllPoints: function (e) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e) }, extrude: function (e) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new or(this, e) }, makeGeometry: function (e) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new _r(this, e) } }), Object.assign(l.prototype, { fromAttribute: function (e, t, i) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, distanceToManhattan: function (e) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, lengthManhattan: function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(h.prototype, { setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (e) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e) }, getScaleFromMatrix: function (e) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e) }, getColumnFromMatrix: function (e, t) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, applyProjection: function (e) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e) }, fromAttribute: function (e, t, i) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, distanceToManhattan: function (e) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, lengthManhattan: function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(P.prototype, { fromAttribute: function (e, t, i) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, lengthManhattan: function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(de.prototype, { computeTangents: function () { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function () { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") } }), Object.assign(le.prototype, { getChildByName: function (e) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e) }, renderDepth: function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function (e, t) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e) }, getWorldRotation: function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") } }), Object.defineProperties(le.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (e) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.defineProperties(nn.prototype, { objects: { get: function () { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(an.prototype, "useVertexTexture", { get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), rn.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(ua.prototype, "__arcLengthDivisions", { get: function () { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function (e) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e } }), Di.prototype.setLens = function (e, t) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e) }, Object.defineProperties(ka.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (e) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e } }, shadowCameraLeft: { set: function (e) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e } }, shadowCameraRight: { set: function (e) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e } }, shadowCameraTop: { set: function (e) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e } }, shadowCameraBottom: { set: function (e) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e } }, shadowCameraNear: { set: function (e) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e } }, shadowCameraFar: { set: function (e) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (e) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (e) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e } }, shadowMapHeight: { set: function (e) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e } } }), Object.defineProperties(pe.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, copyIndicesArray: function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") } }), Object.assign(Ee.prototype, { addIndex: function (e) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e) }, addDrawCall: function (e, t, i) { void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t) }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function () { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") } }), Object.defineProperties(Ee.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.assign(lr.prototype, { getArrays: function () { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.") }, addShapeList: function () { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.") }, addShape: function () { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.") } }), Object.defineProperties(Vs.prototype, { dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(Oe.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new X } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e } } }), Object.defineProperties(kr.prototype, { metal: { get: function () { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(We.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (e) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e } } }), Object.assign(Yi.prototype, { clearTarget: function (e, t, i, n) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, i, n) }, animate: function (e) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e) }, getCurrentRenderTarget: function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function (e) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e) }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, allocTextureUnit: function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, setTexture: function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, setTexture2D: function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, setTextureCube: function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") } }), Object.defineProperties(Yi.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (e) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Pi.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(O.prototype, { activeCubeFace: { set: function () { console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().") } }, activeMipMapLevel: { set: function () { console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().") } } }), Object.defineProperties(L.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (e) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e } } }), Object.defineProperties($i.prototype, { standing: { set: function () { console.warn("THREE.WebVRManager: .standing has been removed.") } }, userHeight: { set: function () { console.warn("THREE.WebVRManager: .userHeight has been removed.") } } }), bs.prototype.load = function (e) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); var t = this; return (new ps).load(e, (function (e) { t.setBuffer(e) })), this }, Ts.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, ys.prototype.updateCubeMap = function (e, t) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t) }; E.crossOrigin = void 0, E.loadTexture = function (e, t, i, n) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); var r = new ha; r.setCrossOrigin(this.crossOrigin); var a = r.load(e, i, void 0, n); return t && (a.mapping = t), a }, E.loadTextureCube = function (e, t, i, n) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); var r = new ca; r.setCrossOrigin(this.crossOrigin); var a = r.load(e, i, void 0, n); return t && (a.mapping = t), a }, E.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, E.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; var go = function () { function e(e) { this.manager = void 0 !== e ? e : ra, this.dracoLoader = null } function t() { var e = {}; return { get: function (t) { return e[t] }, add: function (t, i) { e[t] = i }, remove: function (t) { delete e[t] }, removeAll: function () { e = {} } } } e.prototype = { constructor: e, crossOrigin: "anonymous", load: function (e, t, i, n) { var r, a = this; r = void 0 !== this.resourcePath ? this.resourcePath : void 0 !== this.path ? this.path : Xa(e), a.manager.itemStart(e); var s = function (t) { n ? n(t) : console.error(t), a.manager.itemError(e), a.manager.itemEnd(e) }, o = new sa(a.manager); o.setPath(this.path), o.setResponseType("arraybuffer"), o.load(e, (function (i) { try { a.parse(i, r, (function (i) { t(i), a.manager.itemEnd(e) }), s) } catch (e) { s(e) } }), i, s) }, setCrossOrigin: function (e) { return this.crossOrigin = e, this }, setPath: function (e) { return this.path = e, this }, setResourcePath: function (e) { return this.resourcePath = e, this }, setDRACOLoader: function (e) { return this.dracoLoader = e, this }, parse: function (e, t, o, l) { var c, h = {}; if ("string" == typeof e) c = e; else if ($a(new Uint8Array(e, 0, 4)) === s) { try { h[i.KHR_BINARY_GLTF] = new u(e) } catch (e) { return void (l && l(e)) } c = h[i.KHR_BINARY_GLTF].content } else c = $a(new Uint8Array(e)); var m = JSON.parse(c); if (void 0 === m.asset || m.asset.version[0] < 2) l && l(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.")); else { if (m.extensionsUsed) for (var g = 0; g < m.extensionsUsed.length; ++g) { var v = m.extensionsUsed[g], y = m.extensionsRequired || []; switch (v) { case i.KHR_LIGHTS_PUNCTUAL: h[v] = new r(m); break; case i.KHR_MATERIALS_UNLIT: h[v] = new a(m); break; case i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: h[v] = new f(m); break; case i.KHR_DRACO_MESH_COMPRESSION: h[v] = new d(m, this.dracoLoader); break; case i.MSFT_TEXTURE_DDS: h[i.MSFT_TEXTURE_DDS] = new n; break; case i.KHR_TEXTURE_TRANSFORM: h[i.KHR_TEXTURE_TRANSFORM] = new p(m); break; default: y.indexOf(v) >= 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + v + '".') } } new H(m, h, { path: t || this.resourcePath || "", crossOrigin: this.crossOrigin, manager: this.manager }).parse(o, l) } } }; var i = { KHR_BINARY_GLTF: "KHR_binary_glTF", KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression", KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual", KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness", KHR_MATERIALS_UNLIT: "KHR_materials_unlit", KHR_TEXTURE_TRANSFORM: "KHR_texture_transform", MSFT_TEXTURE_DDS: "MSFT_texture_dds" }; function n() { if (!THREE.DDSLoader) throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader"); this.name = i.MSFT_TEXTURE_DDS, this.ddsLoader = new THREE.DDSLoader } function r(e) { this.name = i.KHR_LIGHTS_PUNCTUAL; var t = e.extensions && e.extensions[i.KHR_LIGHTS_PUNCTUAL] || {}; this.lightDefs = t.lights || [] } function a() { this.name = i.KHR_MATERIALS_UNLIT } r.prototype.loadLight = function (e) { var t, i = this.lightDefs[e], n = new X(16777215); void 0 !== i.color && n.fromArray(i.color); var r = void 0 !== i.range ? i.range : 0; switch (i.type) { case "directional": (t = new Ha(n)).target.position.set(0, 0, -1), t.add(t.target); break; case "point": (t = new Fa(n)).distance = r; break; case "spot": (t = new Ba(n)).distance = r, i.spot = i.spot || {}, i.spot.innerConeAngle = void 0 !== i.spot.innerConeAngle ? i.spot.innerConeAngle : 0, i.spot.outerConeAngle = void 0 !== i.spot.outerConeAngle ? i.spot.outerConeAngle : Math.PI / 4, t.angle = i.spot.outerConeAngle, t.penumbra = 1 - i.spot.innerConeAngle / i.spot.outerConeAngle, t.target.position.set(0, 0, -1), t.add(t.target); break; default: throw new Error('THREE.GLTFLoader: Unexpected light type, "' + i.type + '".') }return t.position.set(0, 0, 0), t.decay = 2, void 0 !== i.intensity && (t.intensity = i.intensity), t.name = i.name || "light_" + e, Promise.resolve(t) }, a.prototype.getMaterialType = function () { return Ye }, a.prototype.extendParams = function (e, t, i) { var n = []; e.color = new X(1, 1, 1), e.opacity = 1; var r = t.pbrMetallicRoughness; if (r) { if (Array.isArray(r.baseColorFactor)) { var a = r.baseColorFactor; e.color.fromArray(a), e.opacity = a[3] } void 0 !== r.baseColorTexture && n.push(i.assignTexture(e, "map", r.baseColorTexture)) } return Promise.all(n) }; var s = "glTF", c = 1313821514, h = 5130562; function u(e) { this.name = i.KHR_BINARY_GLTF, this.content = null, this.body = null; var t = new DataView(e, 0, 12); if (this.header = { magic: $a(new Uint8Array(e.slice(0, 4))), version: t.getUint32(4, !0), length: t.getUint32(8, !0) }, this.header.magic !== s) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header."); if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead."); for (var n = new DataView(e, 12), r = 0; r < n.byteLength;) { var a = n.getUint32(r, !0); r += 4; var o = n.getUint32(r, !0); if (r += 4, o === c) { var l = new Uint8Array(e, 12 + r, a); this.content = $a(l) } else if (o === h) { var u = 12 + r; this.body = e.slice(u, u + a) } r += a } if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.") } function d(e, t) { if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided."); this.name = i.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t } function p() { this.name = i.KHR_TEXTURE_TRANSFORM } function f() { return { name: i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, specularGlossinessParams: ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"], getMaterialType: function () { return We }, extendParams: function (e, t, i) { var n = t.extensions[this.name], r = J.standard, a = W.clone(r.uniforms), s = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"), o = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"), l = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\ttexelSpecular = sRGBToLinear( texelSpecular );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"), c = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"), h = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb;", "material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );", "material.specularColor = specularFactor.rgb;"].join("\n"), u = r.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", s).replace("#include <metalnessmap_pars_fragment>", o).replace("#include <roughnessmap_fragment>", l).replace("#include <metalnessmap_fragment>", c).replace("#include <lights_physical_fragment>", h); delete a.roughness, delete a.metalness, delete a.roughnessMap, delete a.metalnessMap, a.specular = { value: (new X).setHex(1118481) }, a.glossiness = { value: .5 }, a.specularMap = { value: null }, a.glossinessMap = { value: null }, e.vertexShader = r.vertexShader, e.fragmentShader = u, e.uniforms = a, e.defines = { STANDARD: "" }, e.color = new X(1, 1, 1), e.opacity = 1; var d = []; if (Array.isArray(n.diffuseFactor)) { var p = n.diffuseFactor; e.color.fromArray(p), e.opacity = p[3] } if (void 0 !== n.diffuseTexture && d.push(i.assignTexture(e, "map", n.diffuseTexture)), e.emissive = new X(0, 0, 0), e.glossiness = void 0 !== n.glossinessFactor ? n.glossinessFactor : 1, e.specular = new X(1, 1, 1), Array.isArray(n.specularFactor) && e.specular.fromArray(n.specularFactor), void 0 !== n.specularGlossinessTexture) { var f = n.specularGlossinessTexture; d.push(i.assignTexture(e, "glossinessMap", f)), d.push(i.assignTexture(e, "specularMap", f)) } return Promise.all(d) }, createMaterial: function (e) { var t = new We({ defines: e.defines, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader, uniforms: e.uniforms, fog: !0, lights: !0, opacity: e.opacity, transparent: e.transparent }); return t.isGLTFSpecularGlossinessMaterial = !0, t.color = e.color, t.map = void 0 === e.map ? null : e.map, t.lightMap = null, t.lightMapIntensity = 1, t.aoMap = void 0 === e.aoMap ? null : e.aoMap, t.aoMapIntensity = 1, t.emissive = e.emissive, t.emissiveIntensity = 1, t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap, t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap, t.bumpScale = 1, t.normalMap = void 0 === e.normalMap ? null : e.normalMap, e.normalScale && (t.normalScale = e.normalScale), t.displacementMap = null, t.displacementScale = 1, t.displacementBias = 0, t.specularMap = void 0 === e.specularMap ? null : e.specularMap, t.specular = e.specular, t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap, t.glossiness = e.glossiness, t.alphaMap = null, t.envMap = void 0 === e.envMap ? null : e.envMap, t.envMapIntensity = 1, t.refractionRatio = .98, t.extensions.derivatives = !0, t }, cloneMaterial: function (e) { var t = e.clone(); t.isGLTFSpecularGlossinessMaterial = !0; for (var i = this.specularGlossinessParams, n = 0, r = i.length; n < r; n++) { var a = e[i[n]]; t[i[n]] = a && a.isColor ? a.clone() : a } return t }, refreshUniforms: function (e, t, i, n, r, a) { if (!0 === r.isGLTFSpecularGlossinessMaterial) { var s, o = r.uniforms, l = r.defines; o.opacity.value = r.opacity, o.diffuse.value.copy(r.color), o.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), o.map.value = r.map, o.specularMap.value = r.specularMap, o.alphaMap.value = r.alphaMap, o.lightMap.value = r.lightMap, o.lightMapIntensity.value = r.lightMapIntensity, o.aoMap.value = r.aoMap, o.aoMapIntensity.value = r.aoMapIntensity, r.map ? s = r.map : r.specularMap ? s = r.specularMap : r.displacementMap ? s = r.displacementMap : r.normalMap ? s = r.normalMap : r.bumpMap ? s = r.bumpMap : r.glossinessMap ? s = r.glossinessMap : r.alphaMap ? s = r.alphaMap : r.emissiveMap && (s = r.emissiveMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), o.uvTransform.value.copy(s.matrix)), r.envMap && (o.envMap.value = r.envMap, o.envMapIntensity.value = r.envMapIntensity, o.flipEnvMap.value = r.envMap.isCubeTexture ? -1 : 1, o.reflectivity.value = r.reflectivity, o.refractionRatio.value = r.refractionRatio, o.maxMipLevel.value = e.properties.get(r.envMap).__maxMipLevel), o.specular.value.copy(r.specular), o.glossiness.value = r.glossiness, o.glossinessMap.value = r.glossinessMap, o.emissiveMap.value = r.emissiveMap, o.bumpMap.value = r.bumpMap, o.normalMap.value = r.normalMap, o.displacementMap.value = r.displacementMap, o.displacementScale.value = r.displacementScale, o.displacementBias.value = r.displacementBias, null !== o.glossinessMap.value && void 0 === l.USE_GLOSSINESSMAP && (l.USE_GLOSSINESSMAP = "", l.USE_ROUGHNESSMAP = ""), null === o.glossinessMap.value && void 0 !== l.USE_GLOSSINESSMAP && (delete l.USE_GLOSSINESSMAP, delete l.USE_ROUGHNESSMAP) } } } } function m(e, t, i, n) { Hr.call(this, e, t, i, n) } d.prototype.decodePrimitive = function (e, t) { var i = this.json, n = this.dracoLoader, r = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, s = {}, o = {}, l = {}; for (var c in a) { var h = A[c] || c.toLowerCase(); s[h] = a[c] } for (c in e.attributes) { h = A[c] || c.toLowerCase(); if (void 0 !== a[c]) { var u = i.accessors[e.attributes[c]], d = M[u.componentType]; l[h] = d, o[h] = !0 === u.normalized } } return t.getDependency("bufferView", r).then((function (e) { return new Promise((function (t) { n.decodeDracoFile(e, (function (e) { for (var i in e.attributes) { var n = e.attributes[i], r = o[i]; void 0 !== r && (n.normalized = r) } t(e) }), s, l) })) })) }, p.prototype.extendTexture = function (e, t) { return e = e.clone(), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), e.needsUpdate = !0, e }, m.prototype = Object.create(Hr.prototype), m.prototype.constructor = m, m.prototype.copySampleValue_ = function (e) { for (var t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n * 3 + n, a = 0; a !== n; a++)t[a] = i[r + a]; return t }, m.prototype.beforeStart_ = m.prototype.copySampleValue_, m.prototype.afterEnd_ = m.prototype.copySampleValue_, m.prototype.interpolate_ = function (e, t, i, n) { for (var r = this.resultBuffer, a = this.sampleValues, s = this.valueSize, o = 2 * s, l = 3 * s, c = n - t, h = (i - t) / c, u = h * h, d = u * h, p = e * l, f = p - l, m = -2 * d + 3 * u, g = d - u, v = 1 - m, y = g - u + h, _ = 0; _ !== s; _++) { var x = a[f + _ + s], b = a[f + _ + o] * c, w = a[p + _ + s], T = a[p + _] * c; r[_] = v * x + y * b + m * w + g * T } return r }; var g, v = 0, y = 1, _ = 2, x = 3, b = 4, w = 5, T = 6, M = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, S = { 9728: 1003, 9729: 1006, 9984: 1004, 9985: 1007, 9986: 1005, 9987: 1008 }, E = { 33071: 1001, 33648: 1002, 10497: 1e3 }, C = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 }, A = { POSITION: "position", NORMAL: "normal", TANGENT: "tangent", TEXCOORD_0: "uv", TEXCOORD_1: "uv2", COLOR_0: "color", WEIGHTS_0: "skinWeight", JOINTS_0: "skinIndex" }, P = { scale: "scale", translation: "position", rotation: "quaternion", weights: "morphTargetInfluences" }, L = { CUBICSPLINE: void 0, LINEAR: 2301, STEP: 2300 }, R = "OPAQUE", O = "MASK", I = "BLEND", k = { "image/png": 1023, "image/jpeg": 1022 }; function D(e, t) { return "string" != typeof e || "" === e ? "" : /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e } function z(e, t, i) { for (var n in i.extensions) void 0 === e[n] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[n] = i.extensions[n]) } function N(e, t) { void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras)) } function F(e, t) { if (e.updateMorphTargets(), void 0 !== t.weights) for (var i = 0, n = t.weights.length; i < n; i++)e.morphTargetInfluences[i] = t.weights[i]; if (t.extras && Array.isArray(t.extras.targetNames)) { var r = t.extras.targetNames; if (e.morphTargetInfluences.length === r.length) { e.morphTargetDictionary = {}; for (i = 0, n = r.length; i < n; i++)e.morphTargetDictionary[r[i]] = i } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.") } } function G(e) { for (var t = "", i = Object.keys(e).sort(), n = 0, r = i.length; n < r; n++)t += i[n] + ":" + e[i[n]] + ";"; return t } function U(e) { if (e.isInterleavedBufferAttribute) { for (var t = e.count, i = e.itemSize, n = e.array.slice(0, t * i), r = 0, a = 0; r < t; ++r)n[a++] = e.getX(r), i >= 2 && (n[a++] = e.getY(r)), i >= 3 && (n[a++] = e.getZ(r)), i >= 4 && (n[a++] = e.getW(r)); return new pe(n, i, e.normalized) } return e.clone() } function H(e, i, n) { this.json = e || {}, this.extensions = i || {}, this.options = n || {}, this.cache = new t, this.primitiveCache = {}, this.textureLoader = new ha(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.fileLoader = new sa(this.options.manager), this.fileLoader.setResponseType("arraybuffer") } function V(e, t, i) { var n = t.attributes, r = []; function a(t, n) { return i.getDependency("accessor", t).then((function (t) { e.addAttribute(n, t) })) } for (var s in n) { var o = A[s] || s.toLowerCase(); o in e.attributes || r.push(a(n[s], o)) } if (void 0 !== t.indices && !e.index) { var l = i.getDependency("accessor", t.indices).then((function (t) { e.setIndex(t) })); r.push(l) } return N(e, t), Promise.all(r).then((function () { return void 0 !== t.targets ? function (e, t, i) { for (var n = !1, r = !1, a = 0, s = t.length; a < s; a++) { if (void 0 !== (c = t[a]).POSITION && (n = !0), void 0 !== c.NORMAL && (r = !0), n && r) break } if (!n && !r) return Promise.resolve(e); var o = [], l = []; for (a = 0, s = t.length; a < s; a++) { var c = t[a]; if (n) { var h = void 0 !== c.POSITION ? i.getDependency("accessor", c.POSITION) : e.attributes.position; o.push(h) } if (r) { h = void 0 !== c.NORMAL ? i.getDependency("accessor", c.NORMAL) : e.attributes.normal; l.push(h) } } return Promise.all([Promise.all(o), Promise.all(l)]).then((function (i) { for (var a = i[0], s = i[1], o = 0, l = a.length; o < l; o++)e.attributes.position !== a[o] && (a[o] = U(a[o])); for (o = 0, l = s.length; o < l; o++)e.attributes.normal !== s[o] && (s[o] = U(s[o])); for (o = 0, l = t.length; o < l; o++) { var c = t[o], h = "morphTarget" + o; if (n && void 0 !== c.POSITION) { var u = a[o]; u.name = h; for (var d = e.attributes.position, p = 0, f = u.count; p < f; p++)u.setXYZ(p, u.getX(p) + d.getX(p), u.getY(p) + d.getY(p), u.getZ(p) + d.getZ(p)) } if (r && void 0 !== c.NORMAL) { var m = s[o]; m.name = h; var g = e.attributes.normal; for (p = 0, f = m.count; p < f; p++)m.setXYZ(p, m.getX(p) + g.getX(p), m.getY(p) + g.getY(p), m.getZ(p) + g.getZ(p)) } } return n && (e.morphAttributes.position = a), r && (e.morphAttributes.normal = s), e })) }(e, t.targets, i) : e })) } return H.prototype.parse = function (e, t) { var i = this, n = this.json, r = this.extensions; this.cache.removeAll(), this.markDefs(), Promise.all([this.getDependencies("scene"), this.getDependencies("animation"), this.getDependencies("camera")]).then((function (t) { var a = { scene: t[0][n.scene || 0], scenes: t[0], animations: t[1], cameras: t[2], asset: n.asset, parser: i, userData: {} }; z(r, a, n), e(a) })).catch(t) }, H.prototype.markDefs = function () { for (var e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [], n = {}, r = {}, a = 0, s = t.length; a < s; a++)for (var o = t[a].joints, l = 0, c = o.length; l < c; l++)e[o[l]].isBone = !0; for (var h = 0, u = e.length; h < u; h++) { var d = e[h]; void 0 !== d.mesh && (void 0 === n[d.mesh] && (n[d.mesh] = r[d.mesh] = 0), n[d.mesh]++, void 0 !== d.skin && (i[d.mesh].isSkinnedMesh = !0)) } this.json.meshReferences = n, this.json.meshUses = r }, H.prototype.getDependency = function (e, t) { var n = e + ":" + t, r = this.cache.get(n); if (!r) { switch (e) { case "scene": r = this.loadScene(t); break; case "node": r = this.loadNode(t); break; case "mesh": r = this.loadMesh(t); break; case "accessor": r = this.loadAccessor(t); break; case "bufferView": r = this.loadBufferView(t); break; case "buffer": r = this.loadBuffer(t); break; case "material": r = this.loadMaterial(t); break; case "texture": r = this.loadTexture(t); break; case "skin": r = this.loadSkin(t); break; case "animation": r = this.loadAnimation(t); break; case "camera": r = this.loadCamera(t); break; case "light": r = this.extensions[i.KHR_LIGHTS_PUNCTUAL].loadLight(t); break; default: throw new Error("Unknown type: " + e) }this.cache.add(n, r) } return r }, H.prototype.getDependencies = function (e) { var t = this.cache.get(e); if (!t) { var i = this, n = this.json[e + ("mesh" === e ? "es" : "s")] || []; t = Promise.all(n.map((function (t, n) { return i.getDependency(e, n) }))), this.cache.add(e, t) } return t }, H.prototype.loadBuffer = function (e) { var t = this.json.buffers[e], n = this.fileLoader; if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported."); if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[i.KHR_BINARY_GLTF].body); var r = this.options; return new Promise((function (e, i) { n.load(D(t.uri, r.path), e, void 0, (function () { i(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')) })) })) }, H.prototype.loadBufferView = function (e) { var t = this.json.bufferViews[e]; return this.getDependency("buffer", t.buffer).then((function (e) { var i = t.byteLength || 0, n = t.byteOffset || 0; return e.slice(n, n + i) })) }, H.prototype.loadAccessor = function (e) { var t = this, i = this.json, n = this.json.accessors[e]; if (void 0 === n.bufferView && void 0 === n.sparse) return Promise.resolve(null); var r = []; return void 0 !== n.bufferView ? r.push(this.getDependency("bufferView", n.bufferView)) : r.push(null), void 0 !== n.sparse && (r.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(r).then((function (e) { var r, a = e[0], s = C[n.type], o = M[n.componentType], l = o.BYTES_PER_ELEMENT, c = l * s, h = n.byteOffset || 0, u = void 0 !== n.bufferView ? i.bufferViews[n.bufferView].byteStride : void 0, d = !0 === n.normalized; if (u && u !== c) { var p = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType, f = t.cache.get(p); f || (f = new Ki(new o(a), u / l), t.cache.add(p, f)), r = new Qi(f, s, h / l, d) } else r = new pe(null === a ? new o(n.count * s) : new o(a, h, n.count * s), s, d); if (void 0 !== n.sparse) { var m = C.SCALAR, g = M[n.sparse.indices.componentType], v = n.sparse.indices.byteOffset || 0, y = n.sparse.values.byteOffset || 0, _ = new g(e[1], v, n.sparse.count * m), x = new o(e[2], y, n.sparse.count * s); null !== a && r.setArray(r.array.slice()); for (var b = 0, w = _.length; b < w; b++) { var T = _[b]; if (r.setX(T, x[b * s]), s >= 2 && r.setY(T, x[b * s + 1]), s >= 3 && r.setZ(T, x[b * s + 2]), s >= 4 && r.setW(T, x[b * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.") } } return r })) }, H.prototype.loadTexture = function (e) { var t, n = this, r = this.json, a = this.options, s = this.textureLoader, o = window.URL || window.webkitURL, l = r.textures[e], c = l.extensions || {}, h = (t = c[i.MSFT_TEXTURE_DDS] ? r.images[c[i.MSFT_TEXTURE_DDS].source] : r.images[l.source]).uri, u = !1; return void 0 !== t.bufferView && (h = n.getDependency("bufferView", t.bufferView).then((function (e) { u = !0; var i = new Blob([e], { type: t.mimeType }); return h = o.createObjectURL(i) }))), Promise.resolve(h).then((function (e) { var t = us.Handlers.get(e); return t || (t = c[i.MSFT_TEXTURE_DDS] ? n.extensions[i.MSFT_TEXTURE_DDS].ddsLoader : s), new Promise((function (i, n) { t.load(D(e, a.path), i, void 0, n) })) })).then((function (e) { !0 === u && o.revokeObjectURL(h), e.flipY = !1, void 0 !== l.name && (e.name = l.name), t.mimeType in k && (e.format = k[t.mimeType]); var i = (r.samplers || {})[l.sampler] || {}; return e.magFilter = S[i.magFilter] || 1006, e.minFilter = S[i.minFilter] || 1008, e.wrapS = E[i.wrapS] || 1e3, e.wrapT = E[i.wrapT] || 1e3, e })) }, H.prototype.assignTexture = function (e, t, n) { var r = this; return this.getDependency("texture", n.index).then((function (a) { if (!a.isCompressedTexture) switch (t) { case "aoMap": case "emissiveMap": case "metalnessMap": case "normalMap": case "roughnessMap": a.format = 1022 }if (r.extensions[i.KHR_TEXTURE_TRANSFORM]) { var s = void 0 !== n.extensions ? n.extensions[i.KHR_TEXTURE_TRANSFORM] : void 0; s && (a = r.extensions[i.KHR_TEXTURE_TRANSFORM].extendTexture(a, s)) } e[t] = a })) }, H.prototype.assignFinalMaterial = function (e) { var t = e.geometry, n = e.material, r = this.extensions, a = void 0 !== t.attributes.tangent, s = void 0 !== t.attributes.color, o = void 0 === t.attributes.normal, l = !0 === e.isSkinnedMesh, c = Object.keys(t.morphAttributes).length > 0, h = c && void 0 !== t.morphAttributes.normal; if (e.isPoints) { var u = "PointsMaterial:" + n.uuid, d = this.cache.get(u); d || (d = new un, Oe.prototype.copy.call(d, n), d.color.copy(n.color), d.map = n.map, d.lights = !1, this.cache.add(u, d)), n = d } else if (e.isLine) { u = "LineBasicMaterial:" + n.uuid; var p = this.cache.get(u); p || (p = new on, Oe.prototype.copy.call(p, n), p.color.copy(n.color), p.lights = !1, this.cache.add(u, p)), n = p } if (a || s || o || l || c) { u = "ClonedMaterial:" + n.uuid + ":"; n.isGLTFSpecularGlossinessMaterial && (u += "specular-glossiness:"), l && (u += "skinning:"), a && (u += "vertex-tangents:"), s && (u += "vertex-colors:"), o && (u += "flat-shading:"), c && (u += "morph-targets:"), h && (u += "morph-normals:"); var f = this.cache.get(u); f || (f = n.isGLTFSpecularGlossinessMaterial ? r[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(n) : n.clone(), l && (f.skinning = !0), a && (f.vertexTangents = !0), s && (f.vertexColors = 2), o && (f.flatShading = !0), c && (f.morphTargets = !0), h && (f.morphNormals = !0), this.cache.add(u, f)), n = f } n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && (console.log("THREE.GLTFLoader: Duplicating UVs to support aoMap."), t.addAttribute("uv2", new pe(t.attributes.uv.array, 2))), n.isGLTFSpecularGlossinessMaterial && (e.onBeforeRender = r[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms), e.material = n }, H.prototype.loadMaterial = function (e) { var t, n = this.json, r = this.extensions, a = n.materials[e], s = {}, o = a.extensions || {}, c = []; if (o[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) { var h = r[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]; t = h.getMaterialType(), c.push(h.extendParams(s, a, this)) } else if (o[i.KHR_MATERIALS_UNLIT]) { var u = r[i.KHR_MATERIALS_UNLIT]; t = u.getMaterialType(), c.push(u.extendParams(s, a, this)) } else { t = Or; var d = a.pbrMetallicRoughness || {}; if (s.color = new X(1, 1, 1), s.opacity = 1, Array.isArray(d.baseColorFactor)) { var p = d.baseColorFactor; s.color.fromArray(p), s.opacity = p[3] } void 0 !== d.baseColorTexture && c.push(this.assignTexture(s, "map", d.baseColorTexture)), s.metalness = void 0 !== d.metallicFactor ? d.metallicFactor : 1, s.roughness = void 0 !== d.roughnessFactor ? d.roughnessFactor : 1, void 0 !== d.metallicRoughnessTexture && (c.push(this.assignTexture(s, "metalnessMap", d.metallicRoughnessTexture)), c.push(this.assignTexture(s, "roughnessMap", d.metallicRoughnessTexture))) } !0 === a.doubleSided && (s.side = 2); var f = a.alphaMode || R; return f === I ? s.transparent = !0 : (s.transparent = !1, f === O && (s.alphaTest = void 0 !== a.alphaCutoff ? a.alphaCutoff : .5)), void 0 !== a.normalTexture && t !== Ye && (c.push(this.assignTexture(s, "normalMap", a.normalTexture)), s.normalScale = new l(1, 1), void 0 !== a.normalTexture.scale && s.normalScale.set(a.normalTexture.scale, a.normalTexture.scale)), void 0 !== a.occlusionTexture && t !== Ye && (c.push(this.assignTexture(s, "aoMap", a.occlusionTexture)), void 0 !== a.occlusionTexture.strength && (s.aoMapIntensity = a.occlusionTexture.strength)), void 0 !== a.emissiveFactor && t !== Ye && (s.emissive = (new X).fromArray(a.emissiveFactor)), void 0 !== a.emissiveTexture && t !== Ye && c.push(this.assignTexture(s, "emissiveMap", a.emissiveTexture)), Promise.all(c).then((function () { var e; return e = t === We ? r[i.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(s) : new t(s), void 0 !== a.name && (e.name = a.name), e.map && (e.map.encoding = 3001), e.emissiveMap && (e.emissiveMap.encoding = 3001), e.specularMap && (e.specularMap.encoding = 3001), N(e, a), a.extensions && z(r, e, a), e })) }, H.prototype.loadGeometries = function (e) { var t = this, n = this.extensions, r = this.primitiveCache; function a(e) { return n[i.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (i) { return V(i, e, t) })) } for (var s, o, l = [], c = 0, h = e.length; c < h; c++) { var u, d = e[c], p = (o = void 0, (o = (s = d).extensions && s.extensions[i.KHR_DRACO_MESH_COMPRESSION]) ? "draco:" + o.bufferView + ":" + o.indices + ":" + G(o.attributes) : s.indices + ":" + G(s.attributes) + ":" + s.mode), f = r[p]; if (f) l.push(f.promise); else u = d.extensions && d.extensions[i.KHR_DRACO_MESH_COMPRESSION] ? a(d) : V(new Ee, d, t), r[p] = { primitive: d, promise: u }, l.push(u) } return Promise.all(l) }, H.prototype.loadMesh = function (e) { for (var t = this, i = this.json, n = (this.extensions, i.meshes[e]), r = n.primitives, a = [], s = 0, o = r.length; s < o; s++) { var l = void 0 === r[s].material ? g = g || new Or({ color: 16777215, emissive: 0, metalness: 1, roughness: 1, transparent: !1, depthTest: !0, side: 0 }) : this.getDependency("material", r[s].material); a.push(l) } return Promise.all(a).then((function (i) { return t.loadGeometries(r).then((function (a) { for (var s = [], o = 0, l = a.length; o < l; o++) { var c, h = a[o], u = r[o], d = i[o]; if (u.mode === b || u.mode === w || u.mode === T || void 0 === u.mode) !0 === (c = !0 === n.isSkinnedMesh ? new rn(h, d) : new qe(h, d)).isSkinnedMesh && c.normalizeSkinWeights(), u.mode === w ? c.drawMode = 1 : u.mode === T && (c.drawMode = 2); else if (u.mode === y) c = new cn(h, d); else if (u.mode === x) c = new ln(h, d); else if (u.mode === _) c = new hn(h, d); else { if (u.mode !== v) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + u.mode); c = new dn(h, d) } Object.keys(c.geometry.morphAttributes).length > 0 && F(c, n), c.name = n.name || "mesh_" + e, a.length > 1 && (c.name += "_" + o), N(c, n), t.assignFinalMaterial(c), s.push(c) } if (1 === s.length) return s[0]; var p = new Ii; for (o = 0, l = s.length; o < l; o++)p.add(s[o]); return p })) })) }, H.prototype.loadCamera = function (e) { var t, i = this.json.cameras[e], n = i[i.type]; if (n) return "perspective" === i.type ? t = new Di(o.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : "orthographic" === i.type && (t = new Ga(n.xmag / -2, n.xmag / 2, n.ymag / 2, n.ymag / -2, n.znear, n.zfar)), void 0 !== i.name && (t.name = i.name), N(t, i), Promise.resolve(t); console.warn("THREE.GLTFLoader: Missing camera parameters.") }, H.prototype.loadSkin = function (e) { var t = this.json.skins[e], i = { joints: t.joints }; return void 0 === t.inverseBindMatrices ? Promise.resolve(i) : this.getDependency("accessor", t.inverseBindMatrices).then((function (e) { return i.inverseBindMatrices = e, i })) }, H.prototype.loadAnimation = function (e) { for (var t = this.json.animations[e], i = [], n = [], r = [], a = [], s = [], o = 0, l = t.channels.length; o < l; o++) { var c = t.channels[o], h = t.samplers[c.sampler], u = c.target, d = void 0 !== u.node ? u.node : u.id, p = void 0 !== t.parameters ? t.parameters[h.input] : h.input, f = void 0 !== t.parameters ? t.parameters[h.output] : h.output; i.push(this.getDependency("node", d)), n.push(this.getDependency("accessor", p)), r.push(this.getDependency("accessor", f)), a.push(h), s.push(u) } return Promise.all([Promise.all(i), Promise.all(n), Promise.all(r), Promise.all(a), Promise.all(s)]).then((function (i) { for (var n = i[0], r = i[1], a = i[2], s = i[3], o = i[4], l = [], c = 0, h = n.length; c < h; c++) { var u = n[c], d = r[c], p = a[c], f = s[c], g = o[c]; if (void 0 !== u) { var v; switch (u.updateMatrix(), u.matrixAutoUpdate = !0, P[g.path]) { case P.weights: v = qr; break; case P.rotation: v = Zr; break; case P.position: case P.scale: default: v = Qr }var y = u.name ? u.name : u.uuid, _ = void 0 !== f.interpolation ? L[f.interpolation] : 2301, x = []; P[g.path] === P.weights ? u.traverse((function (e) { !0 === e.isMesh && e.morphTargetInfluences && x.push(e.name ? e.name : e.uuid) })) : x.push(y); for (var b = 0, w = x.length; b < w; b++) { var T = new v(x[b] + "." + P[g.path], d.array, p.array, _); "CUBICSPLINE" === f.interpolation && (T.createInterpolant = function (e) { return new m(this.times, this.values, this.getValueSize() / 3, e) }, T.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), l.push(T) } } } return new ea(void 0 !== t.name ? t.name : "animation_" + e, void 0, l) })) }, H.prototype.loadNode = function (e) { var t = this.json, n = this.extensions, r = this, a = t.meshReferences, s = t.meshUses, o = t.nodes[e]; return (!0 === o.isBone ? Promise.resolve(new sn) : void 0 !== o.mesh ? r.getDependency("mesh", o.mesh).then((function (e) { var t; if (a[o.mesh] > 1) { var i = s[o.mesh]++; (t = e.clone()).name += "_instance_" + i, t.onBeforeRender = e.onBeforeRender; for (var n = 0, r = t.children.length; n < r; n++)t.children[n].name += "_instance_" + i, t.children[n].onBeforeRender = e.children[n].onBeforeRender } else t = e; return void 0 !== o.weights && t.traverse((function (e) { if (e.isMesh) for (var t = 0, i = o.weights.length; t < i; t++)e.morphTargetInfluences[t] = o.weights[t] })), t })) : void 0 !== o.camera ? r.getDependency("camera", o.camera) : o.extensions && o.extensions[i.KHR_LIGHTS_PUNCTUAL] && void 0 !== o.extensions[i.KHR_LIGHTS_PUNCTUAL].light ? r.getDependency("light", o.extensions[i.KHR_LIGHTS_PUNCTUAL].light) : Promise.resolve(new le)).then((function (e) { if (void 0 !== o.name && (e.userData.name = o.name, e.name = Gs.sanitizeNodeName(o.name)), N(e, o), o.extensions && z(n, e, o), void 0 !== o.matrix) { var t = new B; t.fromArray(o.matrix), e.applyMatrix(t) } else void 0 !== o.translation && e.position.fromArray(o.translation), void 0 !== o.rotation && e.quaternion.fromArray(o.rotation), void 0 !== o.scale && e.scale.fromArray(o.scale); return e })) }, H.prototype.loadScene = function () { function e(t, i, n, r) { var a = n.nodes[t]; return r.getDependency("node", t).then((function (e) { return void 0 === a.skin ? e : r.getDependency("skin", a.skin).then((function (e) { for (var i = [], n = 0, a = (t = e).joints.length; n < a; n++)i.push(r.getDependency("node", t.joints[n])); return Promise.all(i) })).then((function (i) { for (var n = !0 === e.isGroup ? e.children : [e], r = 0, a = n.length; r < a; r++) { for (var s = n[r], o = [], l = [], c = 0, h = i.length; c < h; c++) { var u = i[c]; if (u) { o.push(u); var d = new B; void 0 !== t.inverseBindMatrices && d.fromArray(t.inverseBindMatrices.array, 16 * c), l.push(d) } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]) } s.bind(new an(o, l), s.matrixWorld) } return e })); var t })).then((function (t) { i.add(t); var s = []; if (a.children) for (var o = a.children, l = 0, c = o.length; l < c; l++) { var h = o[l]; s.push(e(h, t, n, r)) } return Promise.all(s) })) } return function (t) { var i = this.json, n = this.extensions, r = this.json.scenes[t], a = new Zi; void 0 !== r.name && (a.name = r.name), N(a, r), r.extensions && z(n, a, r); for (var s = r.nodes || [], o = [], l = 0, c = s.length; l < c; l++)o.push(e(s[l], a, i, this)); return Promise.all(o).then((function () { return a })) } }(), e }(); const vo = [new X(13882323), new X(14144716), new X(14407108), new X(14735290), new X(14997937), new X(15260327), new X(15588507), new X(15851406), new X(16179582), new X(16639588), new X(16639588)], yo = new na, _o = (() => { let e = new Array; const t = new Va(11321086, .35); t.name = "Ambient"; const i = new Ha(13882323, 1.5); i.position.x = 0, i.position.y = 500, i.position.z = 200, i.name = "Sun"; const n = new Ha(11321086, 0); return n.position.x = -600, n.position.y = 500, n.position.z = 200, n.name = "Moon", e.push(t, i, n), e })(), xo = new Yi({ antialias: !0, alpha: !0, autoClear: !0 }); xo.gammaOutput = !0; const bo = (e, t, i, n) => { if (So()) { let e = new Zi; e.name = i; let t = new Di(55, window.innerWidth / window.innerHeight, 1e3, 6e3); t.updateProjectionMatrix(); let n = wo(), r = To(); return e.add(t), e.add(n), e.add(r), Mo(n), { mainScene: e, renderer: xo, camera: t } } { let n = e.scene; n.name = i; let r = wo(), a = To(); n.add(r), n.add(a), Mo(r), n.getObjectByName("AppleGroup").add(t.scene); for (let e = 0; e < _o.length; e++)n.add(_o[e]); const s = new Hs(e.scene); s.clipAction(e.animations[0]).play(); const o = new _s, l = new Hs(t.scene); return l.clipAction(t.animations[0]).play(), { mainScene: n, renderer: xo, animation: s, wormDance: l, clock: o } } }, wo = () => { let e = new qe(new Ce(1500, 1500, 1500), new Ye({ map: (new ha).load("assets/3D/sky/clouds.png", (function (e) { e.wrapS = e.wrapT = 1e3, e.offset.set(0, So() ? -.6 : -.55), e.repeat.set(2, 2) })), transparent: !0, opacity: So() ? 0 : .4, color: 16777215, side: 1 })); return e.name = "sky", e }, To = () => { const e = So(); let t = new de, i = e ? 2e3 : 6e3; for (let n = 0; n < i; n++) { let i = new h; i.x = o.randFloatSpread(e ? 4e3 : 1500), i.y = o.randFloatSpread(1500), i.z = e ? o.randFloat(-700, -1700) : o.randFloat(-200, -800), t.vertices.push(i) } let n = new dn(t, new un({ size: e ? 3 : 2, opacity: e ? 1 : 0, transparent: !0 })); return n.name = "nightSky", n }, Mo = e => { let t = 0; setInterval((function () { e.material.map.offset.x = t, t -= 3e-4 }), 30) }, So = () => { let e = !1; var t; return t = navigator.userAgent || navigator.vendor || window.opera, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0), e }; var Eo = i(0), Co = (Eo.k.document || {}).documentElement, Ao = Eo.k, Po = function (e, t) { var i = "x" === t ? "Width" : "Height", n = "scroll" + i, r = "client" + i, a = document.body; return e === Ao || e === Co || e === a ? Math.max(Co[n], a[n]) - (Ao["inner" + i] || Co[r] || a[r]) : e[n] - e["offset" + i] }, Lo = function (e, t) { var i = "scroll" + ("x" === t ? "Left" : "Top"); return e === Ao && (null != e.pageXOffset ? i = "page" + t.toUpperCase() + "Offset" : e = null != Co[i] ? Co : document.body), function () { return e[i] } }, Ro = function (e, t) { var i, n = (i = e, "string" == typeof i && (i = TweenLite.selector(i)), i.length && i !== Ao && i[0] && i[0].style && !i.nodeType && (i = i[0]), i === Ao || i.nodeType && i.style ? i : null).getBoundingClientRect(), r = document.body, a = !t || t === Ao || t === r, s = a ? { top: Co.clientTop - (window.pageYOffset || Co.scrollTop || r.scrollTop || 0), left: Co.clientLeft - (window.pageXOffset || Co.scrollLeft || r.scrollLeft || 0) } : t.getBoundingClientRect(), o = { x: n.left - s.left, y: n.top - s.top }; return !a && t && (o.x += Lo(t, "x")(), o.y += Lo(t, "y")()), o }, Oo = function (e, t, i, n) { var r = typeof e; return isNaN(e) ? "string" === r && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) + n : "max" === e ? Po(t, i) : Math.min(Po(t, i), Ro(e, t)[i]) : parseFloat(e) }, Io = Eo.k._gsDefine.plugin({ propName: "scrollTo", API: 2, global: !0, version: "1.9.2", init: function (e, t, i) { return this._wdw = e === Ao, this._target = e, this._tween = i, "object" != typeof t ? "string" == typeof (t = { y: t }).y && "max" !== t.y && "=" !== t.y.charAt(1) && (t.x = t.y) : t.nodeType && (t = { y: t, x: t }), this.vars = t, this._autoKill = !1 !== t.autoKill, this.getX = Lo(e, "x"), this.getY = Lo(e, "y"), this.x = this.xPrev = this.getX(), this.y = this.yPrev = this.getY(), null != t.x ? (this._addTween(this, "x", this.x, Oo(t.x, e, "x", this.x) - (t.offsetX || 0), "scrollTo_x", !0), this._overwriteProps.push("scrollTo_x")) : this.skipX = !0, null != t.y ? (this._addTween(this, "y", this.y, Oo(t.y, e, "y", this.y) - (t.offsetY || 0), "scrollTo_y", !0), this._overwriteProps.push("scrollTo_y")) : this.skipY = !0, !0 }, set: function (e) { this._super.setRatio.call(this, e); var t = this._wdw || !this.skipX ? this.getX() : this.xPrev, i = this._wdw || !this.skipY ? this.getY() : this.yPrev, n = i - this.yPrev, r = t - this.xPrev, a = Io.autoKillThreshold; this.x < 0 && (this.x = 0), this.y < 0 && (this.y = 0), this._autoKill && (!this.skipX && (r > a || r < -a) && t < Po(this._target, "x") && (this.skipX = !0), !this.skipY && (n > a || n < -a) && i < Po(this._target, "y") && (this.skipY = !0), this.skipX && this.skipY && (this._tween.kill(), this.vars.onAutoKill && this.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []))), this._wdw ? Ao.scrollTo(this.skipX ? t : this.x, this.skipY ? i : this.y) : (this.skipY || (this._target.scrollTop = this.y), this.skipX || (this._target.scrollLeft = this.x)), this.xPrev = this.x, this.yPrev = this.y } }), ko = Io.prototype;
/*!
 * VERSION: 1.9.2
 * DATE: 2019-02-07
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/Io.max = Po, Io.getOffset = Ro, Io.buildGetter = Lo, Io.autoKillThreshold = 7, ko._kill = function (e) { return e.scrollTo_x && (this.skipX = !0), e.scrollTo_y && (this.skipY = !0), this._super._kill.call(this, e) }; var Do = i(4), zo = i(3), No = i(1), Bo = i.n(No), Fo = "undefined" == typeof document ? { body: {}, addEventListener: function () { }, removeEventListener: function () { }, activeElement: { blur: function () { }, nodeName: "" }, querySelector: function () { return null }, querySelectorAll: function () { return [] }, getElementById: function () { return null }, createEvent: function () { return { initEvent: function () { } } }, createElement: function () { return { children: [], childNodes: [], style: {}, setAttribute: function () { }, getElementsByTagName: function () { return [] } } }, location: { hash: "" } } : document, Go = "undefined" == typeof window ? { document: Fo, navigator: { userAgent: "" }, location: {}, history: {}, CustomEvent: function () { return this }, addEventListener: function () { }, removeEventListener: function () { }, getComputedStyle: function () { return { getPropertyValue: function () { return "" } } }, Image: function () { }, Date: function () { }, screen: {}, setTimeout: function () { }, clearTimeout: function () { } } : window; class Uo { constructor(e) { const t = this; for (let i = 0; i < e.length; i += 1)t[i] = e[i]; return t.length = e.length, this } } function Ho(e, t) { const i = []; let n = 0; if (e && !t && e instanceof Uo) return e; if (e) if ("string" == typeof e) { let r, a; const s = e.trim(); if (s.indexOf("<") >= 0 && s.indexOf(">") >= 0) { let e = "div"; for (0 === s.indexOf("<li") && (e = "ul"), 0 === s.indexOf("<tr") && (e = "tbody"), 0 !== s.indexOf("<td") && 0 !== s.indexOf("<th") || (e = "tr"), 0 === s.indexOf("<tbody") && (e = "table"), 0 === s.indexOf("<option") && (e = "select"), a = Fo.createElement(e), a.innerHTML = s, n = 0; n < a.childNodes.length; n += 1)i.push(a.childNodes[n]) } else for (r = t || "#" !== e[0] || e.match(/[ .<>:~]/) ? (t || Fo).querySelectorAll(e.trim()) : [Fo.getElementById(e.trim().split("#")[1])], n = 0; n < r.length; n += 1)r[n] && i.push(r[n]) } else if (e.nodeType || e === Go || e === Fo) i.push(e); else if (e.length > 0 && e[0].nodeType) for (n = 0; n < e.length; n += 1)i.push(e[n]); return new Uo(i) } function Vo(e) { const t = []; for (let i = 0; i < e.length; i += 1)-1 === t.indexOf(e[i]) && t.push(e[i]); return t } Ho.fn = Uo.prototype, Ho.Class = Uo, Ho.Dom7 = Uo; "resize scroll".split(" "); const jo = { addClass: function (e) { if (void 0 === e) return this; const t = e.split(" "); for (let e = 0; e < t.length; e += 1)for (let i = 0; i < this.length; i += 1)void 0 !== this[i] && void 0 !== this[i].classList && this[i].classList.add(t[e]); return this }, removeClass: function (e) { const t = e.split(" "); for (let e = 0; e < t.length; e += 1)for (let i = 0; i < this.length; i += 1)void 0 !== this[i] && void 0 !== this[i].classList && this[i].classList.remove(t[e]); return this }, hasClass: function (e) { return !!this[0] && this[0].classList.contains(e) }, toggleClass: function (e) { const t = e.split(" "); for (let e = 0; e < t.length; e += 1)for (let i = 0; i < this.length; i += 1)void 0 !== this[i] && void 0 !== this[i].classList && this[i].classList.toggle(t[e]); return this }, attr: function (e, t) { if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0; for (let i = 0; i < this.length; i += 1)if (2 === arguments.length) this[i].setAttribute(e, t); else for (const t in e) this[i][t] = e[t], this[i].setAttribute(t, e[t]); return this }, removeAttr: function (e) { for (let t = 0; t < this.length; t += 1)this[t].removeAttribute(e); return this }, data: function (e, t) { let i; if (void 0 !== t) { for (let n = 0; n < this.length; n += 1)i = this[n], i.dom7ElementDataStorage || (i.dom7ElementDataStorage = {}), i.dom7ElementDataStorage[e] = t; return this } if (i = this[0], i) { if (i.dom7ElementDataStorage && e in i.dom7ElementDataStorage) return i.dom7ElementDataStorage[e]; const t = i.getAttribute(`data-${e}`); return t || void 0 } }, transform: function (e) { for (let t = 0; t < this.length; t += 1) { const i = this[t].style; i.webkitTransform = e, i.transform = e } return this }, transition: function (e) { "string" != typeof e && (e = `${e}ms`); for (let t = 0; t < this.length; t += 1) { const i = this[t].style; i.webkitTransitionDuration = e, i.transitionDuration = e } return this }, on: function (...e) { let [t, i, n, r] = e; function a(e) { const t = e.target; if (!t) return; const r = e.target.dom7EventData || []; if (r.indexOf(e) < 0 && r.unshift(e), Ho(t).is(i)) n.apply(t, r); else { const e = Ho(t).parents(); for (let t = 0; t < e.length; t += 1)Ho(e[t]).is(i) && n.apply(e[t], r) } } function s(e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), n.apply(this, t) } "function" == typeof e[1] && ([t, n, r] = e, i = void 0), r || (r = !1); const o = t.split(" "); let l; for (let e = 0; e < this.length; e += 1) { const t = this[e]; if (i) for (l = 0; l < o.length; l += 1) { const e = o[l]; t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({ listener: n, proxyListener: a }), t.addEventListener(e, a, r) } else for (l = 0; l < o.length; l += 1) { const e = o[l]; t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({ listener: n, proxyListener: s }), t.addEventListener(e, s, r) } } return this }, off: function (...e) { let [t, i, n, r] = e; "function" == typeof e[1] && ([t, n, r] = e, i = void 0), r || (r = !1); const a = t.split(" "); for (let e = 0; e < a.length; e += 1) { const t = a[e]; for (let e = 0; e < this.length; e += 1) { const a = this[e]; let s; if (!i && a.dom7Listeners ? s = a.dom7Listeners[t] : i && a.dom7LiveListeners && (s = a.dom7LiveListeners[t]), s && s.length) for (let e = s.length - 1; e >= 0; e -= 1) { const i = s[e]; n && i.listener === n || n && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === n ? (a.removeEventListener(t, i.proxyListener, r), s.splice(e, 1)) : n || (a.removeEventListener(t, i.proxyListener, r), s.splice(e, 1)) } } } return this }, trigger: function (...e) { const t = e[0].split(" "), i = e[1]; for (let n = 0; n < t.length; n += 1) { const r = t[n]; for (let t = 0; t < this.length; t += 1) { const n = this[t]; let a; try { a = new Go.CustomEvent(r, { detail: i, bubbles: !0, cancelable: !0 }) } catch (e) { a = Fo.createEvent("Event"), a.initEvent(r, !0, !0), a.detail = i } n.dom7EventData = e.filter((e, t) => t > 0), n.dispatchEvent(a), n.dom7EventData = [], delete n.dom7EventData } } return this }, transitionEnd: function (e) { const t = ["webkitTransitionEnd", "transitionend"], i = this; let n; function r(a) { if (a.target === this) for (e.call(this, a), n = 0; n < t.length; n += 1)i.off(t[n], r) } if (e) for (n = 0; n < t.length; n += 1)i.on(t[n], r); return this }, outerWidth: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null }, outerHeight: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null }, offset: function () { if (this.length > 0) { const e = this[0], t = e.getBoundingClientRect(), i = Fo.body, n = e.clientTop || i.clientTop || 0, r = e.clientLeft || i.clientLeft || 0, a = e === Go ? Go.scrollY : e.scrollTop, s = e === Go ? Go.scrollX : e.scrollLeft; return { top: t.top + a - n, left: t.left + s - r } } return null }, css: function (e, t) { let i; if (1 === arguments.length) { if ("string" != typeof e) { for (i = 0; i < this.length; i += 1)for (let t in e) this[i].style[t] = e[t]; return this } if (this[0]) return Go.getComputedStyle(this[0], null).getPropertyValue(e) } if (2 === arguments.length && "string" == typeof e) { for (i = 0; i < this.length; i += 1)this[i].style[e] = t; return this } return this }, each: function (e) { if (!e) return this; for (let t = 0; t < this.length; t += 1)if (!1 === e.call(this[t], t, this[t])) return this; return this }, html: function (e) { if (void 0 === e) return this[0] ? this[0].innerHTML : void 0; for (let t = 0; t < this.length; t += 1)this[t].innerHTML = e; return this }, text: function (e) { if (void 0 === e) return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1)this[t].textContent = e; return this }, is: function (e) { const t = this[0]; let i, n; if (!t || void 0 === e) return !1; if ("string" == typeof e) { if (t.matches) return t.matches(e); if (t.webkitMatchesSelector) return t.webkitMatchesSelector(e); if (t.msMatchesSelector) return t.msMatchesSelector(e); for (i = Ho(e), n = 0; n < i.length; n += 1)if (i[n] === t) return !0; return !1 } if (e === Fo) return t === Fo; if (e === Go) return t === Go; if (e.nodeType || e instanceof Uo) { for (i = e.nodeType ? [e] : e, n = 0; n < i.length; n += 1)if (i[n] === t) return !0; return !1 } return !1 }, index: function () { let e, t = this[0]; if (t) { for (e = 0; null !== (t = t.previousSibling);)1 === t.nodeType && (e += 1); return e } }, eq: function (e) { if (void 0 === e) return this; const t = this.length; let i; return e > t - 1 ? new Uo([]) : e < 0 ? (i = t + e, new Uo(i < 0 ? [] : [this[i]])) : new Uo([this[e]]) }, append: function (...e) { let t; for (let i = 0; i < e.length; i += 1) { t = e[i]; for (let e = 0; e < this.length; e += 1)if ("string" == typeof t) { const i = Fo.createElement("div"); for (i.innerHTML = t; i.firstChild;)this[e].appendChild(i.firstChild) } else if (t instanceof Uo) for (let i = 0; i < t.length; i += 1)this[e].appendChild(t[i]); else this[e].appendChild(t) } return this }, prepend: function (e) { let t, i; for (t = 0; t < this.length; t += 1)if ("string" == typeof e) { const n = Fo.createElement("div"); for (n.innerHTML = e, i = n.childNodes.length - 1; i >= 0; i -= 1)this[t].insertBefore(n.childNodes[i], this[t].childNodes[0]) } else if (e instanceof Uo) for (i = 0; i < e.length; i += 1)this[t].insertBefore(e[i], this[t].childNodes[0]); else this[t].insertBefore(e, this[t].childNodes[0]); return this }, next: function (e) { return this.length > 0 ? e ? this[0].nextElementSibling && Ho(this[0].nextElementSibling).is(e) ? new Uo([this[0].nextElementSibling]) : new Uo([]) : this[0].nextElementSibling ? new Uo([this[0].nextElementSibling]) : new Uo([]) : new Uo([]) }, nextAll: function (e) { const t = []; let i = this[0]; if (!i) return new Uo([]); for (; i.nextElementSibling;) { const n = i.nextElementSibling; e ? Ho(n).is(e) && t.push(n) : t.push(n), i = n } return new Uo(t) }, prev: function (e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && Ho(t.previousElementSibling).is(e) ? new Uo([t.previousElementSibling]) : new Uo([]) : t.previousElementSibling ? new Uo([t.previousElementSibling]) : new Uo([]) } return new Uo([]) }, prevAll: function (e) { const t = []; let i = this[0]; if (!i) return new Uo([]); for (; i.previousElementSibling;) { const n = i.previousElementSibling; e ? Ho(n).is(e) && t.push(n) : t.push(n), i = n } return new Uo(t) }, parent: function (e) { const t = []; for (let i = 0; i < this.length; i += 1)null !== this[i].parentNode && (e ? Ho(this[i].parentNode).is(e) && t.push(this[i].parentNode) : t.push(this[i].parentNode)); return Ho(Vo(t)) }, parents: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { let n = this[i].parentNode; for (; n;)e ? Ho(n).is(e) && t.push(n) : t.push(n), n = n.parentNode } return Ho(Vo(t)) }, closest: function (e) { let t = this; return void 0 === e ? new Uo([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) }, find: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { const n = this[i].querySelectorAll(e); for (let e = 0; e < n.length; e += 1)t.push(n[e]) } return new Uo(t) }, children: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { const n = this[i].childNodes; for (let i = 0; i < n.length; i += 1)e ? 1 === n[i].nodeType && Ho(n[i]).is(e) && t.push(n[i]) : 1 === n[i].nodeType && t.push(n[i]) } return new Uo(Vo(t)) }, filter: function (e) { const t = [], i = this; for (let n = 0; n < i.length; n += 1)e.call(i[n], n, i[n]) && t.push(i[n]); return new Uo(t) }, remove: function () { for (let e = 0; e < this.length; e += 1)this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this }, add: function (...e) { const t = this; let i, n; for (i = 0; i < e.length; i += 1) { const r = Ho(e[i]); for (n = 0; n < r.length; n += 1)t[t.length] = r[n], t.length += 1 } return t }, styles: function () { return this[0] ? Go.getComputedStyle(this[0], null) : {} } }; Object.keys(jo).forEach(e => { Ho.fn[e] = Ho.fn[e] || jo[e] }); const Wo = { deleteProps(e) { const t = e; Object.keys(t).forEach(e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } }) }, nextTick: (e, t = 0) => setTimeout(e, t), now: () => Date.now(), getTranslate(e, t = "x") { let i, n, r; const a = Go.getComputedStyle(e, null); return Go.WebKitCSSMatrix ? (n = a.transform || a.webkitTransform, n.split(",").length > 6 && (n = n.split(", ").map(e => e.replace(",", ".")).join(", ")), r = new Go.WebKitCSSMatrix("none" === n ? "" : n)) : (r = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = r.toString().split(",")), "x" === t && (n = Go.WebKitCSSMatrix ? r.m41 : 16 === i.length ? parseFloat(i[12]) : parseFloat(i[4])), "y" === t && (n = Go.WebKitCSSMatrix ? r.m42 : 16 === i.length ? parseFloat(i[13]) : parseFloat(i[5])), n || 0 }, parseUrlQuery(e) { const t = {}; let i, n, r, a, s = e || Go.location.href; if ("string" == typeof s && s.length) for (s = s.indexOf("?") > -1 ? s.replace(/\S*\?/, "") : "", n = s.split("&").filter(e => "" !== e), a = n.length, i = 0; i < a; i += 1)r = n[i].replace(/#\S+/g, "").split("="), t[decodeURIComponent(r[0])] = void 0 === r[1] ? void 0 : decodeURIComponent(r[1]) || ""; return t }, isObject: e => "object" == typeof e && null !== e && e.constructor && e.constructor === Object, extend(...e) { const t = Object(e[0]); for (let i = 1; i < e.length; i += 1) { const n = e[i]; if (null != n) { const e = Object.keys(Object(n)); for (let i = 0, r = e.length; i < r; i += 1) { const r = e[i], a = Object.getOwnPropertyDescriptor(n, r); void 0 !== a && a.enumerable && (Wo.isObject(t[r]) && Wo.isObject(n[r]) ? Wo.extend(t[r], n[r]) : !Wo.isObject(t[r]) && Wo.isObject(n[r]) ? (t[r] = {}, Wo.extend(t[r], n[r])) : t[r] = n[r]) } } } return t } }, $o = { touch: Go.Modernizr && !0 === Go.Modernizr.touch || !!(Go.navigator.maxTouchPoints > 0 || "ontouchstart" in Go || Go.DocumentTouch && Fo instanceof Go.DocumentTouch), pointerEvents: !!Go.PointerEvent && "maxTouchPoints" in Go.navigator && Go.navigator.maxTouchPoints > 0, observer: "MutationObserver" in Go || "WebkitMutationObserver" in Go, passiveListener: function () { let e = !1; try { const t = Object.defineProperty({}, "passive", { get() { e = !0 } }); Go.addEventListener("testPassiveListener", null, t) } catch (e) { } return e }(), gestures: "ongesturestart" in Go }; class Xo { constructor(e = {}) { const t = this; t.params = e, t.eventsListeners = {}, t.params && t.params.on && Object.keys(t.params.on).forEach(e => { t.on(e, t.params.on[e]) }) } on(e, t, i) { const n = this; if ("function" != typeof t) return n; const r = i ? "unshift" : "push"; return e.split(" ").forEach(e => { n.eventsListeners[e] || (n.eventsListeners[e] = []), n.eventsListeners[e][r](t) }), n } once(e, t, i) { const n = this; if ("function" != typeof t) return n; function r(...i) { n.off(e, r), r.f7proxy && delete r.f7proxy, t.apply(n, i) } return r.f7proxy = t, n.on(e, r, i) } off(e, t) { const i = this; return i.eventsListeners ? (e.split(" ").forEach(e => { void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].length && i.eventsListeners[e].forEach((n, r) => { (n === t || n.f7proxy && n.f7proxy === t) && i.eventsListeners[e].splice(r, 1) }) }), i) : i } emit(...e) { const t = this; if (!t.eventsListeners) return t; let i, n, r; return "string" == typeof e[0] || Array.isArray(e[0]) ? (i = e[0], n = e.slice(1, e.length), r = t) : (i = e[0].events, n = e[0].data, r = e[0].context || t), (Array.isArray(i) ? i : i.split(" ")).forEach(e => { if (t.eventsListeners && t.eventsListeners[e]) { const i = []; t.eventsListeners[e].forEach(e => { i.push(e) }), i.forEach(e => { e.apply(r, n) }) } }), t } useModulesParams(e) { const t = this; t.modules && Object.keys(t.modules).forEach(i => { const n = t.modules[i]; n.params && Wo.extend(e, n.params) }) } useModules(e = {}) { const t = this; t.modules && Object.keys(t.modules).forEach(i => { const n = t.modules[i], r = e[i] || {}; n.instance && Object.keys(n.instance).forEach(e => { const i = n.instance[e]; t[e] = "function" == typeof i ? i.bind(t) : i }), n.on && t.on && Object.keys(n.on).forEach(e => { t.on(e, n.on[e]) }), n.create && n.create.bind(t)(r) }) } static set components(e) { this.use && this.use(e) } static installModule(e, ...t) { const i = this; i.prototype.modules || (i.prototype.modules = {}); const n = e.name || `${Object.keys(i.prototype.modules).length}_${Wo.now()}`; return i.prototype.modules[n] = e, e.proto && Object.keys(e.proto).forEach(t => { i.prototype[t] = e.proto[t] }), e.static && Object.keys(e.static).forEach(t => { i[t] = e.static[t] }), e.install && e.install.apply(i, t), i } static use(e, ...t) { const i = this; return Array.isArray(e) ? (e.forEach(e => i.installModule(e)), i) : i.installModule(e, ...t) } } var Yo = { updateSize: function () { const e = this; let t, i; const n = e.$el; t = void 0 !== e.params.width ? e.params.width : n[0].clientWidth, i = void 0 !== e.params.height ? e.params.height : n[0].clientHeight, 0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(n.css("padding-left"), 10) - parseInt(n.css("padding-right"), 10), i = i - parseInt(n.css("padding-top"), 10) - parseInt(n.css("padding-bottom"), 10), Wo.extend(e, { width: t, height: i, size: e.isHorizontal() ? t : i })) }, updateSlides: function () { const e = this, t = e.params, { $wrapperEl: i, size: n, rtlTranslate: r, wrongRTL: a } = e, s = e.virtual && t.virtual.enabled, o = s ? e.virtual.slides.length : e.slides.length, l = i.children(`.${e.params.slideClass}`), c = s ? e.virtual.slides.length : l.length; let h = []; const u = [], d = []; function p(e) { return !t.cssMode || e !== l.length - 1 } let f = t.slidesOffsetBefore; "function" == typeof f && (f = t.slidesOffsetBefore.call(e)); let m = t.slidesOffsetAfter; "function" == typeof m && (m = t.slidesOffsetAfter.call(e)); const g = e.snapGrid.length, v = e.snapGrid.length; let y, _, x = t.spaceBetween, b = -f, w = 0, T = 0; if (void 0 === n) return; "string" == typeof x && x.indexOf("%") >= 0 && (x = parseFloat(x.replace("%", "")) / 100 * n), e.virtualSize = -x, r ? l.css({ marginLeft: "", marginTop: "" }) : l.css({ marginRight: "", marginBottom: "" }), t.slidesPerColumn > 1 && (y = Math.floor(c / t.slidesPerColumn) === c / e.params.slidesPerColumn ? c : Math.ceil(c / t.slidesPerColumn) * t.slidesPerColumn, "auto" !== t.slidesPerView && "row" === t.slidesPerColumnFill && (y = Math.max(y, t.slidesPerView * t.slidesPerColumn))); const M = t.slidesPerColumn, S = y / M, E = Math.floor(c / t.slidesPerColumn); for (let i = 0; i < c; i += 1) { _ = 0; const r = l.eq(i); if (t.slidesPerColumn > 1) { let n, a, s; if ("row" === t.slidesPerColumnFill && t.slidesPerGroup > 1) { const e = Math.floor(i / (t.slidesPerGroup * t.slidesPerColumn)), o = i - t.slidesPerColumn * t.slidesPerGroup * e, l = 0 === e ? t.slidesPerGroup : Math.min(Math.ceil((c - e * M * t.slidesPerGroup) / M), t.slidesPerGroup); s = Math.floor(o / l), a = o - s * l + e * t.slidesPerGroup, n = a + s * y / M, r.css({ "-webkit-box-ordinal-group": n, "-moz-box-ordinal-group": n, "-ms-flex-order": n, "-webkit-order": n, order: n }) } else "column" === t.slidesPerColumnFill ? (a = Math.floor(i / M), s = i - a * M, (a > E || a === E && s === M - 1) && (s += 1, s >= M && (s = 0, a += 1))) : (s = Math.floor(i / S), a = i - s * S); r.css(`margin-${e.isHorizontal() ? "top" : "left"}`, 0 !== s && t.spaceBetween && `${t.spaceBetween}px`) } if ("none" !== r.css("display")) { if ("auto" === t.slidesPerView) { const i = Go.getComputedStyle(r[0], null), n = r[0].style.transform, a = r[0].style.webkitTransform; if (n && (r[0].style.transform = "none"), a && (r[0].style.webkitTransform = "none"), t.roundLengths) _ = e.isHorizontal() ? r.outerWidth(!0) : r.outerHeight(!0); else if (e.isHorizontal()) { const e = parseFloat(i.getPropertyValue("width")), t = parseFloat(i.getPropertyValue("padding-left")), n = parseFloat(i.getPropertyValue("padding-right")), r = parseFloat(i.getPropertyValue("margin-left")), a = parseFloat(i.getPropertyValue("margin-right")), s = i.getPropertyValue("box-sizing"); _ = s && "border-box" === s ? e + r + a : e + t + n + r + a } else { const e = parseFloat(i.getPropertyValue("height")), t = parseFloat(i.getPropertyValue("padding-top")), n = parseFloat(i.getPropertyValue("padding-bottom")), r = parseFloat(i.getPropertyValue("margin-top")), a = parseFloat(i.getPropertyValue("margin-bottom")), s = i.getPropertyValue("box-sizing"); _ = s && "border-box" === s ? e + r + a : e + t + n + r + a } n && (r[0].style.transform = n), a && (r[0].style.webkitTransform = a), t.roundLengths && (_ = Math.floor(_)) } else _ = (n - (t.slidesPerView - 1) * x) / t.slidesPerView, t.roundLengths && (_ = Math.floor(_)), l[i] && (e.isHorizontal() ? l[i].style.width = `${_}px` : l[i].style.height = `${_}px`); l[i] && (l[i].swiperSlideSize = _), d.push(_), t.centeredSlides ? (b = b + _ / 2 + w / 2 + x, 0 === w && 0 !== i && (b = b - n / 2 - x), 0 === i && (b = b - n / 2 - x), Math.abs(b) < .001 && (b = 0), t.roundLengths && (b = Math.floor(b)), T % t.slidesPerGroup == 0 && h.push(b), u.push(b)) : (t.roundLengths && (b = Math.floor(b)), (T - Math.min(e.params.slidesPerGroupSkip, T)) % e.params.slidesPerGroup == 0 && h.push(b), u.push(b), b = b + _ + x), e.virtualSize += _ + x, w = _, T += 1 } } let C; if (e.virtualSize = Math.max(e.virtualSize, n) + m, r && a && ("slide" === t.effect || "coverflow" === t.effect) && i.css({ width: `${e.virtualSize + t.spaceBetween}px` }), t.setWrapperSize && (e.isHorizontal() ? i.css({ width: `${e.virtualSize + t.spaceBetween}px` }) : i.css({ height: `${e.virtualSize + t.spaceBetween}px` })), t.slidesPerColumn > 1 && (e.virtualSize = (_ + t.spaceBetween) * y, e.virtualSize = Math.ceil(e.virtualSize / t.slidesPerColumn) - t.spaceBetween, e.isHorizontal() ? i.css({ width: `${e.virtualSize + t.spaceBetween}px` }) : i.css({ height: `${e.virtualSize + t.spaceBetween}px` }), t.centeredSlides)) { C = []; for (let i = 0; i < h.length; i += 1) { let n = h[i]; t.roundLengths && (n = Math.floor(n)), h[i] < e.virtualSize + h[0] && C.push(n) } h = C } if (!t.centeredSlides) { C = []; for (let i = 0; i < h.length; i += 1) { let r = h[i]; t.roundLengths && (r = Math.floor(r)), h[i] <= e.virtualSize - n && C.push(r) } h = C, Math.floor(e.virtualSize - n) - Math.floor(h[h.length - 1]) > 1 && h.push(e.virtualSize - n) } if (0 === h.length && (h = [0]), 0 !== t.spaceBetween && (e.isHorizontal() ? r ? l.filter(p).css({ marginLeft: `${x}px` }) : l.filter(p).css({ marginRight: `${x}px` }) : l.filter(p).css({ marginBottom: `${x}px` })), t.centeredSlides && t.centeredSlidesBounds) { let e = 0; d.forEach(i => { e += i + (t.spaceBetween ? t.spaceBetween : 0) }), e -= t.spaceBetween; const i = e - n; h = h.map(e => e < 0 ? -f : e > i ? i + m : e) } if (t.centerInsufficientSlides) { let e = 0; if (d.forEach(i => { e += i + (t.spaceBetween ? t.spaceBetween : 0) }), e -= t.spaceBetween, e < n) { const t = (n - e) / 2; h.forEach((e, i) => { h[i] = e - t }), u.forEach((e, i) => { u[i] = e + t }) } } Wo.extend(e, { slides: l, snapGrid: h, slidesGrid: u, slidesSizesGrid: d }), c !== o && e.emit("slidesLengthChange"), h.length !== g && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), u.length !== v && e.emit("slidesGridLengthChange"), (t.watchSlidesProgress || t.watchSlidesVisibility) && e.updateSlidesOffset() }, updateAutoHeight: function (e) { const t = this, i = []; let n, r = 0; if ("number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed), "auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) t.visibleSlides.each((e, t) => { i.push(t) }); else for (n = 0; n < Math.ceil(t.params.slidesPerView); n += 1) { const e = t.activeIndex + n; if (e > t.slides.length) break; i.push(t.slides.eq(e)[0]) } else i.push(t.slides.eq(t.activeIndex)[0]); for (n = 0; n < i.length; n += 1)if (void 0 !== i[n]) { const e = i[n].offsetHeight; r = e > r ? e : r } r && t.$wrapperEl.css("height", `${r}px`) }, updateSlidesOffset: function () { const e = this, t = e.slides; for (let i = 0; i < t.length; i += 1)t[i].swiperSlideOffset = e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop }, updateSlidesProgress: function (e = this && this.translate || 0) { const t = this, i = t.params, { slides: n, rtlTranslate: r } = t; if (0 === n.length) return; void 0 === n[0].swiperSlideOffset && t.updateSlidesOffset(); let a = -e; r && (a = e), n.removeClass(i.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let e = 0; e < n.length; e += 1) { const s = n[e], o = (a + (i.centeredSlides ? t.minTranslate() : 0) - s.swiperSlideOffset) / (s.swiperSlideSize + i.spaceBetween); if (i.watchSlidesVisibility || i.centeredSlides && i.autoHeight) { const r = -(a - s.swiperSlideOffset), o = r + t.slidesSizesGrid[e]; (r >= 0 && r < t.size - 1 || o > 1 && o <= t.size || r <= 0 && o >= t.size) && (t.visibleSlides.push(s), t.visibleSlidesIndexes.push(e), n.eq(e).addClass(i.slideVisibleClass)) } s.progress = r ? -o : o } t.visibleSlides = Ho(t.visibleSlides) }, updateProgress: function (e) { const t = this; if (void 0 === e) { const i = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * i || 0 } const i = t.params, n = t.maxTranslate() - t.minTranslate(); let { progress: r, isBeginning: a, isEnd: s } = t; const o = a, l = s; 0 === n ? (r = 0, a = !0, s = !0) : (r = (e - t.minTranslate()) / n, a = r <= 0, s = r >= 1), Wo.extend(t, { progress: r, isBeginning: a, isEnd: s }), (i.watchSlidesProgress || i.watchSlidesVisibility || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e), a && !o && t.emit("reachBeginning toEdge"), s && !l && t.emit("reachEnd toEdge"), (o && !a || l && !s) && t.emit("fromEdge"), t.emit("progress", r) }, updateSlidesClasses: function () { const e = this, { slides: t, params: i, $wrapperEl: n, activeIndex: r, realIndex: a } = e, s = e.virtual && i.virtual.enabled; let o; t.removeClass(`${i.slideActiveClass} ${i.slideNextClass} ${i.slidePrevClass} ${i.slideDuplicateActiveClass} ${i.slideDuplicateNextClass} ${i.slideDuplicatePrevClass}`), o = s ? e.$wrapperEl.find(`.${i.slideClass}[data-swiper-slide-index="${r}"]`) : t.eq(r), o.addClass(i.slideActiveClass), i.loop && (o.hasClass(i.slideDuplicateClass) ? n.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${a}"]`).addClass(i.slideDuplicateActiveClass) : n.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${a}"]`).addClass(i.slideDuplicateActiveClass)); let l = o.nextAll(`.${i.slideClass}`).eq(0).addClass(i.slideNextClass); i.loop && 0 === l.length && (l = t.eq(0), l.addClass(i.slideNextClass)); let c = o.prevAll(`.${i.slideClass}`).eq(0).addClass(i.slidePrevClass); i.loop && 0 === c.length && (c = t.eq(-1), c.addClass(i.slidePrevClass)), i.loop && (l.hasClass(i.slideDuplicateClass) ? n.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass) : n.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass), c.hasClass(i.slideDuplicateClass) ? n.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass) : n.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass)) }, updateActiveIndex: function (e) { const t = this, i = t.rtlTranslate ? t.translate : -t.translate, { slidesGrid: n, snapGrid: r, params: a, activeIndex: s, realIndex: o, snapIndex: l } = t; let c, h = e; if (void 0 === h) { for (let e = 0; e < n.length; e += 1)void 0 !== n[e + 1] ? i >= n[e] && i < n[e + 1] - (n[e + 1] - n[e]) / 2 ? h = e : i >= n[e] && i < n[e + 1] && (h = e + 1) : i >= n[e] && (h = e); a.normalizeSlideIndex && (h < 0 || void 0 === h) && (h = 0) } if (r.indexOf(i) >= 0) c = r.indexOf(i); else { const e = Math.min(a.slidesPerGroupSkip, h); c = e + Math.floor((h - e) / a.slidesPerGroup) } if (c >= r.length && (c = r.length - 1), h === s) return void (c !== l && (t.snapIndex = c, t.emit("snapIndexChange"))); const u = parseInt(t.slides.eq(h).attr("data-swiper-slide-index") || h, 10); Wo.extend(t, { snapIndex: c, realIndex: u, previousIndex: s, activeIndex: h }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), o !== u && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function (e) { const t = this, i = t.params, n = Ho(e.target).closest(`.${i.slideClass}`)[0]; let r = !1; if (n) for (let e = 0; e < t.slides.length; e += 1)t.slides[e] === n && (r = !0); if (!n || !r) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = n, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(Ho(n).attr("data-swiper-slide-index"), 10) : t.clickedIndex = Ho(n).index(), i.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }; var qo = { getTranslate: function (e = (this.isHorizontal() ? "x" : "y")) { const { params: t, rtlTranslate: i, translate: n, $wrapperEl: r } = this; if (t.virtualTranslate) return i ? -n : n; if (t.cssMode) return n; let a = Wo.getTranslate(r[0], e); return i && (a = -a), a || 0 }, setTranslate: function (e, t) { const i = this, { rtlTranslate: n, params: r, $wrapperEl: a, wrapperEl: s, progress: o } = i; let l, c = 0, h = 0; i.isHorizontal() ? c = n ? -e : e : h = e, r.roundLengths && (c = Math.floor(c), h = Math.floor(h)), r.cssMode ? s[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -c : -h : r.virtualTranslate || a.transform(`translate3d(${c}px, ${h}px, 0px)`), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? c : h; const u = i.maxTranslate() - i.minTranslate(); l = 0 === u ? 0 : (e - i.minTranslate()) / u, l !== o && i.updateProgress(e), i.emit("setTranslate", i.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e = 0, t = this.params.speed, i = !0, n = !0, r) { const a = this, { params: s, wrapperEl: o } = a; if (a.animating && s.preventInteractionOnTransition) return !1; const l = a.minTranslate(), c = a.maxTranslate(); let h; if (h = n && e > l ? l : n && e < c ? c : e, a.updateProgress(h), s.cssMode) { const e = a.isHorizontal(); return 0 === t ? o[e ? "scrollLeft" : "scrollTop"] = -h : o.scrollTo ? o.scrollTo({ [e ? "left" : "top"]: -h, behavior: "smooth" }) : o[e ? "scrollLeft" : "scrollTop"] = -h, !0 } return 0 === t ? (a.setTransition(0), a.setTranslate(h), i && (a.emit("beforeTransitionStart", t, r), a.emit("transitionEnd"))) : (a.setTransition(t), a.setTranslate(h), i && (a.emit("beforeTransitionStart", t, r), a.emit("transitionStart")), a.animating || (a.animating = !0, a.onTranslateToWrapperTransitionEnd || (a.onTranslateToWrapperTransitionEnd = function (e) { a && !a.destroyed && e.target === this && (a.$wrapperEl[0].removeEventListener("transitionend", a.onTranslateToWrapperTransitionEnd), a.$wrapperEl[0].removeEventListener("webkitTransitionEnd", a.onTranslateToWrapperTransitionEnd), a.onTranslateToWrapperTransitionEnd = null, delete a.onTranslateToWrapperTransitionEnd, i && a.emit("transitionEnd")) }), a.$wrapperEl[0].addEventListener("transitionend", a.onTranslateToWrapperTransitionEnd), a.$wrapperEl[0].addEventListener("webkitTransitionEnd", a.onTranslateToWrapperTransitionEnd))), !0 } }; var Jo = { setTransition: function (e, t) { const i = this; i.params.cssMode || i.$wrapperEl.transition(e), i.emit("setTransition", e, t) }, transitionStart: function (e = !0, t) { const i = this, { activeIndex: n, params: r, previousIndex: a } = i; if (r.cssMode) return; r.autoHeight && i.updateAutoHeight(); let s = t; if (s || (s = n > a ? "next" : n < a ? "prev" : "reset"), i.emit("transitionStart"), e && n !== a) { if ("reset" === s) return void i.emit("slideResetTransitionStart"); i.emit("slideChangeTransitionStart"), "next" === s ? i.emit("slideNextTransitionStart") : i.emit("slidePrevTransitionStart") } }, transitionEnd: function (e = !0, t) { const i = this, { activeIndex: n, previousIndex: r, params: a } = i; if (i.animating = !1, a.cssMode) return; i.setTransition(0); let s = t; if (s || (s = n > r ? "next" : n < r ? "prev" : "reset"), i.emit("transitionEnd"), e && n !== r) { if ("reset" === s) return void i.emit("slideResetTransitionEnd"); i.emit("slideChangeTransitionEnd"), "next" === s ? i.emit("slideNextTransitionEnd") : i.emit("slidePrevTransitionEnd") } } }; var Zo = { slideTo: function (e = 0, t = this.params.speed, i = !0, n) { const r = this; let a = e; a < 0 && (a = 0); const { params: s, snapGrid: o, slidesGrid: l, previousIndex: c, activeIndex: h, rtlTranslate: u, wrapperEl: d } = r; if (r.animating && s.preventInteractionOnTransition) return !1; const p = Math.min(r.params.slidesPerGroupSkip, a); let f = p + Math.floor((a - p) / r.params.slidesPerGroup); f >= o.length && (f = o.length - 1), (h || s.initialSlide || 0) === (c || 0) && i && r.emit("beforeSlideChangeStart"); const m = -o[f]; if (r.updateProgress(m), s.normalizeSlideIndex) for (let e = 0; e < l.length; e += 1)-Math.floor(100 * m) >= Math.floor(100 * l[e]) && (a = e); if (r.initialized && a !== h) { if (!r.allowSlideNext && m < r.translate && m < r.minTranslate()) return !1; if (!r.allowSlidePrev && m > r.translate && m > r.maxTranslate() && (h || 0) !== a) return !1 } let g; if (g = a > h ? "next" : a < h ? "prev" : "reset", u && -m === r.translate || !u && m === r.translate) return r.updateActiveIndex(a), s.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== s.effect && r.setTranslate(m), "reset" !== g && (r.transitionStart(i, g), r.transitionEnd(i, g)), !1; if (s.cssMode) { const e = r.isHorizontal(); let i = -m; return u && (i = d.scrollWidth - d.offsetWidth - i), 0 === t ? d[e ? "scrollLeft" : "scrollTop"] = i : d.scrollTo ? d.scrollTo({ [e ? "left" : "top"]: i, behavior: "smooth" }) : d[e ? "scrollLeft" : "scrollTop"] = i, !0 } return 0 === t ? (r.setTransition(0), r.setTranslate(m), r.updateActiveIndex(a), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, n), r.transitionStart(i, g), r.transitionEnd(i, g)) : (r.setTransition(t), r.setTranslate(m), r.updateActiveIndex(a), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, n), r.transitionStart(i, g), r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(i, g)) }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd))), !0 }, slideToLoop: function (e = 0, t = this.params.speed, i = !0, n) { const r = this; let a = e; return r.params.loop && (a += r.loopedSlides), r.slideTo(a, t, i, n) }, slideNext: function (e = this.params.speed, t = !0, i) { const n = this, { params: r, animating: a } = n, s = n.activeIndex < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup; if (r.loop) { if (a) return !1; n.loopFix(), n._clientLeft = n.$wrapperEl[0].clientLeft } return n.slideTo(n.activeIndex + s, e, t, i) }, slidePrev: function (e = this.params.speed, t = !0, i) { const n = this, { params: r, animating: a, snapGrid: s, slidesGrid: o, rtlTranslate: l } = n; if (r.loop) { if (a) return !1; n.loopFix(), n._clientLeft = n.$wrapperEl[0].clientLeft } function c(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const h = c(l ? n.translate : -n.translate), u = s.map(e => c(e)); o.map(e => c(e)), s[u.indexOf(h)]; let d, p = s[u.indexOf(h) - 1]; return void 0 === p && r.cssMode && s.forEach(e => { !p && h >= e && (p = e) }), void 0 !== p && (d = o.indexOf(p), d < 0 && (d = n.activeIndex - 1)), n.slideTo(d, e, t, i) }, slideReset: function (e = this.params.speed, t = !0, i) { return this.slideTo(this.activeIndex, e, t, i) }, slideToClosest: function (e = this.params.speed, t = !0, i, n = .5) { const r = this; let a = r.activeIndex; const s = Math.min(r.params.slidesPerGroupSkip, a), o = s + Math.floor((a - s) / r.params.slidesPerGroup), l = r.rtlTranslate ? r.translate : -r.translate; if (l >= r.snapGrid[o]) { const e = r.snapGrid[o]; l - e > (r.snapGrid[o + 1] - e) * n && (a += r.params.slidesPerGroup) } else { const e = r.snapGrid[o - 1]; l - e <= (r.snapGrid[o] - e) * n && (a -= r.params.slidesPerGroup) } return a = Math.max(a, 0), a = Math.min(a, r.slidesGrid.length - 1), r.slideTo(a, e, t, i) }, slideToClickedSlide: function () { const e = this, { params: t, $wrapperEl: i } = e, n = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let r, a = e.clickedIndex; if (t.loop) { if (e.animating) return; r = parseInt(Ho(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? a < e.loopedSlides - n / 2 || a > e.slides.length - e.loopedSlides + n / 2 ? (e.loopFix(), a = i.children(`.${t.slideClass}[data-swiper-slide-index="${r}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), Wo.nextTick(() => { e.slideTo(a) })) : e.slideTo(a) : a > e.slides.length - n ? (e.loopFix(), a = i.children(`.${t.slideClass}[data-swiper-slide-index="${r}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), Wo.nextTick(() => { e.slideTo(a) })) : e.slideTo(a) } else e.slideTo(a) } }; var Ko = { loopCreate: function () { const e = this, { params: t, $wrapperEl: i } = e; i.children(`.${t.slideClass}.${t.slideDuplicateClass}`).remove(); let n = i.children(`.${t.slideClass}`); if (t.loopFillGroupWithBlank) { const e = t.slidesPerGroup - n.length % t.slidesPerGroup; if (e !== t.slidesPerGroup) { for (let n = 0; n < e; n += 1) { const e = Ho(Fo.createElement("div")).addClass(`${t.slideClass} ${t.slideBlankClass}`); i.append(e) } n = i.children(`.${t.slideClass}`) } } "auto" !== t.slidesPerView || t.loopedSlides || (t.loopedSlides = n.length), e.loopedSlides = Math.ceil(parseFloat(t.loopedSlides || t.slidesPerView, 10)), e.loopedSlides += t.loopAdditionalSlides, e.loopedSlides > n.length && (e.loopedSlides = n.length); const r = [], a = []; n.each((t, i) => { const s = Ho(i); t < e.loopedSlides && a.push(i), t < n.length && t >= n.length - e.loopedSlides && r.push(i), s.attr("data-swiper-slide-index", t) }); for (let e = 0; e < a.length; e += 1)i.append(Ho(a[e].cloneNode(!0)).addClass(t.slideDuplicateClass)); for (let e = r.length - 1; e >= 0; e -= 1)i.prepend(Ho(r[e].cloneNode(!0)).addClass(t.slideDuplicateClass)) }, loopFix: function () { const e = this; e.emit("beforeLoopFix"); const { activeIndex: t, slides: i, loopedSlides: n, allowSlidePrev: r, allowSlideNext: a, snapGrid: s, rtlTranslate: o } = e; let l; e.allowSlidePrev = !0, e.allowSlideNext = !0; const c = -s[t] - e.getTranslate(); if (t < n) { l = i.length - 3 * n + t, l += n, e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((o ? -e.translate : e.translate) - c) } else if (t >= i.length - n) { l = -i.length + t + n, l += n, e.slideTo(l, 0, !1, !0) && 0 !== c && e.setTranslate((o ? -e.translate : e.translate) - c) } e.allowSlidePrev = r, e.allowSlideNext = a, e.emit("loopFix") }, loopDestroy: function () { const { $wrapperEl: e, params: t, slides: i } = this; e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), i.removeAttr("data-swiper-slide-index") } }; var Qo = { setGrabCursor: function (e) { if ($o.touch || !this.params.simulateTouch || this.params.watchOverflow && this.isLocked || this.params.cssMode) return; const t = this.el; t.style.cursor = "move", t.style.cursor = e ? "-webkit-grabbing" : "-webkit-grab", t.style.cursor = e ? "-moz-grabbin" : "-moz-grab", t.style.cursor = e ? "grabbing" : "grab" }, unsetGrabCursor: function () { $o.touch || this.params.watchOverflow && this.isLocked || this.params.cssMode || (this.el.style.cursor = "") } }; var el = { appendSlide: function (e) { const t = this, { $wrapperEl: i, params: n } = t; if (n.loop && t.loopDestroy(), "object" == typeof e && "length" in e) for (let t = 0; t < e.length; t += 1)e[t] && i.append(e[t]); else i.append(e); n.loop && t.loopCreate(), n.observer && $o.observer || t.update() }, prependSlide: function (e) { const t = this, { params: i, $wrapperEl: n, activeIndex: r } = t; i.loop && t.loopDestroy(); let a = r + 1; if ("object" == typeof e && "length" in e) { for (let t = 0; t < e.length; t += 1)e[t] && n.prepend(e[t]); a = r + e.length } else n.prepend(e); i.loop && t.loopCreate(), i.observer && $o.observer || t.update(), t.slideTo(a, 0, !1) }, addSlide: function (e, t) { const i = this, { $wrapperEl: n, params: r, activeIndex: a } = i; let s = a; r.loop && (s -= i.loopedSlides, i.loopDestroy(), i.slides = n.children(`.${r.slideClass}`)); const o = i.slides.length; if (e <= 0) return void i.prependSlide(t); if (e >= o) return void i.appendSlide(t); let l = s > e ? s + 1 : s; const c = []; for (let t = o - 1; t >= e; t -= 1) { const e = i.slides.eq(t); e.remove(), c.unshift(e) } if ("object" == typeof t && "length" in t) { for (let e = 0; e < t.length; e += 1)t[e] && n.append(t[e]); l = s > e ? s + t.length : s } else n.append(t); for (let e = 0; e < c.length; e += 1)n.append(c[e]); r.loop && i.loopCreate(), r.observer && $o.observer || i.update(), r.loop ? i.slideTo(l + i.loopedSlides, 0, !1) : i.slideTo(l, 0, !1) }, removeSlide: function (e) { const t = this, { params: i, $wrapperEl: n, activeIndex: r } = t; let a = r; i.loop && (a -= t.loopedSlides, t.loopDestroy(), t.slides = n.children(`.${i.slideClass}`)); let s, o = a; if ("object" == typeof e && "length" in e) { for (let i = 0; i < e.length; i += 1)s = e[i], t.slides[s] && t.slides.eq(s).remove(), s < o && (o -= 1); o = Math.max(o, 0) } else s = e, t.slides[s] && t.slides.eq(s).remove(), s < o && (o -= 1), o = Math.max(o, 0); i.loop && t.loopCreate(), i.observer && $o.observer || t.update(), i.loop ? t.slideTo(o + t.loopedSlides, 0, !1) : t.slideTo(o, 0, !1) }, removeAllSlides: function () { const e = this, t = []; for (let i = 0; i < e.slides.length; i += 1)t.push(i); e.removeSlide(t) } }; const tl = function () { const e = Go.navigator.platform, t = Go.navigator.userAgent, i = { ios: !1, android: !1, androidChrome: !1, desktop: !1, iphone: !1, ipod: !1, ipad: !1, edge: !1, ie: !1, firefox: !1, macos: !1, windows: !1, cordova: !(!Go.cordova && !Go.phonegap), phonegap: !(!Go.cordova && !Go.phonegap), electron: !1 }, n = Go.screen.width, r = Go.screen.height, a = t.match(/(Android);?[\s\/]+([\d.]+)?/); let s = t.match(/(iPad).*OS\s([\d_]+)/); const o = t.match(/(iPod)(.*OS\s([\d_]+))?/), l = !s && t.match(/(iPhone\sOS|iOS)\s([\d_]+)/), c = t.indexOf("MSIE ") >= 0 || t.indexOf("Trident/") >= 0, h = t.indexOf("Edge/") >= 0, u = t.indexOf("Gecko/") >= 0 && t.indexOf("Firefox/") >= 0, d = "Win32" === e, p = t.toLowerCase().indexOf("electron") >= 0; let f = "MacIntel" === e; return !s && f && $o.touch && (1024 === n && 1366 === r || 834 === n && 1194 === r || 834 === n && 1112 === r || 768 === n && 1024 === r) && (s = t.match(/(Version)\/([\d.]+)/), f = !1), i.ie = c, i.edge = h, i.firefox = u, a && !d && (i.os = "android", i.osVersion = a[2], i.android = !0, i.androidChrome = t.toLowerCase().indexOf("chrome") >= 0), (s || l || o) && (i.os = "ios", i.ios = !0), l && !o && (i.osVersion = l[2].replace(/_/g, "."), i.iphone = !0), s && (i.osVersion = s[2].replace(/_/g, "."), i.ipad = !0), o && (i.osVersion = o[3] ? o[3].replace(/_/g, ".") : null, i.ipod = !0), i.ios && i.osVersion && t.indexOf("Version/") >= 0 && "10" === i.osVersion.split(".")[0] && (i.osVersion = t.toLowerCase().split("version/")[1].split(" ")[0]), i.webView = !(!(l || s || o) || !t.match(/.*AppleWebKit(?!.*Safari)/i) && !Go.navigator.standalone) || Go.matchMedia && Go.matchMedia("(display-mode: standalone)").matches, i.webview = i.webView, i.standalone = i.webView, i.desktop = !(i.ios || i.android) || p, i.desktop && (i.electron = p, i.macos = f, i.windows = d, i.macos && (i.os = "macos"), i.windows && (i.os = "windows")), i.pixelRatio = Go.devicePixelRatio || 1, i }(); function il(e) { const t = this, i = t.touchEventsData, { params: n, touches: r } = t; if (t.animating && n.preventInteractionOnTransition) return; let a = e; a.originalEvent && (a = a.originalEvent); const s = Ho(a.target); if ("wrapper" === n.touchEventsTarget && !s.closest(t.wrapperEl).length) return; if (i.isTouchEvent = "touchstart" === a.type, !i.isTouchEvent && "which" in a && 3 === a.which) return; if (!i.isTouchEvent && "button" in a && a.button > 0) return; if (i.isTouched && i.isMoved) return; if (n.noSwiping && s.closest(n.noSwipingSelector ? n.noSwipingSelector : `.${n.noSwipingClass}`)[0]) return void (t.allowClick = !0); if (n.swipeHandler && !s.closest(n.swipeHandler)[0]) return; r.currentX = "touchstart" === a.type ? a.targetTouches[0].pageX : a.pageX, r.currentY = "touchstart" === a.type ? a.targetTouches[0].pageY : a.pageY; const o = r.currentX, l = r.currentY, c = n.edgeSwipeDetection || n.iOSEdgeSwipeDetection, h = n.edgeSwipeThreshold || n.iOSEdgeSwipeThreshold; if (!c || !(o <= h || o >= Go.screen.width - h)) { if (Wo.extend(i, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), r.startX = o, r.startY = l, i.touchStartTime = Wo.now(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, n.threshold > 0 && (i.allowThresholdMove = !1), "touchstart" !== a.type) { let e = !0; s.is(i.formElements) && (e = !1), Fo.activeElement && Ho(Fo.activeElement).is(i.formElements) && Fo.activeElement !== s[0] && Fo.activeElement.blur(); const r = e && t.allowTouchMove && n.touchStartPreventDefault; (n.touchStartForcePreventDefault || r) && a.preventDefault() } t.emit("touchStart", a) } } function nl(e) { const t = this, i = t.touchEventsData, { params: n, touches: r, rtlTranslate: a } = t; let s = e; if (s.originalEvent && (s = s.originalEvent), !i.isTouched) return void (i.startMoving && i.isScrolling && t.emit("touchMoveOpposite", s)); if (i.isTouchEvent && "mousemove" === s.type) return; const o = "touchmove" === s.type && s.targetTouches && (s.targetTouches[0] || s.changedTouches[0]), l = "touchmove" === s.type ? o.pageX : s.pageX, c = "touchmove" === s.type ? o.pageY : s.pageY; if (s.preventedByNestedSwiper) return r.startX = l, void (r.startY = c); if (!t.allowTouchMove) return t.allowClick = !1, void (i.isTouched && (Wo.extend(r, { startX: l, startY: c, currentX: l, currentY: c }), i.touchStartTime = Wo.now())); if (i.isTouchEvent && n.touchReleaseOnEdges && !n.loop) if (t.isVertical()) { if (c < r.startY && t.translate <= t.maxTranslate() || c > r.startY && t.translate >= t.minTranslate()) return i.isTouched = !1, void (i.isMoved = !1) } else if (l < r.startX && t.translate <= t.maxTranslate() || l > r.startX && t.translate >= t.minTranslate()) return; if (i.isTouchEvent && Fo.activeElement && s.target === Fo.activeElement && Ho(s.target).is(i.formElements)) return i.isMoved = !0, void (t.allowClick = !1); if (i.allowTouchCallbacks && t.emit("touchMove", s), s.targetTouches && s.targetTouches.length > 1) return; r.currentX = l, r.currentY = c; const h = r.currentX - r.startX, u = r.currentY - r.startY; if (t.params.threshold && Math.sqrt(h ** 2 + u ** 2) < t.params.threshold) return; if (void 0 === i.isScrolling) { let e; t.isHorizontal() && r.currentY === r.startY || t.isVertical() && r.currentX === r.startX ? i.isScrolling = !1 : h * h + u * u >= 25 && (e = 180 * Math.atan2(Math.abs(u), Math.abs(h)) / Math.PI, i.isScrolling = t.isHorizontal() ? e > n.touchAngle : 90 - e > n.touchAngle) } if (i.isScrolling && t.emit("touchMoveOpposite", s), void 0 === i.startMoving && (r.currentX === r.startX && r.currentY === r.startY || (i.startMoving = !0)), i.isScrolling) return void (i.isTouched = !1); if (!i.startMoving) return; t.allowClick = !1, n.cssMode || s.preventDefault(), n.touchMoveStopPropagation && !n.nested && s.stopPropagation(), i.isMoved || (n.loop && t.loopFix(), i.startTranslate = t.getTranslate(), t.setTransition(0), t.animating && t.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !n.grabCursor || !0 !== t.allowSlideNext && !0 !== t.allowSlidePrev || t.setGrabCursor(!0), t.emit("sliderFirstMove", s)), t.emit("sliderMove", s), i.isMoved = !0; let d = t.isHorizontal() ? h : u; r.diff = d, d *= n.touchRatio, a && (d = -d), t.swipeDirection = d > 0 ? "prev" : "next", i.currentTranslate = d + i.startTranslate; let p = !0, f = n.resistanceRatio; if (n.touchReleaseOnEdges && (f = 0), d > 0 && i.currentTranslate > t.minTranslate() ? (p = !1, n.resistance && (i.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + i.startTranslate + d) ** f)) : d < 0 && i.currentTranslate < t.maxTranslate() && (p = !1, n.resistance && (i.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - i.startTranslate - d) ** f)), p && (s.preventedByNestedSwiper = !0), !t.allowSlideNext && "next" === t.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && "prev" === t.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), n.threshold > 0) { if (!(Math.abs(d) > n.threshold || i.allowThresholdMove)) return void (i.currentTranslate = i.startTranslate); if (!i.allowThresholdMove) return i.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, i.currentTranslate = i.startTranslate, void (r.diff = t.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY) } n.followFinger && !n.cssMode && ((n.freeMode || n.watchSlidesProgress || n.watchSlidesVisibility) && (t.updateActiveIndex(), t.updateSlidesClasses()), n.freeMode && (0 === i.velocities.length && i.velocities.push({ position: r[t.isHorizontal() ? "startX" : "startY"], time: i.touchStartTime }), i.velocities.push({ position: r[t.isHorizontal() ? "currentX" : "currentY"], time: Wo.now() })), t.updateProgress(i.currentTranslate), t.setTranslate(i.currentTranslate)) } function rl(e) { const t = this, i = t.touchEventsData, { params: n, touches: r, rtlTranslate: a, $wrapperEl: s, slidesGrid: o, snapGrid: l } = t; let c = e; if (c.originalEvent && (c = c.originalEvent), i.allowTouchCallbacks && t.emit("touchEnd", c), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && n.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void (i.startMoving = !1); n.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const h = Wo.now(), u = h - i.touchStartTime; if (t.allowClick && (t.updateClickedSlide(c), t.emit("tap click", c), u < 300 && h - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", c)), i.lastClickTime = Wo.now(), Wo.nextTick(() => { t.destroyed || (t.allowClick = !0) }), !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === r.diff || i.currentTranslate === i.startTranslate) return i.isTouched = !1, i.isMoved = !1, void (i.startMoving = !1); let d; if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, d = n.followFinger ? a ? t.translate : -t.translate : -i.currentTranslate, n.cssMode) return; if (n.freeMode) { if (d < -t.minTranslate()) return void t.slideTo(t.activeIndex); if (d > -t.maxTranslate()) return void (t.slides.length < l.length ? t.slideTo(l.length - 1) : t.slideTo(t.slides.length - 1)); if (n.freeModeMomentum) { if (i.velocities.length > 1) { const e = i.velocities.pop(), r = i.velocities.pop(), a = e.position - r.position, s = e.time - r.time; t.velocity = a / s, t.velocity /= 2, Math.abs(t.velocity) < n.freeModeMinimumVelocity && (t.velocity = 0), (s > 150 || Wo.now() - e.time > 300) && (t.velocity = 0) } else t.velocity = 0; t.velocity *= n.freeModeMomentumVelocityRatio, i.velocities.length = 0; let e = 1e3 * n.freeModeMomentumRatio; const r = t.velocity * e; let o = t.translate + r; a && (o = -o); let c, h = !1; const u = 20 * Math.abs(t.velocity) * n.freeModeMomentumBounceRatio; let d; if (o < t.maxTranslate()) n.freeModeMomentumBounce ? (o + t.maxTranslate() < -u && (o = t.maxTranslate() - u), c = t.maxTranslate(), h = !0, i.allowMomentumBounce = !0) : o = t.maxTranslate(), n.loop && n.centeredSlides && (d = !0); else if (o > t.minTranslate()) n.freeModeMomentumBounce ? (o - t.minTranslate() > u && (o = t.minTranslate() + u), c = t.minTranslate(), h = !0, i.allowMomentumBounce = !0) : o = t.minTranslate(), n.loop && n.centeredSlides && (d = !0); else if (n.freeModeSticky) { let e; for (let t = 0; t < l.length; t += 1)if (l[t] > -o) { e = t; break } o = Math.abs(l[e] - o) < Math.abs(l[e - 1] - o) || "next" === t.swipeDirection ? l[e] : l[e - 1], o = -o } if (d && t.once("transitionEnd", () => { t.loopFix() }), 0 !== t.velocity) { if (e = a ? Math.abs((-o - t.translate) / t.velocity) : Math.abs((o - t.translate) / t.velocity), n.freeModeSticky) { const i = Math.abs((a ? -o : o) - t.translate), r = t.slidesSizesGrid[t.activeIndex]; e = i < r ? n.speed : i < 2 * r ? 1.5 * n.speed : 2.5 * n.speed } } else if (n.freeModeSticky) return void t.slideToClosest(); n.freeModeMomentumBounce && h ? (t.updateProgress(c), t.setTransition(e), t.setTranslate(o), t.transitionStart(!0, t.swipeDirection), t.animating = !0, s.transitionEnd(() => { t && !t.destroyed && i.allowMomentumBounce && (t.emit("momentumBounce"), t.setTransition(n.speed), setTimeout(() => { t.setTranslate(c), s.transitionEnd(() => { t && !t.destroyed && t.transitionEnd() }) }, 0)) })) : t.velocity ? (t.updateProgress(o), t.setTransition(e), t.setTranslate(o), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, s.transitionEnd(() => { t && !t.destroyed && t.transitionEnd() }))) : t.updateProgress(o), t.updateActiveIndex(), t.updateSlidesClasses() } else if (n.freeModeSticky) return void t.slideToClosest(); return void ((!n.freeModeMomentum || u >= n.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())) } let p = 0, f = t.slidesSizesGrid[0]; for (let e = 0; e < o.length; e += e < n.slidesPerGroupSkip ? 1 : n.slidesPerGroup) { const t = e < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup; void 0 !== o[e + t] ? d >= o[e] && d < o[e + t] && (p = e, f = o[e + t] - o[e]) : d >= o[e] && (p = e, f = o[o.length - 1] - o[o.length - 2]) } const m = (d - o[p]) / f, g = p < n.slidesPerGroupSkip - 1 ? 1 : n.slidesPerGroup; if (u > n.longSwipesMs) { if (!n.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (m >= n.longSwipesRatio ? t.slideTo(p + g) : t.slideTo(p)), "prev" === t.swipeDirection && (m > 1 - n.longSwipesRatio ? t.slideTo(p + g) : t.slideTo(p)) } else { if (!n.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (c.target === t.navigation.nextEl || c.target === t.navigation.prevEl) ? c.target === t.navigation.nextEl ? t.slideTo(p + g) : t.slideTo(p) : ("next" === t.swipeDirection && t.slideTo(p + g), "prev" === t.swipeDirection && t.slideTo(p)) } } function al() { const e = this, { params: t, el: i } = e; if (i && 0 === i.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: n, allowSlidePrev: r, snapGrid: a } = e; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = r, e.allowSlideNext = n, e.params.watchOverflow && a !== e.snapGrid && e.checkOverflow() } function sl(e) { const t = this; t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation())) } function ol() { const e = this, { wrapperEl: t, rtlTranslate: i } = e; let n; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = i ? t.scrollWidth - t.offsetWidth - t.scrollLeft : -t.scrollLeft : e.translate = -t.scrollTop, -0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate(); n = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, n !== e.progress && e.updateProgress(i ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } let ll = !1; function cl() { } var hl = { init: !0, direction: "horizontal", touchEventsTarget: "container", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, preventInteractionOnTransition: !1, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, freeMode: !1, freeModeMomentum: !0, freeModeMomentumRatio: 1, freeModeMomentumBounce: !0, freeModeMomentumBounceRatio: 1, freeModeMomentumVelocityRatio: 1, freeModeSticky: !1, freeModeMinimumVelocity: .02, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, spaceBetween: 0, slidesPerView: 1, slidesPerColumn: 1, slidesPerColumnFill: "column", slidesPerGroup: 1, slidesPerGroupSkip: 0, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !1, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, watchSlidesVisibility: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopFillGroupWithBlank: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, containerModifierClass: "swiper-container-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0 }; const ul = { update: Yo, translate: qo, transition: Jo, slide: Zo, loop: Ko, grabCursor: Qo, manipulation: el, events: { attachEvents: function () { const e = this, { params: t, touchEvents: i, el: n, wrapperEl: r } = e; e.onTouchStart = il.bind(e), e.onTouchMove = nl.bind(e), e.onTouchEnd = rl.bind(e), t.cssMode && (e.onScroll = ol.bind(e)), e.onClick = sl.bind(e); const a = !!t.nested; if (!$o.touch && $o.pointerEvents) n.addEventListener(i.start, e.onTouchStart, !1), Fo.addEventListener(i.move, e.onTouchMove, a), Fo.addEventListener(i.end, e.onTouchEnd, !1); else { if ($o.touch) { const r = !("touchstart" !== i.start || !$o.passiveListener || !t.passiveListeners) && { passive: !0, capture: !1 }; n.addEventListener(i.start, e.onTouchStart, r), n.addEventListener(i.move, e.onTouchMove, $o.passiveListener ? { passive: !1, capture: a } : a), n.addEventListener(i.end, e.onTouchEnd, r), i.cancel && n.addEventListener(i.cancel, e.onTouchEnd, r), ll || (Fo.addEventListener("touchstart", cl), ll = !0) } (t.simulateTouch && !tl.ios && !tl.android || t.simulateTouch && !$o.touch && tl.ios) && (n.addEventListener("mousedown", e.onTouchStart, !1), Fo.addEventListener("mousemove", e.onTouchMove, a), Fo.addEventListener("mouseup", e.onTouchEnd, !1)) } (t.preventClicks || t.preventClicksPropagation) && n.addEventListener("click", e.onClick, !0), t.cssMode && r.addEventListener("scroll", e.onScroll), t.updateOnWindowResize ? e.on(tl.ios || tl.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", al, !0) : e.on("observerUpdate", al, !0) }, detachEvents: function () { const e = this, { params: t, touchEvents: i, el: n, wrapperEl: r } = e, a = !!t.nested; if (!$o.touch && $o.pointerEvents) n.removeEventListener(i.start, e.onTouchStart, !1), Fo.removeEventListener(i.move, e.onTouchMove, a), Fo.removeEventListener(i.end, e.onTouchEnd, !1); else { if ($o.touch) { const r = !("onTouchStart" !== i.start || !$o.passiveListener || !t.passiveListeners) && { passive: !0, capture: !1 }; n.removeEventListener(i.start, e.onTouchStart, r), n.removeEventListener(i.move, e.onTouchMove, a), n.removeEventListener(i.end, e.onTouchEnd, r), i.cancel && n.removeEventListener(i.cancel, e.onTouchEnd, r) } (t.simulateTouch && !tl.ios && !tl.android || t.simulateTouch && !$o.touch && tl.ios) && (n.removeEventListener("mousedown", e.onTouchStart, !1), Fo.removeEventListener("mousemove", e.onTouchMove, a), Fo.removeEventListener("mouseup", e.onTouchEnd, !1)) } (t.preventClicks || t.preventClicksPropagation) && n.removeEventListener("click", e.onClick, !0), t.cssMode && r.removeEventListener("scroll", e.onScroll), e.off(tl.ios || tl.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", al) } }, breakpoints: { setBreakpoint: function () { const e = this, { activeIndex: t, initialized: i, loopedSlides: n = 0, params: r, $el: a } = e, s = r.breakpoints; if (!s || s && 0 === Object.keys(s).length) return; const o = e.getBreakpoint(s); if (o && e.currentBreakpoint !== o) { const l = o in s ? s[o] : void 0; l && ["slidesPerView", "spaceBetween", "slidesPerGroup", "slidesPerGroupSkip", "slidesPerColumn"].forEach(e => { const t = l[e]; void 0 !== t && (l[e] = "slidesPerView" !== e || "AUTO" !== t && "auto" !== t ? "slidesPerView" === e ? parseFloat(t) : parseInt(t, 10) : "auto") }); const c = l || e.originalParams, h = r.slidesPerColumn > 1, u = c.slidesPerColumn > 1; h && !u ? a.removeClass(`${r.containerModifierClass}multirow ${r.containerModifierClass}multirow-column`) : !h && u && (a.addClass(`${r.containerModifierClass}multirow`), "column" === c.slidesPerColumnFill && a.addClass(`${r.containerModifierClass}multirow-column`)); const d = c.direction && c.direction !== r.direction, p = r.loop && (c.slidesPerView !== r.slidesPerView || d); d && i && e.changeDirection(), Wo.extend(e.params, c), Wo.extend(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), e.currentBreakpoint = o, p && i && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - n + e.loopedSlides, 0, !1)), e.emit("breakpoint", c) } }, getBreakpoint: function (e) { if (!e) return; let t = !1; const i = Object.keys(e).map(e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: Go.innerHeight * t, point: e } } return { value: e, point: e } }); i.sort((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10)); for (let e = 0; e < i.length; e += 1) { const { point: n, value: r } = i[e]; r <= Go.innerWidth && (t = n) } return t || "max" } }, checkOverflow: { checkOverflow: function () { const e = this, t = e.params, i = e.isLocked, n = e.slides.length > 0 && t.slidesOffsetBefore + t.spaceBetween * (e.slides.length - 1) + e.slides[0].offsetWidth * e.slides.length; t.slidesOffsetBefore && t.slidesOffsetAfter && n ? e.isLocked = n <= e.size : e.isLocked = 1 === e.snapGrid.length, e.allowSlideNext = !e.isLocked, e.allowSlidePrev = !e.isLocked, i !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock"), i && i !== e.isLocked && (e.isEnd = !1, e.navigation.update()) } }, classes: { addClasses: function () { const { classNames: e, params: t, rtl: i, $el: n } = this, r = []; r.push("initialized"), r.push(t.direction), t.freeMode && r.push("free-mode"), t.autoHeight && r.push("autoheight"), i && r.push("rtl"), t.slidesPerColumn > 1 && (r.push("multirow"), "column" === t.slidesPerColumnFill && r.push("multirow-column")), tl.android && r.push("android"), tl.ios && r.push("ios"), t.cssMode && r.push("css-mode"), r.forEach(i => { e.push(t.containerModifierClass + i) }), n.addClass(e.join(" ")) }, removeClasses: function () { const { $el: e, classNames: t } = this; e.removeClass(t.join(" ")) } }, images: { loadImage: function (e, t, i, n, r, a) { let s; function o() { a && a() } e.complete && r ? o() : t ? (s = new Go.Image, s.onload = o, s.onerror = o, n && (s.sizes = n), i && (s.srcset = i), t && (s.src = t)) : o() }, preloadImages: function () { const e = this; function t() { null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady"))) } e.imagesToLoad = e.$el.find("img"); for (let i = 0; i < e.imagesToLoad.length; i += 1) { const n = e.imagesToLoad[i]; e.loadImage(n, n.currentSrc || n.getAttribute("src"), n.srcset || n.getAttribute("srcset"), n.sizes || n.getAttribute("sizes"), !0, t) } } } }, dl = {}; class pl extends Xo { constructor(...e) { let t, i; 1 === e.length && e[0].constructor && e[0].constructor === Object ? i = e[0] : [t, i] = e, i || (i = {}), i = Wo.extend({}, i), t && !i.el && (i.el = t), super(i), Object.keys(ul).forEach(e => { Object.keys(ul[e]).forEach(t => { pl.prototype[t] || (pl.prototype[t] = ul[e][t]) }) }); const n = this; void 0 === n.modules && (n.modules = {}), Object.keys(n.modules).forEach(e => { const t = n.modules[e]; if (t.params) { const e = Object.keys(t.params)[0], n = t.params[e]; if ("object" != typeof n || null === n) return; if (!(e in i) || !("enabled" in n)) return; !0 === i[e] && (i[e] = { enabled: !0 }), "object" != typeof i[e] || "enabled" in i[e] || (i[e].enabled = !0), i[e] || (i[e] = { enabled: !1 }) } }); const r = Wo.extend({}, hl); n.useModulesParams(r), n.params = Wo.extend({}, r, dl, i), n.originalParams = Wo.extend({}, n.params), n.passedParams = Wo.extend({}, i), n.$ = Ho; const a = Ho(n.params.el); if (t = a[0], !t) return; if (a.length > 1) { const e = []; return a.each((t, n) => { const r = Wo.extend({}, i, { el: n }); e.push(new pl(r)) }), e } let s; return t.swiper = n, a.data("swiper", n), t && t.shadowRoot && t.shadowRoot.querySelector ? (s = Ho(t.shadowRoot.querySelector(`.${n.params.wrapperClass}`)), s.children = e => a.children(e)) : s = a.children(`.${n.params.wrapperClass}`), Wo.extend(n, { $el: a, el: t, $wrapperEl: s, wrapperEl: s[0], classNames: [], slides: Ho(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === n.params.direction, isVertical: () => "vertical" === n.params.direction, rtl: "rtl" === t.dir.toLowerCase() || "rtl" === a.css("direction"), rtlTranslate: "horizontal" === n.params.direction && ("rtl" === t.dir.toLowerCase() || "rtl" === a.css("direction")), wrongRTL: "-webkit-box" === s.css("display"), activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: n.params.allowSlideNext, allowSlidePrev: n.params.allowSlidePrev, touchEvents: function () { const e = ["touchstart", "touchmove", "touchend", "touchcancel"]; let t = ["mousedown", "mousemove", "mouseup"]; return $o.pointerEvents && (t = ["pointerdown", "pointermove", "pointerup"]), n.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, n.touchEventsDesktop = { start: t[0], move: t[1], end: t[2] }, $o.touch || !n.params.simulateTouch ? n.touchEventsTouch : n.touchEventsDesktop }(), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, formElements: "input, select, option, textarea, button, video, label", lastClickTime: Wo.now(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: n.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), n.useModules(), n.params.init && n.init(), n } slidesPerViewDynamic() { const { params: e, slides: t, slidesGrid: i, size: n, activeIndex: r } = this; let a = 1; if (e.centeredSlides) { let e, i = t[r].swiperSlideSize; for (let s = r + 1; s < t.length; s += 1)t[s] && !e && (i += t[s].swiperSlideSize, a += 1, i > n && (e = !0)); for (let s = r - 1; s >= 0; s -= 1)t[s] && !e && (i += t[s].swiperSlideSize, a += 1, i > n && (e = !0)) } else for (let e = r + 1; e < t.length; e += 1)i[e] - i[r] < n && (a += 1); return a } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: i } = e; function n() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses() } let r; i.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode ? (n(), e.params.autoHeight && e.updateAutoHeight()) : (r = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), r || n()), i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t = !0) { const i = this, n = i.params.direction; return e || (e = "horizontal" === n ? "vertical" : "horizontal"), e === n || "horizontal" !== e && "vertical" !== e || (i.$el.removeClass(`${i.params.containerModifierClass}${n}`).addClass(`${i.params.containerModifierClass}${e}`), i.params.direction = e, i.slides.each((t, i) => { "vertical" === e ? i.style.width = "" : i.style.height = "" }), i.emit("changeDirection"), t && i.update()), i } init() { const e = this; e.initialized || (e.emit("beforeInit"), e.params.breakpoints && e.setBreakpoint(), e.addClasses(), e.params.loop && e.loopCreate(), e.updateSize(), e.updateSlides(), e.params.watchOverflow && e.checkOverflow(), e.params.grabCursor && e.setGrabCursor(), e.params.preloadImages && e.preloadImages(), e.params.loop ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit), e.attachEvents(), e.initialized = !0, e.emit("init")) } destroy(e = !0, t = !0) { const i = this, { params: n, $el: r, $wrapperEl: a, slides: s } = i; return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), n.loop && i.loopDestroy(), t && (i.removeClasses(), r.removeAttr("style"), a.removeAttr("style"), s && s.length && s.removeClass([n.slideVisibleClass, n.slideActiveClass, n.slideNextClass, n.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(e => { i.off(e) }), !1 !== e && (i.$el[0].swiper = null, i.$el.data("swiper", null), Wo.deleteProps(i)), i.destroyed = !0), null } static extendDefaults(e) { Wo.extend(dl, e) } static get extendedDefaults() { return dl } static get defaults() { return hl } static get Class() { return Xo } static get $() { return Ho } } var fl = { name: "device", proto: { device: tl }, static: { device: tl } }, ml = { name: "support", proto: { support: $o }, static: { support: $o } }; const gl = { isEdge: !!Go.navigator.userAgent.match(/Edge/g), isSafari: function () { const e = Go.navigator.userAgent.toLowerCase(); return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0 }(), isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(Go.navigator.userAgent) }; var vl = { name: "browser", proto: { browser: gl }, static: { browser: gl } }, yl = { name: "resize", create() { const e = this; Wo.extend(e, { resize: { resizeHandler() { e && !e.destroyed && e.initialized && (e.emit("beforeResize"), e.emit("resize")) }, orientationChangeHandler() { e && !e.destroyed && e.initialized && e.emit("orientationchange") } } }) }, on: { init() { Go.addEventListener("resize", this.resize.resizeHandler), Go.addEventListener("orientationchange", this.resize.orientationChangeHandler) }, destroy() { Go.removeEventListener("resize", this.resize.resizeHandler), Go.removeEventListener("orientationchange", this.resize.orientationChangeHandler) } } }; const _l = { func: Go.MutationObserver || Go.WebkitMutationObserver, attach(e, t = {}) { const i = this, n = new (0, _l.func)(e => { if (1 === e.length) return void i.emit("observerUpdate", e[0]); const t = function () { i.emit("observerUpdate", e[0]) }; Go.requestAnimationFrame ? Go.requestAnimationFrame(t) : Go.setTimeout(t, 0) }); n.observe(e, { attributes: void 0 === t.attributes || t.attributes, childList: void 0 === t.childList || t.childList, characterData: void 0 === t.characterData || t.characterData }), i.observer.observers.push(n) }, init() { const e = this; if ($o.observer && e.params.observer) { if (e.params.observeParents) { const t = e.$el.parents(); for (let i = 0; i < t.length; i += 1)e.observer.attach(t[i]) } e.observer.attach(e.$el[0], { childList: e.params.observeSlideChildren }), e.observer.attach(e.$wrapperEl[0], { attributes: !1 }) } }, destroy() { this.observer.observers.forEach(e => { e.disconnect() }), this.observer.observers = [] } }; var xl = { name: "observer", params: { observer: !1, observeParents: !1, observeSlideChildren: !1 }, create() { Wo.extend(this, { observer: { init: _l.init.bind(this), attach: _l.attach.bind(this), destroy: _l.destroy.bind(this), observers: [] } }) }, on: { init() { this.observer.init() }, destroy() { this.observer.destroy() } } }; const bl = { update(e) { const t = this, { slidesPerView: i, slidesPerGroup: n, centeredSlides: r } = t.params, { addSlidesBefore: a, addSlidesAfter: s } = t.params.virtual, { from: o, to: l, slides: c, slidesGrid: h, renderSlide: u, offset: d } = t.virtual; t.updateActiveIndex(); const p = t.activeIndex || 0; let f, m, g; f = t.rtlTranslate ? "right" : t.isHorizontal() ? "left" : "top", r ? (m = Math.floor(i / 2) + n + a, g = Math.floor(i / 2) + n + s) : (m = i + (n - 1) + a, g = n + s); const v = Math.max((p || 0) - g, 0), y = Math.min((p || 0) + m, c.length - 1), _ = (t.slidesGrid[v] || 0) - (t.slidesGrid[0] || 0); function x() { t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load() } if (Wo.extend(t.virtual, { from: v, to: y, offset: _, slidesGrid: t.slidesGrid }), o === v && l === y && !e) return t.slidesGrid !== h && _ !== d && t.slides.css(f, `${_}px`), void t.updateProgress(); if (t.params.virtual.renderExternal) return t.params.virtual.renderExternal.call(t, { offset: _, from: v, to: y, slides: function () { const e = []; for (let t = v; t <= y; t += 1)e.push(c[t]); return e }() }), void x(); const b = [], w = []; if (e) t.$wrapperEl.find(`.${t.params.slideClass}`).remove(); else for (let e = o; e <= l; e += 1)(e < v || e > y) && t.$wrapperEl.find(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`).remove(); for (let t = 0; t < c.length; t += 1)t >= v && t <= y && (void 0 === l || e ? w.push(t) : (t > l && w.push(t), t < o && b.push(t))); w.forEach(e => { t.$wrapperEl.append(u(c[e], e)) }), b.sort((e, t) => t - e).forEach(e => { t.$wrapperEl.prepend(u(c[e], e)) }), t.$wrapperEl.children(".swiper-slide").css(f, `${_}px`), x() }, renderSlide(e, t) { const i = this, n = i.params.virtual; if (n.cache && i.virtual.cache[t]) return i.virtual.cache[t]; const r = n.renderSlide ? Ho(n.renderSlide.call(i, e, t)) : Ho(`<div class="${i.params.slideClass}" data-swiper-slide-index="${t}">${e}</div>`); return r.attr("data-swiper-slide-index") || r.attr("data-swiper-slide-index", t), n.cache && (i.virtual.cache[t] = r), r }, appendSlide(e) { const t = this; if ("object" == typeof e && "length" in e) for (let i = 0; i < e.length; i += 1)e[i] && t.virtual.slides.push(e[i]); else t.virtual.slides.push(e); t.virtual.update(!0) }, prependSlide(e) { const t = this, i = t.activeIndex; let n = i + 1, r = 1; if (Array.isArray(e)) { for (let i = 0; i < e.length; i += 1)e[i] && t.virtual.slides.unshift(e[i]); n = i + e.length, r = e.length } else t.virtual.slides.unshift(e); if (t.params.virtual.cache) { const e = t.virtual.cache, i = {}; Object.keys(e).forEach(t => { const n = e[t], a = n.attr("data-swiper-slide-index"); a && n.attr("data-swiper-slide-index", parseInt(a, 10) + 1), i[parseInt(t, 10) + r] = n }), t.virtual.cache = i } t.virtual.update(!0), t.slideTo(n, 0) }, removeSlide(e) { const t = this; if (null == e) return; let i = t.activeIndex; if (Array.isArray(e)) for (let n = e.length - 1; n >= 0; n -= 1)t.virtual.slides.splice(e[n], 1), t.params.virtual.cache && delete t.virtual.cache[e[n]], e[n] < i && (i -= 1), i = Math.max(i, 0); else t.virtual.slides.splice(e, 1), t.params.virtual.cache && delete t.virtual.cache[e], e < i && (i -= 1), i = Math.max(i, 0); t.virtual.update(!0), t.slideTo(i, 0) }, removeAllSlides() { const e = this; e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), e.virtual.update(!0), e.slideTo(0, 0) } }; var wl = { name: "virtual", params: { virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, addSlidesBefore: 0, addSlidesAfter: 0 } }, create() { Wo.extend(this, { virtual: { update: bl.update.bind(this), appendSlide: bl.appendSlide.bind(this), prependSlide: bl.prependSlide.bind(this), removeSlide: bl.removeSlide.bind(this), removeAllSlides: bl.removeAllSlides.bind(this), renderSlide: bl.renderSlide.bind(this), slides: this.params.virtual.slides, cache: {} } }) }, on: { beforeInit() { const e = this; if (!e.params.virtual.enabled) return; e.classNames.push(`${e.params.containerModifierClass}virtual`); const t = { watchSlidesProgress: !0 }; Wo.extend(e.params, t), Wo.extend(e.originalParams, t), e.params.initialSlide || e.virtual.update() }, setTranslate() { this.params.virtual.enabled && this.virtual.update() } } }; const Tl = { handle(e) { const t = this, { rtlTranslate: i } = t; let n = e; n.originalEvent && (n = n.originalEvent); const r = n.keyCode || n.charCode; if (!t.allowSlideNext && (t.isHorizontal() && 39 === r || t.isVertical() && 40 === r || 34 === r)) return !1; if (!t.allowSlidePrev && (t.isHorizontal() && 37 === r || t.isVertical() && 38 === r || 33 === r)) return !1; if (!(n.shiftKey || n.altKey || n.ctrlKey || n.metaKey || Fo.activeElement && Fo.activeElement.nodeName && ("input" === Fo.activeElement.nodeName.toLowerCase() || "textarea" === Fo.activeElement.nodeName.toLowerCase()))) { if (t.params.keyboard.onlyInViewport && (33 === r || 34 === r || 37 === r || 39 === r || 38 === r || 40 === r)) { let e = !1; if (t.$el.parents(`.${t.params.slideClass}`).length > 0 && 0 === t.$el.parents(`.${t.params.slideActiveClass}`).length) return; const n = Go.innerWidth, r = Go.innerHeight, a = t.$el.offset(); i && (a.left -= t.$el[0].scrollLeft); const s = [[a.left, a.top], [a.left + t.width, a.top], [a.left, a.top + t.height], [a.left + t.width, a.top + t.height]]; for (let t = 0; t < s.length; t += 1) { const i = s[t]; i[0] >= 0 && i[0] <= n && i[1] >= 0 && i[1] <= r && (e = !0) } if (!e) return } t.isHorizontal() ? (33 !== r && 34 !== r && 37 !== r && 39 !== r || (n.preventDefault ? n.preventDefault() : n.returnValue = !1), (34 !== r && 39 !== r || i) && (33 !== r && 37 !== r || !i) || t.slideNext(), (33 !== r && 37 !== r || i) && (34 !== r && 39 !== r || !i) || t.slidePrev()) : (33 !== r && 34 !== r && 38 !== r && 40 !== r || (n.preventDefault ? n.preventDefault() : n.returnValue = !1), 34 !== r && 40 !== r || t.slideNext(), 33 !== r && 38 !== r || t.slidePrev()), t.emit("keyPress", r) } }, enable() { this.keyboard.enabled || (Ho(Fo).on("keydown", this.keyboard.handle), this.keyboard.enabled = !0) }, disable() { this.keyboard.enabled && (Ho(Fo).off("keydown", this.keyboard.handle), this.keyboard.enabled = !1) } }; var Ml = { name: "keyboard", params: { keyboard: { enabled: !1, onlyInViewport: !0 } }, create() { Wo.extend(this, { keyboard: { enabled: !1, enable: Tl.enable.bind(this), disable: Tl.disable.bind(this), handle: Tl.handle.bind(this) } }) }, on: { init() { const e = this; e.params.keyboard.enabled && e.keyboard.enable() }, destroy() { const e = this; e.keyboard.enabled && e.keyboard.disable() } } }; const Sl = { lastScrollTime: Wo.now(), lastEventBeforeSnap: void 0, recentWheelEvents: [], event: () => Go.navigator.userAgent.indexOf("firefox") > -1 ? "DOMMouseScroll" : function () { let e = "onwheel" in Fo; if (!e) { const t = Fo.createElement("div"); t.setAttribute("onwheel", "return;"), e = "function" == typeof t.onwheel } return !e && Fo.implementation && Fo.implementation.hasFeature && !0 !== Fo.implementation.hasFeature("", "") && (e = Fo.implementation.hasFeature("Events.wheel", "3.0")), e }() ? "wheel" : "mousewheel", normalize(e) { let t = 0, i = 0, n = 0, r = 0; return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = i, i = 0), n = 10 * t, r = 10 * i, "deltaY" in e && (r = e.deltaY), "deltaX" in e && (n = e.deltaX), e.shiftKey && !n && (n = r, r = 0), (n || r) && e.deltaMode && (1 === e.deltaMode ? (n *= 40, r *= 40) : (n *= 800, r *= 800)), n && !t && (t = n < 1 ? -1 : 1), r && !i && (i = r < 1 ? -1 : 1), { spinX: t, spinY: i, pixelX: n, pixelY: r } }, handleMouseEnter() { this.mouseEntered = !0 }, handleMouseLeave() { this.mouseEntered = !1 }, handle(e) { let t = e; const i = this, n = i.params.mousewheel; i.params.cssMode && t.preventDefault(); let r = i.$el; if ("container" !== i.params.mousewheel.eventsTarged && (r = Ho(i.params.mousewheel.eventsTarged)), !i.mouseEntered && !r[0].contains(t.target) && !n.releaseOnEdges) return !0; t.originalEvent && (t = t.originalEvent); let a = 0; const s = i.rtlTranslate ? -1 : 1, o = Sl.normalize(t); if (n.forceToAxis) if (i.isHorizontal()) { if (!(Math.abs(o.pixelX) > Math.abs(o.pixelY))) return !0; a = o.pixelX * s } else { if (!(Math.abs(o.pixelY) > Math.abs(o.pixelX))) return !0; a = o.pixelY } else a = Math.abs(o.pixelX) > Math.abs(o.pixelY) ? -o.pixelX * s : -o.pixelY; if (0 === a) return !0; if (n.invert && (a = -a), i.params.freeMode) { const e = { time: Wo.now(), delta: Math.abs(a), direction: Math.sign(a) }, { lastEventBeforeSnap: r } = i.mousewheel, s = r && e.time < r.time + 500 && e.delta <= r.delta && e.direction === r.direction; if (!s) { i.mousewheel.lastEventBeforeSnap = void 0, i.params.loop && i.loopFix(); let r = i.getTranslate() + a * n.sensitivity; const o = i.isBeginning, l = i.isEnd; if (r >= i.minTranslate() && (r = i.minTranslate()), r <= i.maxTranslate() && (r = i.maxTranslate()), i.setTransition(0), i.setTranslate(r), i.updateProgress(), i.updateActiveIndex(), i.updateSlidesClasses(), (!o && i.isBeginning || !l && i.isEnd) && i.updateSlidesClasses(), i.params.freeModeSticky) { clearTimeout(i.mousewheel.timeout), i.mousewheel.timeout = void 0; const t = i.mousewheel.recentWheelEvents; t.length >= 15 && t.shift(); const n = t.length ? t[t.length - 1] : void 0, r = t[0]; if (t.push(e), n && (e.delta > n.delta || e.direction !== n.direction)) t.splice(0); else if (t.length >= 15 && e.time - r.time < 500 && r.delta - e.delta >= 1 && e.delta <= 6) { const n = a > 0 ? .8 : .2; i.mousewheel.lastEventBeforeSnap = e, t.splice(0), i.mousewheel.timeout = Wo.nextTick(() => { i.slideToClosest(i.params.speed, !0, void 0, n) }, 0) } i.mousewheel.timeout || (i.mousewheel.timeout = Wo.nextTick(() => { i.mousewheel.lastEventBeforeSnap = e, t.splice(0), i.slideToClosest(i.params.speed, !0, void 0, .5) }, 500)) } if (s || i.emit("scroll", t), i.params.autoplay && i.params.autoplayDisableOnInteraction && i.autoplay.stop(), r === i.minTranslate() || r === i.maxTranslate()) return !0 } } else { const t = { time: Wo.now(), delta: Math.abs(a), direction: Math.sign(a), raw: e }, n = i.mousewheel.recentWheelEvents; n.length >= 2 && n.shift(); const r = n.length ? n[n.length - 1] : void 0; if (n.push(t), r ? (t.direction !== r.direction || t.delta > r.delta) && i.mousewheel.animateSlider(t) : i.mousewheel.animateSlider(t), i.mousewheel.releaseScroll(t)) return !0 } return t.preventDefault ? t.preventDefault() : t.returnValue = !1, !1 }, animateSlider(e) { const t = this; return e.delta >= 6 && Wo.now() - t.mousewheel.lastScrollTime < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), t.emit("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), t.emit("scroll", e.raw)), t.mousewheel.lastScrollTime = (new Go.Date).getTime(), !1) }, releaseScroll(e) { const t = this, i = t.params.mousewheel; if (e.direction < 0) { if (t.isEnd && !t.params.loop && i.releaseOnEdges) return !0 } else if (t.isBeginning && !t.params.loop && i.releaseOnEdges) return !0; return !1 }, enable() { const e = this, t = Sl.event(); if (e.params.cssMode) return e.wrapperEl.removeEventListener(t, e.mousewheel.handle), !0; if (!t) return !1; if (e.mousewheel.enabled) return !1; let i = e.$el; return "container" !== e.params.mousewheel.eventsTarged && (i = Ho(e.params.mousewheel.eventsTarged)), i.on("mouseenter", e.mousewheel.handleMouseEnter), i.on("mouseleave", e.mousewheel.handleMouseLeave), i.on(t, e.mousewheel.handle), e.mousewheel.enabled = !0, !0 }, disable() { const e = this, t = Sl.event(); if (e.params.cssMode) return e.wrapperEl.addEventListener(t, e.mousewheel.handle), !0; if (!t) return !1; if (!e.mousewheel.enabled) return !1; let i = e.$el; return "container" !== e.params.mousewheel.eventsTarged && (i = Ho(e.params.mousewheel.eventsTarged)), i.off(t, e.mousewheel.handle), e.mousewheel.enabled = !1, !0 } }; const El = { update() { const e = this, t = e.params.navigation; if (e.params.loop) return; const { $nextEl: i, $prevEl: n } = e.navigation; n && n.length > 0 && (e.isBeginning ? n.addClass(t.disabledClass) : n.removeClass(t.disabledClass), n[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](t.lockClass)), i && i.length > 0 && (e.isEnd ? i.addClass(t.disabledClass) : i.removeClass(t.disabledClass), i[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](t.lockClass)) }, onPrevClick(e) { e.preventDefault(), this.isBeginning && !this.params.loop || this.slidePrev() }, onNextClick(e) { e.preventDefault(), this.isEnd && !this.params.loop || this.slideNext() }, init() { const e = this, t = e.params.navigation; if (!t.nextEl && !t.prevEl) return; let i, n; t.nextEl && (i = Ho(t.nextEl), e.params.uniqueNavElements && "string" == typeof t.nextEl && i.length > 1 && 1 === e.$el.find(t.nextEl).length && (i = e.$el.find(t.nextEl))), t.prevEl && (n = Ho(t.prevEl), e.params.uniqueNavElements && "string" == typeof t.prevEl && n.length > 1 && 1 === e.$el.find(t.prevEl).length && (n = e.$el.find(t.prevEl))), i && i.length > 0 && i.on("click", e.navigation.onNextClick), n && n.length > 0 && n.on("click", e.navigation.onPrevClick), Wo.extend(e.navigation, { $nextEl: i, nextEl: i && i[0], $prevEl: n, prevEl: n && n[0] }) }, destroy() { const e = this, { $nextEl: t, $prevEl: i } = e.navigation; t && t.length && (t.off("click", e.navigation.onNextClick), t.removeClass(e.params.navigation.disabledClass)), i && i.length && (i.off("click", e.navigation.onPrevClick), i.removeClass(e.params.navigation.disabledClass)) } }; const Cl = { update() { const e = this, t = e.rtl, i = e.params.pagination; if (!i.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length) return; const n = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, r = e.pagination.$el; let a; const s = e.params.loop ? Math.ceil((n - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (a = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup), a > n - 1 - 2 * e.loopedSlides && (a -= n - 2 * e.loopedSlides), a > s - 1 && (a -= s), a < 0 && "bullets" !== e.params.paginationType && (a = s + a)) : a = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0, "bullets" === i.type && e.pagination.bullets && e.pagination.bullets.length > 0) { const n = e.pagination.bullets; let s, o, l; if (i.dynamicBullets && (e.pagination.bulletSize = n.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), r.css(e.isHorizontal() ? "width" : "height", `${e.pagination.bulletSize * (i.dynamicMainBullets + 4)}px`), i.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (e.pagination.dynamicBulletIndex += a - e.previousIndex, e.pagination.dynamicBulletIndex > i.dynamicMainBullets - 1 ? e.pagination.dynamicBulletIndex = i.dynamicMainBullets - 1 : e.pagination.dynamicBulletIndex < 0 && (e.pagination.dynamicBulletIndex = 0)), s = a - e.pagination.dynamicBulletIndex, o = s + (Math.min(n.length, i.dynamicMainBullets) - 1), l = (o + s) / 2), n.removeClass(`${i.bulletActiveClass} ${i.bulletActiveClass}-next ${i.bulletActiveClass}-next-next ${i.bulletActiveClass}-prev ${i.bulletActiveClass}-prev-prev ${i.bulletActiveClass}-main`), r.length > 1) n.each((e, t) => { const n = Ho(t), r = n.index(); r === a && n.addClass(i.bulletActiveClass), i.dynamicBullets && (r >= s && r <= o && n.addClass(`${i.bulletActiveClass}-main`), r === s && n.prev().addClass(`${i.bulletActiveClass}-prev`).prev().addClass(`${i.bulletActiveClass}-prev-prev`), r === o && n.next().addClass(`${i.bulletActiveClass}-next`).next().addClass(`${i.bulletActiveClass}-next-next`)) }); else { const t = n.eq(a), r = t.index(); if (t.addClass(i.bulletActiveClass), i.dynamicBullets) { const t = n.eq(s), a = n.eq(o); for (let e = s; e <= o; e += 1)n.eq(e).addClass(`${i.bulletActiveClass}-main`); if (e.params.loop) if (r >= n.length - i.dynamicMainBullets) { for (let e = i.dynamicMainBullets; e >= 0; e -= 1)n.eq(n.length - e).addClass(`${i.bulletActiveClass}-main`); n.eq(n.length - i.dynamicMainBullets - 1).addClass(`${i.bulletActiveClass}-prev`) } else t.prev().addClass(`${i.bulletActiveClass}-prev`).prev().addClass(`${i.bulletActiveClass}-prev-prev`), a.next().addClass(`${i.bulletActiveClass}-next`).next().addClass(`${i.bulletActiveClass}-next-next`); else t.prev().addClass(`${i.bulletActiveClass}-prev`).prev().addClass(`${i.bulletActiveClass}-prev-prev`), a.next().addClass(`${i.bulletActiveClass}-next`).next().addClass(`${i.bulletActiveClass}-next-next`) } } if (i.dynamicBullets) { const r = Math.min(n.length, i.dynamicMainBullets + 4), a = (e.pagination.bulletSize * r - e.pagination.bulletSize) / 2 - l * e.pagination.bulletSize, s = t ? "right" : "left"; n.css(e.isHorizontal() ? s : "top", `${a}px`) } } if ("fraction" === i.type && (r.find(`.${i.currentClass}`).text(i.formatFractionCurrent(a + 1)), r.find(`.${i.totalClass}`).text(i.formatFractionTotal(s))), "progressbar" === i.type) { let t; t = i.progressbarOpposite ? e.isHorizontal() ? "vertical" : "horizontal" : e.isHorizontal() ? "horizontal" : "vertical"; const n = (a + 1) / s; let o = 1, l = 1; "horizontal" === t ? o = n : l = n, r.find(`.${i.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${o}) scaleY(${l})`).transition(e.params.speed) } "custom" === i.type && i.renderCustom ? (r.html(i.renderCustom(e, a + 1, s)), e.emit("paginationRender", e, r[0])) : e.emit("paginationUpdate", e, r[0]), r[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](i.lockClass) }, render() { const e = this, t = e.params.pagination; if (!t.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length) return; const i = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, n = e.pagination.$el; let r = ""; if ("bullets" === t.type) { const a = e.params.loop ? Math.ceil((i - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length; for (let i = 0; i < a; i += 1)t.renderBullet ? r += t.renderBullet.call(e, i, t.bulletClass) : r += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`; n.html(r), e.pagination.bullets = n.find(`.${t.bulletClass}`) } "fraction" === t.type && (r = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span>` + " / " + `<span class="${t.totalClass}"></span>`, n.html(r)), "progressbar" === t.type && (r = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, n.html(r)), "custom" !== t.type && e.emit("paginationRender", e.pagination.$el[0]) }, init() { const e = this, t = e.params.pagination; if (!t.el) return; let i = Ho(t.el); 0 !== i.length && (e.params.uniqueNavElements && "string" == typeof t.el && i.length > 1 && 1 === e.$el.find(t.el).length && (i = e.$el.find(t.el)), "bullets" === t.type && t.clickable && i.addClass(t.clickableClass), i.addClass(t.modifierClass + t.type), "bullets" === t.type && t.dynamicBullets && (i.addClass(`${t.modifierClass}${t.type}-dynamic`), e.pagination.dynamicBulletIndex = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), "progressbar" === t.type && t.progressbarOpposite && i.addClass(t.progressbarOppositeClass), t.clickable && i.on("click", `.${t.bulletClass}`, (function (t) { t.preventDefault(); let i = Ho(this).index() * e.params.slidesPerGroup; e.params.loop && (i += e.loopedSlides), e.slideTo(i) })), Wo.extend(e.pagination, { $el: i, el: i[0] })) }, destroy() { const e = this.params.pagination; if (!e.el || !this.pagination.el || !this.pagination.$el || 0 === this.pagination.$el.length) return; const t = this.pagination.$el; t.removeClass(e.hiddenClass), t.removeClass(e.modifierClass + e.type), this.pagination.bullets && this.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && t.off("click", `.${e.bulletClass}`) } }; const Al = { setTranslate() { const e = this; if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t, rtlTranslate: i, progress: n } = e, { dragSize: r, trackSize: a, $dragEl: s, $el: o } = t, l = e.params.scrollbar; let c = r, h = (a - r) * n; i ? (h = -h, h > 0 ? (c = r - h, h = 0) : -h + r > a && (c = a + h)) : h < 0 ? (c = r + h, h = 0) : h + r > a && (c = a - h), e.isHorizontal() ? (s.transform(`translate3d(${h}px, 0, 0)`), s[0].style.width = `${c}px`) : (s.transform(`translate3d(0px, ${h}px, 0)`), s[0].style.height = `${c}px`), l.hide && (clearTimeout(e.scrollbar.timeout), o[0].style.opacity = 1, e.scrollbar.timeout = setTimeout(() => { o[0].style.opacity = 0, o.transition(400) }, 1e3)) }, setTransition(e) { this.params.scrollbar.el && this.scrollbar.el && this.scrollbar.$dragEl.transition(e) }, updateSize() { const e = this; if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: t } = e, { $dragEl: i, $el: n } = t; i[0].style.width = "", i[0].style.height = ""; const r = e.isHorizontal() ? n[0].offsetWidth : n[0].offsetHeight, a = e.size / e.virtualSize, s = a * (r / e.size); let o; o = "auto" === e.params.scrollbar.dragSize ? r * a : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? i[0].style.width = `${o}px` : i[0].style.height = `${o}px`, n[0].style.display = a >= 1 ? "none" : "", e.params.scrollbar.hide && (n[0].style.opacity = 0), Wo.extend(t, { trackSize: r, divider: a, moveDivider: s, dragSize: o }), t.$el[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](e.params.scrollbar.lockClass) }, getPointerPosition(e) { return this.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientX : e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientY : e.clientY }, setDragPosition(e) { const { scrollbar: t, rtlTranslate: i } = this, { $el: n, dragSize: r, trackSize: a, dragStartPos: s } = t; let o; o = (t.getPointerPosition(e) - n.offset()[this.isHorizontal() ? "left" : "top"] - (null !== s ? s : r / 2)) / (a - r), o = Math.max(Math.min(o, 1), 0), i && (o = 1 - o); const l = this.minTranslate() + (this.maxTranslate() - this.minTranslate()) * o; this.updateProgress(l), this.setTranslate(l), this.updateActiveIndex(), this.updateSlidesClasses() }, onDragStart(e) { const t = this, i = t.params.scrollbar, { scrollbar: n, $wrapperEl: r } = t, { $el: a, $dragEl: s } = n; t.scrollbar.isTouched = !0, t.scrollbar.dragStartPos = e.target === s[0] || e.target === s ? n.getPointerPosition(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), r.transition(100), s.transition(100), n.setDragPosition(e), clearTimeout(t.scrollbar.dragTimeout), a.transition(0), i.hide && a.css("opacity", 1), t.params.cssMode && t.$wrapperEl.css("scroll-snap-type", "none"), t.emit("scrollbarDragStart", e) }, onDragMove(e) { const { scrollbar: t, $wrapperEl: i } = this, { $el: n, $dragEl: r } = t; this.scrollbar.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, t.setDragPosition(e), i.transition(0), n.transition(0), r.transition(0), this.emit("scrollbarDragMove", e)) }, onDragEnd(e) { const t = this, i = t.params.scrollbar, { scrollbar: n, $wrapperEl: r } = t, { $el: a } = n; t.scrollbar.isTouched && (t.scrollbar.isTouched = !1, t.params.cssMode && (t.$wrapperEl.css("scroll-snap-type", ""), r.transition("")), i.hide && (clearTimeout(t.scrollbar.dragTimeout), t.scrollbar.dragTimeout = Wo.nextTick(() => { a.css("opacity", 0), a.transition(400) }, 1e3)), t.emit("scrollbarDragEnd", e), i.snapOnRelease && t.slideToClosest()) }, enableDraggable() { const e = this; if (!e.params.scrollbar.el) return; const { scrollbar: t, touchEventsTouch: i, touchEventsDesktop: n, params: r } = e, a = t.$el[0], s = !(!$o.passiveListener || !r.passiveListeners) && { passive: !1, capture: !1 }, o = !(!$o.passiveListener || !r.passiveListeners) && { passive: !0, capture: !1 }; $o.touch ? (a.addEventListener(i.start, e.scrollbar.onDragStart, s), a.addEventListener(i.move, e.scrollbar.onDragMove, s), a.addEventListener(i.end, e.scrollbar.onDragEnd, o)) : (a.addEventListener(n.start, e.scrollbar.onDragStart, s), Fo.addEventListener(n.move, e.scrollbar.onDragMove, s), Fo.addEventListener(n.end, e.scrollbar.onDragEnd, o)) }, disableDraggable() { const e = this; if (!e.params.scrollbar.el) return; const { scrollbar: t, touchEventsTouch: i, touchEventsDesktop: n, params: r } = e, a = t.$el[0], s = !(!$o.passiveListener || !r.passiveListeners) && { passive: !1, capture: !1 }, o = !(!$o.passiveListener || !r.passiveListeners) && { passive: !0, capture: !1 }; $o.touch ? (a.removeEventListener(i.start, e.scrollbar.onDragStart, s), a.removeEventListener(i.move, e.scrollbar.onDragMove, s), a.removeEventListener(i.end, e.scrollbar.onDragEnd, o)) : (a.removeEventListener(n.start, e.scrollbar.onDragStart, s), Fo.removeEventListener(n.move, e.scrollbar.onDragMove, s), Fo.removeEventListener(n.end, e.scrollbar.onDragEnd, o)) }, init() { const e = this; if (!e.params.scrollbar.el) return; const { scrollbar: t, $el: i } = e, n = e.params.scrollbar; let r = Ho(n.el); e.params.uniqueNavElements && "string" == typeof n.el && r.length > 1 && 1 === i.find(n.el).length && (r = i.find(n.el)); let a = r.find(`.${e.params.scrollbar.dragClass}`); 0 === a.length && (a = Ho(`<div class="${e.params.scrollbar.dragClass}"></div>`), r.append(a)), Wo.extend(t, { $el: r, el: r[0], $dragEl: a, dragEl: a[0] }), n.draggable && t.enableDraggable() }, destroy() { this.scrollbar.disableDraggable() } }; const Pl = { setTransform(e, t) { const { rtl: i } = this, n = Ho(e), r = i ? -1 : 1, a = n.attr("data-swiper-parallax") || "0"; let s = n.attr("data-swiper-parallax-x"), o = n.attr("data-swiper-parallax-y"); const l = n.attr("data-swiper-parallax-scale"), c = n.attr("data-swiper-parallax-opacity"); if (s || o ? (s = s || "0", o = o || "0") : this.isHorizontal() ? (s = a, o = "0") : (o = a, s = "0"), s = s.indexOf("%") >= 0 ? `${parseInt(s, 10) * t * r}%` : `${s * t * r}px`, o = o.indexOf("%") >= 0 ? `${parseInt(o, 10) * t}%` : `${o * t}px`, null != c) { const e = c - (c - 1) * (1 - Math.abs(t)); n[0].style.opacity = e } if (null == l) n.transform(`translate3d(${s}, ${o}, 0px)`); else { const e = l - (l - 1) * (1 - Math.abs(t)); n.transform(`translate3d(${s}, ${o}, 0px) scale(${e})`) } }, setTranslate() { const e = this, { $el: t, slides: i, progress: n, snapGrid: r } = e; t.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t, i) => { e.parallax.setTransform(i, n) }), i.each((t, i) => { let a = i.progress; e.params.slidesPerGroup > 1 && "auto" !== e.params.slidesPerView && (a += Math.ceil(t / 2) - n * (r.length - 1)), a = Math.min(Math.max(a, -1), 1), Ho(i).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t, i) => { e.parallax.setTransform(i, a) }) }) }, setTransition(e = this.params.speed) { const { $el: t } = this; t.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t, i) => { const n = Ho(i); let r = parseInt(n.attr("data-swiper-parallax-duration"), 10) || e; 0 === e && (r = 0), n.transition(r) }) } }; const Ll = { getDistanceBetweenTouches(e) { if (e.targetTouches.length < 2) return 1; const t = e.targetTouches[0].pageX, i = e.targetTouches[0].pageY, n = e.targetTouches[1].pageX, r = e.targetTouches[1].pageY; return Math.sqrt((n - t) ** 2 + (r - i) ** 2) }, onGestureStart(e) { const t = this, i = t.params.zoom, n = t.zoom, { gesture: r } = n; if (n.fakeGestureTouched = !1, n.fakeGestureMoved = !1, !$o.gestures) { if ("touchstart" !== e.type || "touchstart" === e.type && e.targetTouches.length < 2) return; n.fakeGestureTouched = !0, r.scaleStart = Ll.getDistanceBetweenTouches(e) } r.$slideEl && r.$slideEl.length || (r.$slideEl = Ho(e.target).closest(`.${t.params.slideClass}`), 0 === r.$slideEl.length && (r.$slideEl = t.slides.eq(t.activeIndex)), r.$imageEl = r.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), r.$imageWrapEl = r.$imageEl.parent(`.${i.containerClass}`), r.maxRatio = r.$imageWrapEl.attr("data-swiper-zoom") || i.maxRatio, 0 !== r.$imageWrapEl.length) ? (r.$imageEl && r.$imageEl.transition(0), t.zoom.isScaling = !0) : r.$imageEl = void 0 }, onGestureChange(e) { const t = this.params.zoom, i = this.zoom, { gesture: n } = i; if (!$o.gestures) { if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return; i.fakeGestureMoved = !0, n.scaleMove = Ll.getDistanceBetweenTouches(e) } n.$imageEl && 0 !== n.$imageEl.length && (i.scale = $o.gestures ? e.scale * i.currentScale : n.scaleMove / n.scaleStart * i.currentScale, i.scale > n.maxRatio && (i.scale = n.maxRatio - 1 + (i.scale - n.maxRatio + 1) ** .5), i.scale < t.minRatio && (i.scale = t.minRatio + 1 - (t.minRatio - i.scale + 1) ** .5), n.$imageEl.transform(`translate3d(0,0,0) scale(${i.scale})`)) }, onGestureEnd(e) { const t = this.params.zoom, i = this.zoom, { gesture: n } = i; if (!$o.gestures) { if (!i.fakeGestureTouched || !i.fakeGestureMoved) return; if ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2 && !tl.android) return; i.fakeGestureTouched = !1, i.fakeGestureMoved = !1 } n.$imageEl && 0 !== n.$imageEl.length && (i.scale = Math.max(Math.min(i.scale, n.maxRatio), t.minRatio), n.$imageEl.transition(this.params.speed).transform(`translate3d(0,0,0) scale(${i.scale})`), i.currentScale = i.scale, i.isScaling = !1, 1 === i.scale && (n.$slideEl = void 0)) }, onTouchStart(e) { const t = this.zoom, { gesture: i, image: n } = t; i.$imageEl && 0 !== i.$imageEl.length && (n.isTouched || (tl.android && e.preventDefault(), n.isTouched = !0, n.touchesStart.x = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, n.touchesStart.y = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY)) }, onTouchMove(e) { const t = this, i = t.zoom, { gesture: n, image: r, velocity: a } = i; if (!n.$imageEl || 0 === n.$imageEl.length) return; if (t.allowClick = !1, !r.isTouched || !n.$slideEl) return; r.isMoved || (r.width = n.$imageEl[0].offsetWidth, r.height = n.$imageEl[0].offsetHeight, r.startX = Wo.getTranslate(n.$imageWrapEl[0], "x") || 0, r.startY = Wo.getTranslate(n.$imageWrapEl[0], "y") || 0, n.slideWidth = n.$slideEl[0].offsetWidth, n.slideHeight = n.$slideEl[0].offsetHeight, n.$imageWrapEl.transition(0), t.rtl && (r.startX = -r.startX, r.startY = -r.startY)); const s = r.width * i.scale, o = r.height * i.scale; if (!(s < n.slideWidth && o < n.slideHeight)) { if (r.minX = Math.min(n.slideWidth / 2 - s / 2, 0), r.maxX = -r.minX, r.minY = Math.min(n.slideHeight / 2 - o / 2, 0), r.maxY = -r.minY, r.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, r.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !r.isMoved && !i.isScaling) { if (t.isHorizontal() && (Math.floor(r.minX) === Math.floor(r.startX) && r.touchesCurrent.x < r.touchesStart.x || Math.floor(r.maxX) === Math.floor(r.startX) && r.touchesCurrent.x > r.touchesStart.x)) return void (r.isTouched = !1); if (!t.isHorizontal() && (Math.floor(r.minY) === Math.floor(r.startY) && r.touchesCurrent.y < r.touchesStart.y || Math.floor(r.maxY) === Math.floor(r.startY) && r.touchesCurrent.y > r.touchesStart.y)) return void (r.isTouched = !1) } e.preventDefault(), e.stopPropagation(), r.isMoved = !0, r.currentX = r.touchesCurrent.x - r.touchesStart.x + r.startX, r.currentY = r.touchesCurrent.y - r.touchesStart.y + r.startY, r.currentX < r.minX && (r.currentX = r.minX + 1 - (r.minX - r.currentX + 1) ** .8), r.currentX > r.maxX && (r.currentX = r.maxX - 1 + (r.currentX - r.maxX + 1) ** .8), r.currentY < r.minY && (r.currentY = r.minY + 1 - (r.minY - r.currentY + 1) ** .8), r.currentY > r.maxY && (r.currentY = r.maxY - 1 + (r.currentY - r.maxY + 1) ** .8), a.prevPositionX || (a.prevPositionX = r.touchesCurrent.x), a.prevPositionY || (a.prevPositionY = r.touchesCurrent.y), a.prevTime || (a.prevTime = Date.now()), a.x = (r.touchesCurrent.x - a.prevPositionX) / (Date.now() - a.prevTime) / 2, a.y = (r.touchesCurrent.y - a.prevPositionY) / (Date.now() - a.prevTime) / 2, Math.abs(r.touchesCurrent.x - a.prevPositionX) < 2 && (a.x = 0), Math.abs(r.touchesCurrent.y - a.prevPositionY) < 2 && (a.y = 0), a.prevPositionX = r.touchesCurrent.x, a.prevPositionY = r.touchesCurrent.y, a.prevTime = Date.now(), n.$imageWrapEl.transform(`translate3d(${r.currentX}px, ${r.currentY}px,0)`) } }, onTouchEnd() { const e = this.zoom, { gesture: t, image: i, velocity: n } = e; if (!t.$imageEl || 0 === t.$imageEl.length) return; if (!i.isTouched || !i.isMoved) return i.isTouched = !1, void (i.isMoved = !1); i.isTouched = !1, i.isMoved = !1; let r = 300, a = 300; const s = n.x * r, o = i.currentX + s, l = n.y * a, c = i.currentY + l; 0 !== n.x && (r = Math.abs((o - i.currentX) / n.x)), 0 !== n.y && (a = Math.abs((c - i.currentY) / n.y)); const h = Math.max(r, a); i.currentX = o, i.currentY = c; const u = i.width * e.scale, d = i.height * e.scale; i.minX = Math.min(t.slideWidth / 2 - u / 2, 0), i.maxX = -i.minX, i.minY = Math.min(t.slideHeight / 2 - d / 2, 0), i.maxY = -i.minY, i.currentX = Math.max(Math.min(i.currentX, i.maxX), i.minX), i.currentY = Math.max(Math.min(i.currentY, i.maxY), i.minY), t.$imageWrapEl.transition(h).transform(`translate3d(${i.currentX}px, ${i.currentY}px,0)`) }, onTransitionEnd() { const e = this.zoom, { gesture: t } = e; t.$slideEl && this.previousIndex !== this.activeIndex && (t.$imageEl && t.$imageEl.transform("translate3d(0,0,0) scale(1)"), t.$imageWrapEl && t.$imageWrapEl.transform("translate3d(0,0,0)"), e.scale = 1, e.currentScale = 1, t.$slideEl = void 0, t.$imageEl = void 0, t.$imageWrapEl = void 0) }, toggle(e) { const t = this.zoom; t.scale && 1 !== t.scale ? t.out() : t.in(e) }, in(e) { const t = this, i = t.zoom, n = t.params.zoom, { gesture: r, image: a } = i; if (r.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? r.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : r.$slideEl = t.slides.eq(t.activeIndex), r.$imageEl = r.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), r.$imageWrapEl = r.$imageEl.parent(`.${n.containerClass}`)), !r.$imageEl || 0 === r.$imageEl.length) return; let s, o, l, c, h, u, d, p, f, m, g, v, y, _, x, b, w, T; r.$slideEl.addClass(`${n.zoomedSlideClass}`), void 0 === a.touchesStart.x && e ? (s = "touchend" === e.type ? e.changedTouches[0].pageX : e.pageX, o = "touchend" === e.type ? e.changedTouches[0].pageY : e.pageY) : (s = a.touchesStart.x, o = a.touchesStart.y), i.scale = r.$imageWrapEl.attr("data-swiper-zoom") || n.maxRatio, i.currentScale = r.$imageWrapEl.attr("data-swiper-zoom") || n.maxRatio, e ? (w = r.$slideEl[0].offsetWidth, T = r.$slideEl[0].offsetHeight, l = r.$slideEl.offset().left, c = r.$slideEl.offset().top, h = l + w / 2 - s, u = c + T / 2 - o, f = r.$imageEl[0].offsetWidth, m = r.$imageEl[0].offsetHeight, g = f * i.scale, v = m * i.scale, y = Math.min(w / 2 - g / 2, 0), _ = Math.min(T / 2 - v / 2, 0), x = -y, b = -_, d = h * i.scale, p = u * i.scale, d < y && (d = y), d > x && (d = x), p < _ && (p = _), p > b && (p = b)) : (d = 0, p = 0), r.$imageWrapEl.transition(300).transform(`translate3d(${d}px, ${p}px,0)`), r.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${i.scale})`) }, out() { const e = this, t = e.zoom, i = e.params.zoom, { gesture: n } = t; n.$slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? n.$slideEl = e.$wrapperEl.children(`.${e.params.slideActiveClass}`) : n.$slideEl = e.slides.eq(e.activeIndex), n.$imageEl = n.$slideEl.find("img, svg, canvas, picture, .swiper-zoom-target"), n.$imageWrapEl = n.$imageEl.parent(`.${i.containerClass}`)), n.$imageEl && 0 !== n.$imageEl.length && (t.scale = 1, t.currentScale = 1, n.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), n.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), n.$slideEl.removeClass(`${i.zoomedSlideClass}`), n.$slideEl = void 0) }, enable() { const e = this, t = e.zoom; if (t.enabled) return; t.enabled = !0; const i = !("touchstart" !== e.touchEvents.start || !$o.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }, n = !$o.passiveListener || { passive: !1, capture: !0 }, r = `.${e.params.slideClass}`; $o.gestures ? (e.$wrapperEl.on("gesturestart", r, t.onGestureStart, i), e.$wrapperEl.on("gesturechange", r, t.onGestureChange, i), e.$wrapperEl.on("gestureend", r, t.onGestureEnd, i)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.on(e.touchEvents.start, r, t.onGestureStart, i), e.$wrapperEl.on(e.touchEvents.move, r, t.onGestureChange, n), e.$wrapperEl.on(e.touchEvents.end, r, t.onGestureEnd, i), e.touchEvents.cancel && e.$wrapperEl.on(e.touchEvents.cancel, r, t.onGestureEnd, i)), e.$wrapperEl.on(e.touchEvents.move, `.${e.params.zoom.containerClass}`, t.onTouchMove, n) }, disable() { const e = this, t = e.zoom; if (!t.enabled) return; e.zoom.enabled = !1; const i = !("touchstart" !== e.touchEvents.start || !$o.passiveListener || !e.params.passiveListeners) && { passive: !0, capture: !1 }, n = !$o.passiveListener || { passive: !1, capture: !0 }, r = `.${e.params.slideClass}`; $o.gestures ? (e.$wrapperEl.off("gesturestart", r, t.onGestureStart, i), e.$wrapperEl.off("gesturechange", r, t.onGestureChange, i), e.$wrapperEl.off("gestureend", r, t.onGestureEnd, i)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.off(e.touchEvents.start, r, t.onGestureStart, i), e.$wrapperEl.off(e.touchEvents.move, r, t.onGestureChange, n), e.$wrapperEl.off(e.touchEvents.end, r, t.onGestureEnd, i), e.touchEvents.cancel && e.$wrapperEl.off(e.touchEvents.cancel, r, t.onGestureEnd, i)), e.$wrapperEl.off(e.touchEvents.move, `.${e.params.zoom.containerClass}`, t.onTouchMove, n) } }; const Rl = { loadInSlide(e, t = !0) { const i = this, n = i.params.lazy; if (void 0 === e) return; if (0 === i.slides.length) return; const r = i.virtual && i.params.virtual.enabled ? i.$wrapperEl.children(`.${i.params.slideClass}[data-swiper-slide-index="${e}"]`) : i.slides.eq(e); let a = r.find(`.${n.elementClass}:not(.${n.loadedClass}):not(.${n.loadingClass})`); !r.hasClass(n.elementClass) || r.hasClass(n.loadedClass) || r.hasClass(n.loadingClass) || (a = a.add(r[0])), 0 !== a.length && a.each((e, a) => { const s = Ho(a); s.addClass(n.loadingClass); const o = s.attr("data-background"), l = s.attr("data-src"), c = s.attr("data-srcset"), h = s.attr("data-sizes"); i.loadImage(s[0], l || o, c, h, !1, () => { if (null != i && i && (!i || i.params) && !i.destroyed) { if (o ? (s.css("background-image", `url("${o}")`), s.removeAttr("data-background")) : (c && (s.attr("srcset", c), s.removeAttr("data-srcset")), h && (s.attr("sizes", h), s.removeAttr("data-sizes")), l && (s.attr("src", l), s.removeAttr("data-src"))), s.addClass(n.loadedClass).removeClass(n.loadingClass), r.find(`.${n.preloaderClass}`).remove(), i.params.loop && t) { const e = r.attr("data-swiper-slide-index"); if (r.hasClass(i.params.slideDuplicateClass)) { const t = i.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${i.params.slideDuplicateClass})`); i.lazy.loadInSlide(t.index(), !1) } else { const t = i.$wrapperEl.children(`.${i.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`); i.lazy.loadInSlide(t.index(), !1) } } i.emit("lazyImageReady", r[0], s[0]), i.params.autoHeight && i.updateAutoHeight() } }), i.emit("lazyImageLoad", r[0], s[0]) }) }, load() { const e = this, { $wrapperEl: t, params: i, slides: n, activeIndex: r } = e, a = e.virtual && i.virtual.enabled, s = i.lazy; let o = i.slidesPerView; function l(e) { if (a) { if (t.children(`.${i.slideClass}[data-swiper-slide-index="${e}"]`).length) return !0 } else if (n[e]) return !0; return !1 } function c(e) { return a ? Ho(e).attr("data-swiper-slide-index") : Ho(e).index() } if ("auto" === o && (o = 0), e.lazy.initialImageLoaded || (e.lazy.initialImageLoaded = !0), e.params.watchSlidesVisibility) t.children(`.${i.slideVisibleClass}`).each((t, i) => { const n = a ? Ho(i).attr("data-swiper-slide-index") : Ho(i).index(); e.lazy.loadInSlide(n) }); else if (o > 1) for (let t = r; t < r + o; t += 1)l(t) && e.lazy.loadInSlide(t); else e.lazy.loadInSlide(r); if (s.loadPrevNext) if (o > 1 || s.loadPrevNextAmount && s.loadPrevNextAmount > 1) { const t = s.loadPrevNextAmount, i = o, a = Math.min(r + i + Math.max(t, i), n.length), c = Math.max(r - Math.max(i, t), 0); for (let t = r + o; t < a; t += 1)l(t) && e.lazy.loadInSlide(t); for (let t = c; t < r; t += 1)l(t) && e.lazy.loadInSlide(t) } else { const n = t.children(`.${i.slideNextClass}`); n.length > 0 && e.lazy.loadInSlide(c(n)); const r = t.children(`.${i.slidePrevClass}`); r.length > 0 && e.lazy.loadInSlide(c(r)) } } }; const Ol = { LinearSpline: function (e, t) { const i = function () { let e, t, i; return (n, r) => { for (t = -1, e = n.length; e - t > 1;)i = e + t >> 1, n[i] <= r ? t = i : e = i; return e } }(); let n, r; return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) { return e ? (r = i(this.x, e), n = r - 1, (e - this.x[n]) * (this.y[r] - this.y[n]) / (this.x[r] - this.x[n]) + this.y[n]) : 0 }, this }, getInterpolateFunction(e) { const t = this; t.controller.spline || (t.controller.spline = t.params.loop ? new Ol.LinearSpline(t.slidesGrid, e.slidesGrid) : new Ol.LinearSpline(t.snapGrid, e.snapGrid)) }, setTranslate(e, t) { const i = this, n = i.controller.control; let r, a; function s(e) { const t = i.rtlTranslate ? -i.translate : i.translate; "slide" === i.params.controller.by && (i.controller.getInterpolateFunction(e), a = -i.controller.spline.interpolate(-t)), a && "container" !== i.params.controller.by || (r = (e.maxTranslate() - e.minTranslate()) / (i.maxTranslate() - i.minTranslate()), a = (t - i.minTranslate()) * r + e.minTranslate()), i.params.controller.inverse && (a = e.maxTranslate() - a), e.updateProgress(a), e.setTranslate(a, i), e.updateActiveIndex(), e.updateSlidesClasses() } if (Array.isArray(n)) for (let e = 0; e < n.length; e += 1)n[e] !== t && n[e] instanceof pl && s(n[e]); else n instanceof pl && t !== n && s(n) }, setTransition(e, t) { const i = this, n = i.controller.control; let r; function a(t) { t.setTransition(e, i), 0 !== e && (t.transitionStart(), t.params.autoHeight && Wo.nextTick(() => { t.updateAutoHeight() }), t.$wrapperEl.transitionEnd(() => { n && (t.params.loop && "slide" === i.params.controller.by && t.loopFix(), t.transitionEnd()) })) } if (Array.isArray(n)) for (r = 0; r < n.length; r += 1)n[r] !== t && n[r] instanceof pl && a(n[r]); else n instanceof pl && t !== n && a(n) } }; const Il = { makeElFocusable: e => (e.attr("tabIndex", "0"), e), addElRole: (e, t) => (e.attr("role", t), e), addElLabel: (e, t) => (e.attr("aria-label", t), e), disableEl: e => (e.attr("aria-disabled", !0), e), enableEl: e => (e.attr("aria-disabled", !1), e), onEnterKey(e) { const t = this, i = t.params.a11y; if (13 !== e.keyCode) return; const n = Ho(e.target); t.navigation && t.navigation.$nextEl && n.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? t.a11y.notify(i.lastSlideMessage) : t.a11y.notify(i.nextSlideMessage)), t.navigation && t.navigation.$prevEl && n.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? t.a11y.notify(i.firstSlideMessage) : t.a11y.notify(i.prevSlideMessage)), t.pagination && n.is(`.${t.params.pagination.bulletClass}`) && n[0].click() }, notify(e) { const t = this.a11y.liveRegion; 0 !== t.length && (t.html(""), t.html(e)) }, updateNavigation() { const e = this; if (e.params.loop || !e.navigation) return; const { $nextEl: t, $prevEl: i } = e.navigation; i && i.length > 0 && (e.isBeginning ? e.a11y.disableEl(i) : e.a11y.enableEl(i)), t && t.length > 0 && (e.isEnd ? e.a11y.disableEl(t) : e.a11y.enableEl(t)) }, updatePagination() { const e = this, t = e.params.a11y; e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.bullets.each((i, n) => { const r = Ho(n); e.a11y.makeElFocusable(r), e.a11y.addElRole(r, "button"), e.a11y.addElLabel(r, t.paginationBulletMessage.replace(/\{\{index\}\}/, r.index() + 1)) }) }, init() { const e = this; e.$el.append(e.a11y.liveRegion); const t = e.params.a11y; let i, n; e.navigation && e.navigation.$nextEl && (i = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (n = e.navigation.$prevEl), i && (e.a11y.makeElFocusable(i), e.a11y.addElRole(i, "button"), e.a11y.addElLabel(i, t.nextSlideMessage), i.on("keydown", e.a11y.onEnterKey)), n && (e.a11y.makeElFocusable(n), e.a11y.addElRole(n, "button"), e.a11y.addElLabel(n, t.prevSlideMessage), n.on("keydown", e.a11y.onEnterKey)), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.on("keydown", `.${e.params.pagination.bulletClass}`, e.a11y.onEnterKey) }, destroy() { const e = this; let t, i; e.a11y.liveRegion && e.a11y.liveRegion.length > 0 && e.a11y.liveRegion.remove(), e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (i = e.navigation.$prevEl), t && t.off("keydown", e.a11y.onEnterKey), i && i.off("keydown", e.a11y.onEnterKey), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.off("keydown", `.${e.params.pagination.bulletClass}`, e.a11y.onEnterKey) } }; const kl = { init() { const e = this; if (!e.params.history) return; if (!Go.history || !Go.history.pushState) return e.params.history.enabled = !1, void (e.params.hashNavigation.enabled = !0); const t = e.history; t.initialized = !0, t.paths = kl.getPathValues(), (t.paths.key || t.paths.value) && (t.scrollToSlide(0, t.paths.value, e.params.runCallbacksOnInit), e.params.history.replaceState || Go.addEventListener("popstate", e.history.setHistoryPopState)) }, destroy() { const e = this; e.params.history.replaceState || Go.removeEventListener("popstate", e.history.setHistoryPopState) }, setHistoryPopState() { this.history.paths = kl.getPathValues(), this.history.scrollToSlide(this.params.speed, this.history.paths.value, !1) }, getPathValues() { const e = Go.location.pathname.slice(1).split("/").filter(e => "" !== e), t = e.length; return { key: e[t - 2], value: e[t - 1] } }, setHistory(e, t) { if (!this.history.initialized || !this.params.history.enabled) return; const i = this.slides.eq(t); let n = kl.slugify(i.attr("data-history")); Go.location.pathname.includes(e) || (n = `${e}/${n}`); const r = Go.history.state; r && r.value === n || (this.params.history.replaceState ? Go.history.replaceState({ value: n }, null, n) : Go.history.pushState({ value: n }, null, n)) }, slugify: e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), scrollToSlide(e, t, i) { const n = this; if (t) for (let r = 0, a = n.slides.length; r < a; r += 1) { const a = n.slides.eq(r); if (kl.slugify(a.attr("data-history")) === t && !a.hasClass(n.params.slideDuplicateClass)) { const t = a.index(); n.slideTo(t, e, i) } } else n.slideTo(0, e, i) } }; const Dl = { onHashCange() { const e = this, t = Fo.location.hash.replace("#", ""); if (t !== e.slides.eq(e.activeIndex).attr("data-hash")) { const i = e.$wrapperEl.children(`.${e.params.slideClass}[data-hash="${t}"]`).index(); if (void 0 === i) return; e.slideTo(i) } }, setHash() { const e = this; if (e.hashNavigation.initialized && e.params.hashNavigation.enabled) if (e.params.hashNavigation.replaceState && Go.history && Go.history.replaceState) Go.history.replaceState(null, null, `#${e.slides.eq(e.activeIndex).attr("data-hash")}` || ""); else { const t = e.slides.eq(e.activeIndex), i = t.attr("data-hash") || t.attr("data-history"); Fo.location.hash = i || "" } }, init() { const e = this; if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return; e.hashNavigation.initialized = !0; const t = Fo.location.hash.replace("#", ""); if (t) { const i = 0; for (let n = 0, r = e.slides.length; n < r; n += 1) { const r = e.slides.eq(n); if ((r.attr("data-hash") || r.attr("data-history")) === t && !r.hasClass(e.params.slideDuplicateClass)) { const t = r.index(); e.slideTo(t, i, e.params.runCallbacksOnInit, !0) } } } e.params.hashNavigation.watchState && Ho(Go).on("hashchange", e.hashNavigation.onHashCange) }, destroy() { const e = this; e.params.hashNavigation.watchState && Ho(Go).off("hashchange", e.hashNavigation.onHashCange) } }; const zl = { run() { const e = this, t = e.slides.eq(e.activeIndex); let i = e.params.autoplay.delay; t.attr("data-swiper-autoplay") && (i = t.attr("data-swiper-autoplay") || e.params.autoplay.delay), clearTimeout(e.autoplay.timeout), e.autoplay.timeout = Wo.nextTick(() => { e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), e.slidePrev(e.params.speed, !0, !0), e.emit("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), e.emit("autoplay")) : (e.slidePrev(e.params.speed, !0, !0), e.emit("autoplay")) : e.params.loop ? (e.loopFix(), e.slideNext(e.params.speed, !0, !0), e.emit("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(0, e.params.speed, !0, !0), e.emit("autoplay")) : (e.slideNext(e.params.speed, !0, !0), e.emit("autoplay")), e.params.cssMode && e.autoplay.running && e.autoplay.run() }, i) }, start() { return void 0 === this.autoplay.timeout && (!this.autoplay.running && (this.autoplay.running = !0, this.emit("autoplayStart"), this.autoplay.run(), !0)) }, stop() { const e = this; return !!e.autoplay.running && (void 0 !== e.autoplay.timeout && (e.autoplay.timeout && (clearTimeout(e.autoplay.timeout), e.autoplay.timeout = void 0), e.autoplay.running = !1, e.emit("autoplayStop"), !0)) }, pause(e) { const t = this; t.autoplay.running && (t.autoplay.paused || (t.autoplay.timeout && clearTimeout(t.autoplay.timeout), t.autoplay.paused = !0, 0 !== e && t.params.autoplay.waitForTransition ? (t.$wrapperEl[0].addEventListener("transitionend", t.autoplay.onTransitionEnd), t.$wrapperEl[0].addEventListener("webkitTransitionEnd", t.autoplay.onTransitionEnd)) : (t.autoplay.paused = !1, t.autoplay.run()))) } }; const Nl = { setTranslate() { const e = this, { slides: t } = e; for (let i = 0; i < t.length; i += 1) { const t = e.slides.eq(i); let n = -t[0].swiperSlideOffset; e.params.virtualTranslate || (n -= e.translate); let r = 0; e.isHorizontal() || (r = n, n = 0); const a = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(t[0].progress), 0) : 1 + Math.min(Math.max(t[0].progress, -1), 0); t.css({ opacity: a }).transform(`translate3d(${n}px, ${r}px, 0px)`) } }, setTransition(e) { const t = this, { slides: i, $wrapperEl: n } = t; if (i.transition(e), t.params.virtualTranslate && 0 !== e) { let e = !1; i.transitionEnd(() => { if (e) return; if (!t || t.destroyed) return; e = !0, t.animating = !1; const i = ["webkitTransitionEnd", "transitionend"]; for (let e = 0; e < i.length; e += 1)n.trigger(i[e]) }) } } }; const Bl = { setTranslate() { const { $el: e, $wrapperEl: t, slides: i, width: n, height: r, rtlTranslate: a, size: s } = this, o = this.params.cubeEffect, l = this.isHorizontal(), c = this.virtual && this.params.virtual.enabled; let h, u = 0; o.shadow && (l ? (h = t.find(".swiper-cube-shadow"), 0 === h.length && (h = Ho('<div class="swiper-cube-shadow"></div>'), t.append(h)), h.css({ height: `${n}px` })) : (h = e.find(".swiper-cube-shadow"), 0 === h.length && (h = Ho('<div class="swiper-cube-shadow"></div>'), e.append(h)))); for (let e = 0; e < i.length; e += 1) { const t = i.eq(e); let n = e; c && (n = parseInt(t.attr("data-swiper-slide-index"), 10)); let r = 90 * n, h = Math.floor(r / 360); a && (r = -r, h = Math.floor(-r / 360)); const d = Math.max(Math.min(t[0].progress, 1), -1); let p = 0, f = 0, m = 0; n % 4 == 0 ? (p = 4 * -h * s, m = 0) : (n - 1) % 4 == 0 ? (p = 0, m = 4 * -h * s) : (n - 2) % 4 == 0 ? (p = s + 4 * h * s, m = s) : (n - 3) % 4 == 0 && (p = -s, m = 3 * s + 4 * s * h), a && (p = -p), l || (f = p, p = 0); const g = `rotateX(${l ? 0 : -r}deg) rotateY(${l ? r : 0}deg) translate3d(${p}px, ${f}px, ${m}px)`; if (d <= 1 && d > -1 && (u = 90 * n + 90 * d, a && (u = 90 * -n - 90 * d)), t.transform(g), o.slideShadows) { let e = l ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"), i = l ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom"); 0 === e.length && (e = Ho(`<div class="swiper-slide-shadow-${l ? "left" : "top"}"></div>`), t.append(e)), 0 === i.length && (i = Ho(`<div class="swiper-slide-shadow-${l ? "right" : "bottom"}"></div>`), t.append(i)), e.length && (e[0].style.opacity = Math.max(-d, 0)), i.length && (i[0].style.opacity = Math.max(d, 0)) } } if (t.css({ "-webkit-transform-origin": `50% 50% -${s / 2}px`, "-moz-transform-origin": `50% 50% -${s / 2}px`, "-ms-transform-origin": `50% 50% -${s / 2}px`, "transform-origin": `50% 50% -${s / 2}px` }), o.shadow) if (l) h.transform(`translate3d(0px, ${n / 2 + o.shadowOffset}px, ${-n / 2}px) rotateX(90deg) rotateZ(0deg) scale(${o.shadowScale})`); else { const e = Math.abs(u) - 90 * Math.floor(Math.abs(u) / 90), t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2), i = o.shadowScale, n = o.shadowScale / t, a = o.shadowOffset; h.transform(`scale3d(${i}, 1, ${n}) translate3d(0px, ${r / 2 + a}px, ${-r / 2 / n}px) rotateX(-90deg)`) } const d = gl.isSafari || gl.isUiWebView ? -s / 2 : 0; t.transform(`translate3d(0px,0,${d}px) rotateX(${this.isHorizontal() ? 0 : u}deg) rotateY(${this.isHorizontal() ? -u : 0}deg)`) }, setTransition(e) { const { $el: t, slides: i } = this; i.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), this.params.cubeEffect.shadow && !this.isHorizontal() && t.find(".swiper-cube-shadow").transition(e) } }; const Fl = { setTranslate() { const e = this, { slides: t, rtlTranslate: i } = e; for (let n = 0; n < t.length; n += 1) { const r = t.eq(n); let a = r[0].progress; e.params.flipEffect.limitRotation && (a = Math.max(Math.min(r[0].progress, 1), -1)); let s = -180 * a, o = 0, l = -r[0].swiperSlideOffset, c = 0; if (e.isHorizontal() ? i && (s = -s) : (c = l, l = 0, o = -s, s = 0), r[0].style.zIndex = -Math.abs(Math.round(a)) + t.length, e.params.flipEffect.slideShadows) { let t = e.isHorizontal() ? r.find(".swiper-slide-shadow-left") : r.find(".swiper-slide-shadow-top"), i = e.isHorizontal() ? r.find(".swiper-slide-shadow-right") : r.find(".swiper-slide-shadow-bottom"); 0 === t.length && (t = Ho(`<div class="swiper-slide-shadow-${e.isHorizontal() ? "left" : "top"}"></div>`), r.append(t)), 0 === i.length && (i = Ho(`<div class="swiper-slide-shadow-${e.isHorizontal() ? "right" : "bottom"}"></div>`), r.append(i)), t.length && (t[0].style.opacity = Math.max(-a, 0)), i.length && (i[0].style.opacity = Math.max(a, 0)) } r.transform(`translate3d(${l}px, ${c}px, 0px) rotateX(${o}deg) rotateY(${s}deg)`) } }, setTransition(e) { const t = this, { slides: i, activeIndex: n, $wrapperEl: r } = t; if (i.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), t.params.virtualTranslate && 0 !== e) { let e = !1; i.eq(n).transitionEnd((function () { if (e) return; if (!t || t.destroyed) return; e = !0, t.animating = !1; const i = ["webkitTransitionEnd", "transitionend"]; for (let e = 0; e < i.length; e += 1)r.trigger(i[e]) })) } } }; const Gl = { setTranslate() { const { width: e, height: t, slides: i, $wrapperEl: n, slidesSizesGrid: r } = this, a = this.params.coverflowEffect, s = this.isHorizontal(), o = this.translate, l = s ? e / 2 - o : t / 2 - o, c = s ? a.rotate : -a.rotate, h = a.depth; for (let e = 0, t = i.length; e < t; e += 1) { const t = i.eq(e), n = r[e], o = (l - t[0].swiperSlideOffset - n / 2) / n * a.modifier; let u = s ? c * o : 0, d = s ? 0 : c * o, p = -h * Math.abs(o), f = a.stretch; "string" == typeof f && -1 !== f.indexOf("%") && (f = parseFloat(a.stretch) / 100 * n); let m = s ? 0 : f * o, g = s ? f * o : 0; Math.abs(g) < .001 && (g = 0), Math.abs(m) < .001 && (m = 0), Math.abs(p) < .001 && (p = 0), Math.abs(u) < .001 && (u = 0), Math.abs(d) < .001 && (d = 0); const v = `translate3d(${g}px,${m}px,${p}px)  rotateX(${d}deg) rotateY(${u}deg)`; if (t.transform(v), t[0].style.zIndex = 1 - Math.abs(Math.round(o)), a.slideShadows) { let e = s ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"), i = s ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom"); 0 === e.length && (e = Ho(`<div class="swiper-slide-shadow-${s ? "left" : "top"}"></div>`), t.append(e)), 0 === i.length && (i = Ho(`<div class="swiper-slide-shadow-${s ? "right" : "bottom"}"></div>`), t.append(i)), e.length && (e[0].style.opacity = o > 0 ? o : 0), i.length && (i[0].style.opacity = -o > 0 ? -o : 0) } } if ($o.pointerEvents || $o.prefixedPointerEvents) { n[0].style.perspectiveOrigin = `${l}px 50%` } }, setTransition(e) { this.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e) } }; const Ul = { init() { const e = this, { thumbs: t } = e.params, i = e.constructor; t.swiper instanceof i ? (e.thumbs.swiper = t.swiper, Wo.extend(e.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Wo.extend(e.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 })) : Wo.isObject(t.swiper) && (e.thumbs.swiper = new i(Wo.extend({}, t.swiper, { watchSlidesVisibility: !0, watchSlidesProgress: !0, slideToClickedSlide: !1 })), e.thumbs.swiperCreated = !0), e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", e.thumbs.onThumbClick) }, onThumbClick() { const e = this, t = e.thumbs.swiper; if (!t) return; const i = t.clickedIndex, n = t.clickedSlide; if (n && Ho(n).hasClass(e.params.thumbs.slideThumbActiveClass)) return; if (null == i) return; let r; if (r = t.params.loop ? parseInt(Ho(t.clickedSlide).attr("data-swiper-slide-index"), 10) : i, e.params.loop) { let t = e.activeIndex; e.slides.eq(t).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, t = e.activeIndex); const i = e.slides.eq(t).prevAll(`[data-swiper-slide-index="${r}"]`).eq(0).index(), n = e.slides.eq(t).nextAll(`[data-swiper-slide-index="${r}"]`).eq(0).index(); r = void 0 === i ? n : void 0 === n ? i : n - t < t - i ? n : i } e.slideTo(r) }, update(e) { const t = this, i = t.thumbs.swiper; if (!i) return; const n = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView, r = t.params.thumbs.autoScrollOffset, a = r && !i.params.loop; if (t.realIndex !== i.realIndex || a) { let s, o, l = i.activeIndex; if (i.params.loop) { i.slides.eq(l).hasClass(i.params.slideDuplicateClass) && (i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft, l = i.activeIndex); const e = i.slides.eq(l).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(), n = i.slides.eq(l).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(); s = void 0 === e ? n : void 0 === n ? e : n - l == l - e ? l : n - l < l - e ? n : e, o = t.activeIndex > t.previousIndex ? "next" : "prev" } else s = t.realIndex, o = s > t.previousIndex ? "next" : "prev"; a && (s += "next" === o ? r : -1 * r), i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(s) < 0 && (i.params.centeredSlides ? s = s > l ? s - Math.floor(n / 2) + 1 : s + Math.floor(n / 2) - 1 : s > l && (s = s - n + 1), i.slideTo(s, e ? 0 : void 0)) } let s = 1; const o = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (s = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (s = 1), s = Math.floor(s), i.slides.removeClass(o), i.params.loop || i.params.virtual && i.params.virtual.enabled) for (let e = 0; e < s; e += 1)i.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex + e}"]`).addClass(o); else for (let e = 0; e < s; e += 1)i.slides.eq(t.realIndex + e).addClass(o) } }; const Hl = [fl, ml, vl, yl, xl, wl, Ml, { name: "mousewheel", params: { mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarged: "container" } }, create() { Wo.extend(this, { mousewheel: { enabled: !1, enable: Sl.enable.bind(this), disable: Sl.disable.bind(this), handle: Sl.handle.bind(this), handleMouseEnter: Sl.handleMouseEnter.bind(this), handleMouseLeave: Sl.handleMouseLeave.bind(this), animateSlider: Sl.animateSlider.bind(this), releaseScroll: Sl.releaseScroll.bind(this), lastScrollTime: Wo.now(), lastEventBeforeSnap: void 0, recentWheelEvents: [] } }) }, on: { init() { const e = this; !e.params.mousewheel.enabled && e.params.cssMode && e.mousewheel.disable(), e.params.mousewheel.enabled && e.mousewheel.enable() }, destroy() { const e = this; e.params.cssMode && e.mousewheel.enable(), e.mousewheel.enabled && e.mousewheel.disable() } } }, { name: "navigation", params: { navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock" } }, create() { Wo.extend(this, { navigation: { init: El.init.bind(this), update: El.update.bind(this), destroy: El.destroy.bind(this), onNextClick: El.onNextClick.bind(this), onPrevClick: El.onPrevClick.bind(this) } }) }, on: { init() { this.navigation.init(), this.navigation.update() }, toEdge() { this.navigation.update() }, fromEdge() { this.navigation.update() }, destroy() { this.navigation.destroy() }, click(e) { const t = this, { $nextEl: i, $prevEl: n } = t.navigation; if (t.params.navigation.hideOnClick && !Ho(e.target).is(n) && !Ho(e.target).is(i)) { let e; i ? e = i.hasClass(t.params.navigation.hiddenClass) : n && (e = n.hasClass(t.params.navigation.hiddenClass)), !0 === e ? t.emit("navigationShow", t) : t.emit("navigationHide", t), i && i.toggleClass(t.params.navigation.hiddenClass), n && n.toggleClass(t.params.navigation.hiddenClass) } } } }, { name: "pagination", params: { pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: e => e, formatFractionTotal: e => e, bulletClass: "swiper-pagination-bullet", bulletActiveClass: "swiper-pagination-bullet-active", modifierClass: "swiper-pagination-", currentClass: "swiper-pagination-current", totalClass: "swiper-pagination-total", hiddenClass: "swiper-pagination-hidden", progressbarFillClass: "swiper-pagination-progressbar-fill", progressbarOppositeClass: "swiper-pagination-progressbar-opposite", clickableClass: "swiper-pagination-clickable", lockClass: "swiper-pagination-lock" } }, create() { Wo.extend(this, { pagination: { init: Cl.init.bind(this), render: Cl.render.bind(this), update: Cl.update.bind(this), destroy: Cl.destroy.bind(this), dynamicBulletIndex: 0 } }) }, on: { init() { this.pagination.init(), this.pagination.render(), this.pagination.update() }, activeIndexChange() { const e = this; (e.params.loop || void 0 === e.snapIndex) && e.pagination.update() }, snapIndexChange() { const e = this; e.params.loop || e.pagination.update() }, slidesLengthChange() { const e = this; e.params.loop && (e.pagination.render(), e.pagination.update()) }, snapGridLengthChange() { const e = this; e.params.loop || (e.pagination.render(), e.pagination.update()) }, destroy() { this.pagination.destroy() }, click(e) { const t = this; if (t.params.pagination.el && t.params.pagination.hideOnClick && t.pagination.$el.length > 0 && !Ho(e.target).hasClass(t.params.pagination.bulletClass)) { !0 === t.pagination.$el.hasClass(t.params.pagination.hiddenClass) ? t.emit("paginationShow", t) : t.emit("paginationHide", t), t.pagination.$el.toggleClass(t.params.pagination.hiddenClass) } } } }, { name: "scrollbar", params: { scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag" } }, create() { Wo.extend(this, { scrollbar: { init: Al.init.bind(this), destroy: Al.destroy.bind(this), updateSize: Al.updateSize.bind(this), setTranslate: Al.setTranslate.bind(this), setTransition: Al.setTransition.bind(this), enableDraggable: Al.enableDraggable.bind(this), disableDraggable: Al.disableDraggable.bind(this), setDragPosition: Al.setDragPosition.bind(this), getPointerPosition: Al.getPointerPosition.bind(this), onDragStart: Al.onDragStart.bind(this), onDragMove: Al.onDragMove.bind(this), onDragEnd: Al.onDragEnd.bind(this), isTouched: !1, timeout: null, dragTimeout: null } }) }, on: { init() { this.scrollbar.init(), this.scrollbar.updateSize(), this.scrollbar.setTranslate() }, update() { this.scrollbar.updateSize() }, resize() { this.scrollbar.updateSize() }, observerUpdate() { this.scrollbar.updateSize() }, setTranslate() { this.scrollbar.setTranslate() }, setTransition(e) { this.scrollbar.setTransition(e) }, destroy() { this.scrollbar.destroy() } } }, { name: "parallax", params: { parallax: { enabled: !1 } }, create() { Wo.extend(this, { parallax: { setTransform: Pl.setTransform.bind(this), setTranslate: Pl.setTranslate.bind(this), setTransition: Pl.setTransition.bind(this) } }) }, on: { beforeInit() { this.params.parallax.enabled && (this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0) }, init() { this.params.parallax.enabled && this.parallax.setTranslate() }, setTranslate() { this.params.parallax.enabled && this.parallax.setTranslate() }, setTransition(e) { this.params.parallax.enabled && this.parallax.setTransition(e) } } }, { name: "zoom", params: { zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }, create() { const e = this, t = { enabled: !1, scale: 1, currentScale: 1, isScaling: !1, gesture: { $slideEl: void 0, slideWidth: void 0, slideHeight: void 0, $imageEl: void 0, $imageWrapEl: void 0, maxRatio: 3 }, image: { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, velocity: { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 } }; "onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out".split(" ").forEach(i => { t[i] = Ll[i].bind(e) }), Wo.extend(e, { zoom: t }); let i = 1; Object.defineProperty(e.zoom, "scale", { get: () => i, set(t) { if (i !== t) { const i = e.zoom.gesture.$imageEl ? e.zoom.gesture.$imageEl[0] : void 0, n = e.zoom.gesture.$slideEl ? e.zoom.gesture.$slideEl[0] : void 0; e.emit("zoomChange", t, i, n) } i = t } }) }, on: { init() { const e = this; e.params.zoom.enabled && e.zoom.enable() }, destroy() { this.zoom.disable() }, touchStart(e) { this.zoom.enabled && this.zoom.onTouchStart(e) }, touchEnd(e) { this.zoom.enabled && this.zoom.onTouchEnd(e) }, doubleTap(e) { const t = this; t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && t.zoom.toggle(e) }, transitionEnd() { const e = this; e.zoom.enabled && e.params.zoom.enabled && e.zoom.onTransitionEnd() }, slideChange() { const e = this; e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && e.zoom.onTransitionEnd() } } }, { name: "lazy", params: { lazy: { enabled: !1, loadPrevNext: !1, loadPrevNextAmount: 1, loadOnTransitionStart: !1, elementClass: "swiper-lazy", loadingClass: "swiper-lazy-loading", loadedClass: "swiper-lazy-loaded", preloaderClass: "swiper-lazy-preloader" } }, create() { Wo.extend(this, { lazy: { initialImageLoaded: !1, load: Rl.load.bind(this), loadInSlide: Rl.loadInSlide.bind(this) } }) }, on: { beforeInit() { const e = this; e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1) }, init() { const e = this; e.params.lazy.enabled && !e.params.loop && 0 === e.params.initialSlide && e.lazy.load() }, scroll() { const e = this; e.params.freeMode && !e.params.freeModeSticky && e.lazy.load() }, resize() { const e = this; e.params.lazy.enabled && e.lazy.load() }, scrollbarDragMove() { const e = this; e.params.lazy.enabled && e.lazy.load() }, transitionStart() { const e = this; e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !e.lazy.initialImageLoaded) && e.lazy.load() }, transitionEnd() { const e = this; e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && e.lazy.load() }, slideChange() { const e = this; e.params.lazy.enabled && e.params.cssMode && e.lazy.load() } } }, { name: "controller", params: { controller: { control: void 0, inverse: !1, by: "slide" } }, create() { Wo.extend(this, { controller: { control: this.params.controller.control, getInterpolateFunction: Ol.getInterpolateFunction.bind(this), setTranslate: Ol.setTranslate.bind(this), setTransition: Ol.setTransition.bind(this) } }) }, on: { update() { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, resize() { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, observerUpdate() { const e = this; e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) }, setTranslate(e, t) { this.controller.control && this.controller.setTranslate(e, t) }, setTransition(e, t) { this.controller.control && this.controller.setTransition(e, t) } } }, { name: "a11y", params: { a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}" } }, create() { const e = this; Wo.extend(e, { a11y: { liveRegion: Ho(`<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`) } }), Object.keys(Il).forEach(t => { e.a11y[t] = Il[t].bind(e) }) }, on: { init() { this.params.a11y.enabled && (this.a11y.init(), this.a11y.updateNavigation()) }, toEdge() { this.params.a11y.enabled && this.a11y.updateNavigation() }, fromEdge() { this.params.a11y.enabled && this.a11y.updateNavigation() }, paginationUpdate() { this.params.a11y.enabled && this.a11y.updatePagination() }, destroy() { this.params.a11y.enabled && this.a11y.destroy() } } }, { name: "history", params: { history: { enabled: !1, replaceState: !1, key: "slides" } }, create() { Wo.extend(this, { history: { init: kl.init.bind(this), setHistory: kl.setHistory.bind(this), setHistoryPopState: kl.setHistoryPopState.bind(this), scrollToSlide: kl.scrollToSlide.bind(this), destroy: kl.destroy.bind(this) } }) }, on: { init() { const e = this; e.params.history.enabled && e.history.init() }, destroy() { const e = this; e.params.history.enabled && e.history.destroy() }, transitionEnd() { const e = this; e.history.initialized && e.history.setHistory(e.params.history.key, e.activeIndex) }, slideChange() { const e = this; e.history.initialized && e.params.cssMode && e.history.setHistory(e.params.history.key, e.activeIndex) } } }, { name: "hash-navigation", params: { hashNavigation: { enabled: !1, replaceState: !1, watchState: !1 } }, create() { Wo.extend(this, { hashNavigation: { initialized: !1, init: Dl.init.bind(this), destroy: Dl.destroy.bind(this), setHash: Dl.setHash.bind(this), onHashCange: Dl.onHashCange.bind(this) } }) }, on: { init() { const e = this; e.params.hashNavigation.enabled && e.hashNavigation.init() }, destroy() { const e = this; e.params.hashNavigation.enabled && e.hashNavigation.destroy() }, transitionEnd() { const e = this; e.hashNavigation.initialized && e.hashNavigation.setHash() }, slideChange() { const e = this; e.hashNavigation.initialized && e.params.cssMode && e.hashNavigation.setHash() } } }, { name: "autoplay", params: { autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1 } }, create() { const e = this; Wo.extend(e, { autoplay: { running: !1, paused: !1, run: zl.run.bind(e), start: zl.start.bind(e), stop: zl.stop.bind(e), pause: zl.pause.bind(e), onVisibilityChange() { "hidden" === document.visibilityState && e.autoplay.running && e.autoplay.pause(), "visible" === document.visibilityState && e.autoplay.paused && (e.autoplay.run(), e.autoplay.paused = !1) }, onTransitionEnd(t) { e && !e.destroyed && e.$wrapperEl && t.target === this && (e.$wrapperEl[0].removeEventListener("transitionend", e.autoplay.onTransitionEnd), e.$wrapperEl[0].removeEventListener("webkitTransitionEnd", e.autoplay.onTransitionEnd), e.autoplay.paused = !1, e.autoplay.running ? e.autoplay.run() : e.autoplay.stop()) } } }) }, on: { init() { const e = this; e.params.autoplay.enabled && (e.autoplay.start(), document.addEventListener("visibilitychange", e.autoplay.onVisibilityChange)) }, beforeTransitionStart(e, t) { const i = this; i.autoplay.running && (t || !i.params.autoplay.disableOnInteraction ? i.autoplay.pause(e) : i.autoplay.stop()) }, sliderFirstMove() { const e = this; e.autoplay.running && (e.params.autoplay.disableOnInteraction ? e.autoplay.stop() : e.autoplay.pause()) }, touchEnd() { const e = this; e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && e.autoplay.run() }, destroy() { const e = this; e.autoplay.running && e.autoplay.stop(), document.removeEventListener("visibilitychange", e.autoplay.onVisibilityChange) } } }, { name: "effect-fade", params: { fadeEffect: { crossFade: !1 } }, create() { Wo.extend(this, { fadeEffect: { setTranslate: Nl.setTranslate.bind(this), setTransition: Nl.setTransition.bind(this) } }) }, on: { beforeInit() { if ("fade" !== this.params.effect) return; this.classNames.push(`${this.params.containerModifierClass}fade`); const e = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0 }; Wo.extend(this.params, e), Wo.extend(this.originalParams, e) }, setTranslate() { "fade" === this.params.effect && this.fadeEffect.setTranslate() }, setTransition(e) { "fade" === this.params.effect && this.fadeEffect.setTransition(e) } } }, { name: "effect-cube", params: { cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }, create() { Wo.extend(this, { cubeEffect: { setTranslate: Bl.setTranslate.bind(this), setTransition: Bl.setTransition.bind(this) } }) }, on: { beforeInit() { if ("cube" !== this.params.effect) return; this.classNames.push(`${this.params.containerModifierClass}cube`), this.classNames.push(`${this.params.containerModifierClass}3d`); const e = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }; Wo.extend(this.params, e), Wo.extend(this.originalParams, e) }, setTranslate() { "cube" === this.params.effect && this.cubeEffect.setTranslate() }, setTransition(e) { "cube" === this.params.effect && this.cubeEffect.setTransition(e) } } }, { name: "effect-flip", params: { flipEffect: { slideShadows: !0, limitRotation: !0 } }, create() { Wo.extend(this, { flipEffect: { setTranslate: Fl.setTranslate.bind(this), setTransition: Fl.setTransition.bind(this) } }) }, on: { beforeInit() { if ("flip" !== this.params.effect) return; this.classNames.push(`${this.params.containerModifierClass}flip`), this.classNames.push(`${this.params.containerModifierClass}3d`); const e = { slidesPerView: 1, slidesPerColumn: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !0 }; Wo.extend(this.params, e), Wo.extend(this.originalParams, e) }, setTranslate() { "flip" === this.params.effect && this.flipEffect.setTranslate() }, setTransition(e) { "flip" === this.params.effect && this.flipEffect.setTransition(e) } } }, { name: "effect-coverflow", params: { coverflowEffect: { rotate: 50, stretch: 0, depth: 100, modifier: 1, slideShadows: !0 } }, create() { Wo.extend(this, { coverflowEffect: { setTranslate: Gl.setTranslate.bind(this), setTransition: Gl.setTransition.bind(this) } }) }, on: { beforeInit() { "coverflow" === this.params.effect && (this.classNames.push(`${this.params.containerModifierClass}coverflow`), this.classNames.push(`${this.params.containerModifierClass}3d`), this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0) }, setTranslate() { "coverflow" === this.params.effect && this.coverflowEffect.setTranslate() }, setTransition(e) { "coverflow" === this.params.effect && this.coverflowEffect.setTransition(e) } } }, { name: "thumbs", params: { thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-container-thumbs" } }, create() { Wo.extend(this, { thumbs: { swiper: null, init: Ul.init.bind(this), update: Ul.update.bind(this), onThumbClick: Ul.onThumbClick.bind(this) } }) }, on: { beforeInit() { const { thumbs: e } = this.params; e && e.swiper && (this.thumbs.init(), this.thumbs.update(!0)) }, slideChange() { this.thumbs.swiper && this.thumbs.update() }, update() { this.thumbs.swiper && this.thumbs.update() }, resize() { this.thumbs.swiper && this.thumbs.update() }, observerUpdate() { this.thumbs.swiper && this.thumbs.update() }, setTransition(e) { const t = this.thumbs.swiper; t && t.setTransition(e) }, beforeDestroy() { const e = this.thumbs.swiper; e && this.thumbs.swiperCreated && e && e.destroy() } } }]; void 0 === pl.use && (pl.use = pl.Class.use, pl.installModule = pl.Class.installModule), pl.use(Hl); var Vl = pl; i(6), i(7); let jl, Wl; console.log(Io); let $l = !1; const Xl = (e, t) => { let i = document.querySelector(".lnk" + e + " .dot"); t ? i.classList.add("active") : i.classList.remove("active") }, Yl = e => { tc() ? Jl("#projects h3.largeView") : Jl("#projects h3.mobView"); let t = 0, i = document.querySelectorAll("#projects h3"), n = e[0], r = e[1]; n.addEventListener("click", (function () { ql(e, "disabled"), t > 0 && (t -= 1, ql(i, "active"), i[t].classList.add("active")), t <= 0 && n.classList.add("disabled") })), r.addEventListener("click", (function () { ql(e, "disabled"), t < i.length - 1 && (t += 1, ql(i, "active"), i[t].classList.add("active")), t >= i.length - 1 && r.classList.add("disabled") })) }, ql = (e, t) => { e.forEach((function (i, n) { e[n].classList.remove(t) })) }, Jl = e => { document.querySelectorAll(e).forEach((function (e, t) { e.remove() })) }, Zl = (e, t) => { e.forEach((function (e) { t ? e.setAttribute("onclick", "return false") : e.removeAttribute("onclick") })) }; class Kl { constructor(e) { this.nose = e.getElementById("Nasp"), this.section = document.getElementsByTagName("main")[0], this.fellaCoord = Kl.fellaCoord(this.section, this.nose) } static fellaCoord(e, t) { const i = document.getElementById("logo").getBoundingClientRect(), n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), a = (window.innerWidth - n.width) / 2; let s = i.x + r.x + r.width; return { y: i.y + r.y + r.height - 18, x: s - a - 12 } } idFella() { let e = document.getElementById("matrix"), t = e.cloneNode(!0); this.latestId ? this.latestId++ : this.latestId = 1; let i = "fella" + this.latestId; return t.id = i, this.section.insertBefore(t, e), document.getElementById(i).style.top = this.fellaCoord.y, document.getElementById(i).style.left = this.fellaCoord.x, i } fellaCreation() { const e = this.idFella(); let t = { rx: Math.floor(140 * Math.random()) + 40, ry: Math.floor(5 * Math.random()) - 2 }, i = new zo.a({ delay: 1, ease: Eo.c.easeNone }), n = this.fellaMove(t, e); this.fellaDie(e); i.to(this.nose, .9, { rotation: 7, scale: .85 }).to(this.nose, .3, { rotation: -5, scale: 1.1 }).add((function () { Do.a.to("#" + e, 1, { x: t.rx, y: t.ry, opacity: 1, scale: 1, ease: Eo.c.easeNone, onComplete: function () { Do.a.set("#" + e, { x: t.rx, y: t.ry }), n.play() } }) })).to(this.nose, .3, { rotation: 0, scale: 1 }) } fellaMove(e, t) { Math.floor(e.rx / 2), Math.floor(e.ry / 2); let i = window.innerWidth < 800; const n = i ? 40 - this.section.clientWidth : -this.section.clientWidth / 2 + 20, r = i ? this.section.clientWidth - 50 : this.section.clientWidth / 2 - 200, a = i ? -10 : -50, s = i ? this.section.clientHeight : this.section.clientWidth / 2 - 200; let o = function (e, t) { return Math.floor(Math.random() * (t - e) + e) }, l = new zo.a({ yoyo: !1, ease: Eo.c.easeNone, repeat: -1, paused: !0 }); return l.to("#" + t, 20, { ease: Eo.c.easeNone, bezier: { values: [{ x: e.rx, y: e.ry }, { x: o(n, r), y: o(a, s) }, { x: o(n, r), y: o(a, s) }, { x: o(n, r), y: o(a, s) }, { x: o(n, r), y: o(a, s) }, { x: o(n, r), y: o(a, s) }, { x: o(n, r), y: o(a, s) }, { x: e.rx, y: e.ry }] } }), l } fellaDie(e) { let t = ["Paolo", "Martina", "Giulia", "Agostino", "Tommaso", "Giacomo", "Andrea", "Valerio"]; document.getElementById(e).addEventListener("click", (function () { tc() && navigator.vibrate(200), document.getElementById(e).remove(), console.log("Hai ucciso " + t[e.match(/\d/g)] + "!") })) } } const Ql = () => { const e = document.getElementById("slf").contentDocument; if (e) { $l = !0, ec(e), jl = e.querySelectorAll(".cls-10, .cls-11, .cls-12, .cls-13"); let t = 0, i = new Kl(e); setTimeout((function () { i.fellaCreation() }), 4e3); let n = setInterval((function () { t < 8 ? (i.fellaCreation(), t += 1) : clearInterval(n) }), 2e4) } }, ec = e => { const t = e.getElementById("Ala1"), i = e.getElementById("Ala2"); let n = 0, r = new zo.a({ delay: 1, repeat: -1, yoyo: !0, ease: Eo.c.easeNone, onRepeat: function () { n >= 25 ? (r.restart(!0), n = 0) : n++ } }); r.to(t, .05, { rotation: -9, transformOrigin: "100% 100%" }, 0), r.to(i, .05, { rotation: 9, transformOrigin: "bottom left" }, 0) }, tc = () => { let e = !1; var t; return t = navigator.userAgent || navigator.vendor || window.opera, (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0, 4))) && (e = !0), e }; function ic(e, t) { var i = e.__state.conversionName.toString(), n = Math.round(e.r), r = Math.round(e.g), a = Math.round(e.b), s = e.a, o = Math.round(e.h), l = e.s.toFixed(1), c = e.v.toFixed(1); if (t || "THREE_CHAR_HEX" === i || "SIX_CHAR_HEX" === i) { for (var h = e.hex.toString(16); h.length < 6;)h = "0" + h; return "#" + h } return "CSS_RGB" === i ? "rgb(" + n + "," + r + "," + a + ")" : "CSS_RGBA" === i ? "rgba(" + n + "," + r + "," + a + "," + s + ")" : "HEX" === i ? "0x" + e.hex.toString(16) : "RGB_ARRAY" === i ? "[" + n + "," + r + "," + a + "]" : "RGBA_ARRAY" === i ? "[" + n + "," + r + "," + a + "," + s + "]" : "RGB_OBJ" === i ? "{r:" + n + ",g:" + r + ",b:" + a + "}" : "RGBA_OBJ" === i ? "{r:" + n + ",g:" + r + ",b:" + a + ",a:" + s + "}" : "HSV_OBJ" === i ? "{h:" + o + ",s:" + l + ",v:" + c + "}" : "HSVA_OBJ" === i ? "{h:" + o + ",s:" + l + ",v:" + c + ",a:" + s + "}" : "unknown format" } tc() ? (() => { Zl(document.querySelectorAll("a"), !0), document.querySelector("#content .sunset.fRight").remove(); let e = new Vl("#content", { loop: !1, setWrapperSize: !0, fadeEffect: { crossFade: !0 }, effect: "fade" }); e.on("slideChange", (function () { Zl(document.querySelectorAll("a"), !0); for (let t = 0; t < e.slides.length; t++)e.slides[t].style.zIndex = 1; e.slides[e.realIndex].style.zIndex = 2, 4 == e.activeIndex ? (e.allowSlideNext = !1, Zl(document.querySelectorAll(".night a"), !1)) : e.allowSlideNext = !0, 2 == e.activeIndex && Zl(document.querySelectorAll(".sunset a"), !1), 0 == e.activeIndex ? document.getElementById("swipe").classList.remove("swiped") : document.getElementById("swipe").classList.add("swiped"), $l || (Ql(), document.getElementById("swipe").classList.add("swiped"), $l = !0) })); const t = document.querySelectorAll("#arrows .arrow"); Yl(t) })() : (() => { Zl(document.querySelectorAll("a"), !0); let e = new Bo.a.Controller({ loglevel: -1 }); const t = Math.round(document.body.scrollHeight / 3) - 300, i = Math.round(t / 6); e.scrollTo((function (e, t) { Do.a.to(window, e, { scrollTo: { y: t }, ease: Eo.c.easeNone }) })); let n = Do.a.to(".morning.fLeft span", 1, { marginLeft: 0, opacity: 1 }), r = Do.a.to(".morning.fRight span", 1, { marginRight: 0, opacity: 1 }), a = Do.a.to(".morning", 1, { scale: 1.1, opacity: 0 }), s = Do.a.to(".sunset.fRight span", 1, { marginRight: 0, opacity: 1, scale: 1 }), o = Do.a.to(".sunset.fLeft", 1, { scale: 1, opacity: 1 }), l = Do.a.to(".sunset", 1, { scale: 1.1, opacity: 0 }), c = Do.a.to(".night.fLeft span", 1, { marginLeft: 0, opacity: 1, scale: 1 }), h = Do.a.to(".night.fRight span, .night.fRight p", 1, { marginRight: 0, marginTop: 0, opacity: 1 }), u = 1.5, d = 4, p = new Bo.a.Scene({ duration: t, offset: 100 }).on("enter", (function (e) { Xl("Morning", !0), document.getElementById("scroll").classList.add("scrolled"), u = 1.5, d = 4 })).on("leave", (function (e) { "REVERSE" == e.scrollDirection ? document.getElementById("scroll").classList.remove("scrolled") : $l || (Ql(), $l = !0), Xl("Morning", !1) })).addTo(e), f = (new Bo.a.Scene({ duration: i / 2, offset: 0 }).setTween(n).addTo(e), new Bo.a.Scene({ duration: i / 2, offset: 2 * i + 100 }).setTween(r).addTo(e)), m = (new Bo.a.Scene({ duration: i / 2, offset: 5 * i }).setTween(a).addTo(e), new Bo.a.Scene({ duration: t, offset: t + 100 }).on("enter", (function (e) { Xl("Sunset", !0), u = 2.5, d = 3.5, Zl(document.querySelectorAll(".sunset a"), !1) })).on("leave", (function (e) { Xl("Sunset", !1), Zl(document.querySelectorAll(".sunset a"), !0) })).addTo(e)), g = (new Bo.a.Scene({ duration: i / 2, offset: t + 100 }).setTween(s).addTo(e), new Bo.a.Scene({ duration: i / 2, offset: t + i + 100 }).setTween(o).addTo(e)); new Bo.a.Scene({ duration: i / 2, offset: t + 5 * i }).setTween(l).addTo(e); const v = document.querySelectorAll("#arrows .arrow"); Yl(v); let y = new Bo.a.Scene({ duration: t, offset: 2 * t + 100 }).on("enter", (function (e) { Xl("Night", !0), u = 4, d = 1.5, Zl(document.querySelectorAll(".night a"), !1), null != jl && Do.a.to(jl, .4, { fill: "#fff", opacity: .3 }) })).on("leave", (function (e) { Xl("Night", !1), Zl(document.querySelectorAll(".night a"), !0), Do.a.to(jl, .4, { fill: "#333", opacity: .5 }) })).addTo(e); new Bo.a.Scene({ duration: i / 2, offset: 2 * t + 100 }).setTween(c).addTo(e), new Bo.a.Scene({ duration: i / 2, offset: 2 * t + 2 * i }).setTween(h).addTo(e); document.querySelector(".lnkMorning .dot").addEventListener("click", (function () { e.scrollTo(u, f.duration() + f.offset()) })), document.querySelector(".lnkSunset .dot").addEventListener("click", (function () { e.scrollTo(2.5, g.duration() + g.offset()) })), document.querySelector(".lnkNight .dot").addEventListener("click", (function () { e.scrollTo(d, y.duration() + y.offset()) })), Wl = { morning: p, sunset: m, night: y } })(); var nc = Array.prototype.forEach, rc = Array.prototype.slice, ac = { BREAK: {}, extend: function (e) { return this.each(rc.call(arguments, 1), (function (t) { (this.isObject(t) ? Object.keys(t) : []).forEach(function (i) { this.isUndefined(t[i]) || (e[i] = t[i]) }.bind(this)) }), this), e }, defaults: function (e) { return this.each(rc.call(arguments, 1), (function (t) { (this.isObject(t) ? Object.keys(t) : []).forEach(function (i) { this.isUndefined(e[i]) && (e[i] = t[i]) }.bind(this)) }), this), e }, compose: function () { var e = rc.call(arguments); return function () { for (var t = rc.call(arguments), i = e.length - 1; i >= 0; i--)t = [e[i].apply(this, t)]; return t[0] } }, each: function (e, t, i) { if (e) if (nc && e.forEach && e.forEach === nc) e.forEach(t, i); else if (e.length === e.length + 0) { var n, r = void 0; for (r = 0, n = e.length; r < n; r++)if (r in e && t.call(i, e[r], r) === this.BREAK) return } else for (var a in e) if (t.call(i, e[a], a) === this.BREAK) return }, defer: function (e) { setTimeout(e, 0) }, debounce: function (e, t, i) { var n = void 0; return function () { var r = this, a = arguments; function s() { n = null, i || e.apply(r, a) } var o = i || !n; clearTimeout(n), n = setTimeout(s, t), o && e.apply(r, a) } }, toArray: function (e) { return e.toArray ? e.toArray() : rc.call(e) }, isUndefined: function (e) { return void 0 === e }, isNull: function (e) { return null === e }, isNaN: function (e) { function t(t) { return e.apply(this, arguments) } return t.toString = function () { return e.toString() }, t }((function (e) { return isNaN(e) })), isArray: Array.isArray || function (e) { return e.constructor === Array }, isObject: function (e) { return e === Object(e) }, isNumber: function (e) { return e === e + 0 }, isString: function (e) { return e === e + "" }, isBoolean: function (e) { return !1 === e || !0 === e }, isFunction: function (e) { return e instanceof Function } }, sc = [{ litmus: ac.isString, conversions: { THREE_CHAR_HEX: { read: function (e) { var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i); return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString() + t[1].toString() + t[2].toString() + t[2].toString() + t[3].toString() + t[3].toString(), 0) } }, write: ic }, SIX_CHAR_HEX: { read: function (e) { var t = e.match(/^#([A-F0-9]{6})$/i); return null !== t && { space: "HEX", hex: parseInt("0x" + t[1].toString(), 0) } }, write: ic }, CSS_RGB: { read: function (e) { var t = e.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/); return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]) } }, write: ic }, CSS_RGBA: { read: function (e) { var t = e.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/); return null !== t && { space: "RGB", r: parseFloat(t[1]), g: parseFloat(t[2]), b: parseFloat(t[3]), a: parseFloat(t[4]) } }, write: ic } } }, { litmus: ac.isNumber, conversions: { HEX: { read: function (e) { return { space: "HEX", hex: e, conversionName: "HEX" } }, write: function (e) { return e.hex } } } }, { litmus: ac.isArray, conversions: { RGB_ARRAY: { read: function (e) { return 3 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2] } }, write: function (e) { return [e.r, e.g, e.b] } }, RGBA_ARRAY: { read: function (e) { return 4 === e.length && { space: "RGB", r: e[0], g: e[1], b: e[2], a: e[3] } }, write: function (e) { return [e.r, e.g, e.b, e.a] } } } }, { litmus: ac.isObject, conversions: { RGBA_OBJ: { read: function (e) { return !!(ac.isNumber(e.r) && ac.isNumber(e.g) && ac.isNumber(e.b) && ac.isNumber(e.a)) && { space: "RGB", r: e.r, g: e.g, b: e.b, a: e.a } }, write: function (e) { return { r: e.r, g: e.g, b: e.b, a: e.a } } }, RGB_OBJ: { read: function (e) { return !!(ac.isNumber(e.r) && ac.isNumber(e.g) && ac.isNumber(e.b)) && { space: "RGB", r: e.r, g: e.g, b: e.b } }, write: function (e) { return { r: e.r, g: e.g, b: e.b } } }, HSVA_OBJ: { read: function (e) { return !!(ac.isNumber(e.h) && ac.isNumber(e.s) && ac.isNumber(e.v) && ac.isNumber(e.a)) && { space: "HSV", h: e.h, s: e.s, v: e.v, a: e.a } }, write: function (e) { return { h: e.h, s: e.s, v: e.v, a: e.a } } }, HSV_OBJ: { read: function (e) { return !!(ac.isNumber(e.h) && ac.isNumber(e.s) && ac.isNumber(e.v)) && { space: "HSV", h: e.h, s: e.s, v: e.v } }, write: function (e) { return { h: e.h, s: e.s, v: e.v } } } } }], oc = void 0, lc = void 0, cc = function () { lc = !1; var e = arguments.length > 1 ? ac.toArray(arguments) : arguments[0]; return ac.each(sc, (function (t) { if (t.litmus(e)) return ac.each(t.conversions, (function (t, i) { if (oc = t.read(e), !1 === lc && !1 !== oc) return lc = oc, oc.conversionName = i, oc.conversion = t, ac.BREAK })), ac.BREAK })), lc }, hc = void 0, uc = { hsv_to_rgb: function (e, t, i) { var n = Math.floor(e / 60) % 6, r = e / 60 - Math.floor(e / 60), a = i * (1 - t), s = i * (1 - r * t), o = i * (1 - (1 - r) * t), l = [[i, o, a], [s, i, a], [a, i, o], [a, s, i], [o, a, i], [i, a, s]][n]; return { r: 255 * l[0], g: 255 * l[1], b: 255 * l[2] } }, rgb_to_hsv: function (e, t, i) { var n = Math.min(e, t, i), r = Math.max(e, t, i), a = r - n, s = void 0; return 0 === r ? { h: NaN, s: 0, v: 0 } : (s = e === r ? (t - i) / a : t === r ? 2 + (i - e) / a : 4 + (e - t) / a, (s /= 6) < 0 && (s += 1), { h: 360 * s, s: a / r, v: r / 255 }) }, rgb_to_hex: function (e, t, i) { var n = this.hex_with_component(0, 2, e); return n = this.hex_with_component(n, 1, t), n = this.hex_with_component(n, 0, i) }, component_from_hex: function (e, t) { return e >> 8 * t & 255 }, hex_with_component: function (e, t, i) { return i << (hc = 8 * t) | e & ~(255 << hc) } }, dc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, pc = function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }, fc = function () { function e(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (t, i, n) { return i && e(t.prototype, i), n && e(t, n), t } }(), mc = function e(t, i, n) { null === t && (t = Function.prototype); var r = Object.getOwnPropertyDescriptor(t, i); if (void 0 === r) { var a = Object.getPrototypeOf(t); return null === a ? void 0 : e(a, i, n) } if ("value" in r) return r.value; var s = r.get; return void 0 !== s ? s.call(n) : void 0 }, gc = function (e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t) }, vc = function (e, t) { if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !t || "object" != typeof t && "function" != typeof t ? e : t }, yc = function () { function e() { if (pc(this, e), this.__state = cc.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments"); this.__state.a = this.__state.a || 1 } return fc(e, [{ key: "toString", value: function () { return ic(this) } }, { key: "toHexString", value: function () { return ic(this, !0) } }, { key: "toOriginal", value: function () { return this.__state.conversion.write(this) } }]), e }(); function _c(e, t, i) { Object.defineProperty(e, t, { get: function () { return "RGB" === this.__state.space || yc.recalculateRGB(this, t, i), this.__state[t] }, set: function (e) { "RGB" !== this.__state.space && (yc.recalculateRGB(this, t, i), this.__state.space = "RGB"), this.__state[t] = e } }) } function xc(e, t) { Object.defineProperty(e, t, { get: function () { return "HSV" === this.__state.space || yc.recalculateHSV(this), this.__state[t] }, set: function (e) { "HSV" !== this.__state.space && (yc.recalculateHSV(this), this.__state.space = "HSV"), this.__state[t] = e } }) } yc.recalculateRGB = function (e, t, i) { if ("HEX" === e.__state.space) e.__state[t] = uc.component_from_hex(e.__state.hex, i); else { if ("HSV" !== e.__state.space) throw new Error("Corrupted color state"); ac.extend(e.__state, uc.hsv_to_rgb(e.__state.h, e.__state.s, e.__state.v)) } }, yc.recalculateHSV = function (e) { var t = uc.rgb_to_hsv(e.r, e.g, e.b); ac.extend(e.__state, { s: t.s, v: t.v }), ac.isNaN(t.h) ? ac.isUndefined(e.__state.h) && (e.__state.h = 0) : e.__state.h = t.h }, yc.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], _c(yc.prototype, "r", 2), _c(yc.prototype, "g", 1), _c(yc.prototype, "b", 0), xc(yc.prototype, "h"), xc(yc.prototype, "s"), xc(yc.prototype, "v"), Object.defineProperty(yc.prototype, "a", { get: function () { return this.__state.a }, set: function (e) { this.__state.a = e } }), Object.defineProperty(yc.prototype, "hex", { get: function () { return "HEX" !== this.__state.space && (this.__state.hex = uc.rgb_to_hex(this.r, this.g, this.b), this.__state.space = "HEX"), this.__state.hex }, set: function (e) { this.__state.space = "HEX", this.__state.hex = e } }); var bc = function () { function e(t, i) { pc(this, e), this.initialValue = t[i], this.domElement = document.createElement("div"), this.object = t, this.property = i, this.__onChange = void 0, this.__onFinishChange = void 0 } return fc(e, [{ key: "onChange", value: function (e) { return this.__onChange = e, this } }, { key: "onFinishChange", value: function (e) { return this.__onFinishChange = e, this } }, { key: "setValue", value: function (e) { return this.object[this.property] = e, this.__onChange && this.__onChange.call(this, e), this.updateDisplay(), this } }, { key: "getValue", value: function () { return this.object[this.property] } }, { key: "updateDisplay", value: function () { return this } }, { key: "isModified", value: function () { return this.initialValue !== this.getValue() } }]), e }(), wc = {}; ac.each({ HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] }, (function (e, t) { ac.each(e, (function (e) { wc[e] = t })) })); var Tc = /(\d+(\.\d+)?)px/; function Mc(e) { if ("0" === e || ac.isUndefined(e)) return 0; var t = e.match(Tc); return ac.isNull(t) ? 0 : parseFloat(t[1]) } var Sc = { makeSelectable: function (e, t) { void 0 !== e && void 0 !== e.style && (e.onselectstart = t ? function () { return !1 } : function () { }, e.style.MozUserSelect = t ? "auto" : "none", e.style.KhtmlUserSelect = t ? "auto" : "none", e.unselectable = t ? "on" : "off") }, makeFullscreen: function (e, t, i) { var n = i, r = t; ac.isUndefined(r) && (r = !0), ac.isUndefined(n) && (n = !0), e.style.position = "absolute", r && (e.style.left = 0, e.style.right = 0), n && (e.style.top = 0, e.style.bottom = 0) }, fakeEvent: function (e, t, i, n) { var r = i || {}, a = wc[t]; if (!a) throw new Error("Event type " + t + " not supported."); var s = document.createEvent(a); switch (a) { case "MouseEvents": var o = r.x || r.clientX || 0, l = r.y || r.clientY || 0; s.initMouseEvent(t, r.bubbles || !1, r.cancelable || !0, window, r.clickCount || 1, 0, 0, o, l, !1, !1, !1, !1, 0, null); break; case "KeyboardEvents": var c = s.initKeyboardEvent || s.initKeyEvent; ac.defaults(r, { cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0 }), c(t, r.bubbles || !1, r.cancelable, window, r.ctrlKey, r.altKey, r.shiftKey, r.metaKey, r.keyCode, r.charCode); break; default: s.initEvent(t, r.bubbles || !1, r.cancelable || !0) }ac.defaults(s, n), e.dispatchEvent(s) }, bind: function (e, t, i, n) { var r = n || !1; return e.addEventListener ? e.addEventListener(t, i, r) : e.attachEvent && e.attachEvent("on" + t, i), Sc }, unbind: function (e, t, i, n) { var r = n || !1; return e.removeEventListener ? e.removeEventListener(t, i, r) : e.detachEvent && e.detachEvent("on" + t, i), Sc }, addClass: function (e, t) { if (void 0 === e.className) e.className = t; else if (e.className !== t) { var i = e.className.split(/ +/); -1 === i.indexOf(t) && (i.push(t), e.className = i.join(" ").replace(/^\s+/, "").replace(/\s+$/, "")) } return Sc }, removeClass: function (e, t) { if (t) if (e.className === t) e.removeAttribute("class"); else { var i = e.className.split(/ +/), n = i.indexOf(t); -1 !== n && (i.splice(n, 1), e.className = i.join(" ")) } else e.className = void 0; return Sc }, hasClass: function (e, t) { return new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1 }, getWidth: function (e) { var t = getComputedStyle(e); return Mc(t["border-left-width"]) + Mc(t["border-right-width"]) + Mc(t["padding-left"]) + Mc(t["padding-right"]) + Mc(t.width) }, getHeight: function (e) { var t = getComputedStyle(e); return Mc(t["border-top-width"]) + Mc(t["border-bottom-width"]) + Mc(t["padding-top"]) + Mc(t["padding-bottom"]) + Mc(t.height) }, getOffset: function (e) { var t = e, i = { left: 0, top: 0 }; if (t.offsetParent) do { i.left += t.offsetLeft, i.top += t.offsetTop, t = t.offsetParent } while (t); return i }, isActive: function (e) { return e === document.activeElement && (e.type || e.href) } }, Ec = function (e) { function t(e, i) { pc(this, t); var n = vc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), r = n; return n.__prev = n.getValue(), n.__checkbox = document.createElement("input"), n.__checkbox.setAttribute("type", "checkbox"), Sc.bind(n.__checkbox, "change", (function () { r.setValue(!r.__prev) }), !1), n.domElement.appendChild(n.__checkbox), n.updateDisplay(), n } return gc(t, e), fc(t, [{ key: "setValue", value: function (e) { var i = mc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), i } }, { key: "updateDisplay", value: function () { return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), mc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(bc), Cc = function (e) { function t(e, i, n) { pc(this, t); var r = vc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), a = n, s = r; if (r.__select = document.createElement("select"), ac.isArray(a)) { var o = {}; ac.each(a, (function (e) { o[e] = e })), a = o } return ac.each(a, (function (e, t) { var i = document.createElement("option"); i.innerHTML = t, i.setAttribute("value", e), s.__select.appendChild(i) })), r.updateDisplay(), Sc.bind(r.__select, "change", (function () { var e = this.options[this.selectedIndex].value; s.setValue(e) })), r.domElement.appendChild(r.__select), r } return gc(t, e), fc(t, [{ key: "setValue", value: function (e) { var i = mc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, e); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), i } }, { key: "updateDisplay", value: function () { return Sc.isActive(this.__select) ? this : (this.__select.value = this.getValue(), mc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this)) } }]), t }(bc), Ac = function (e) { function t(e, i) { pc(this, t); var n = vc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), r = n; function a() { r.setValue(r.__input.value) } return n.__input = document.createElement("input"), n.__input.setAttribute("type", "text"), Sc.bind(n.__input, "keyup", a), Sc.bind(n.__input, "change", a), Sc.bind(n.__input, "blur", (function () { r.__onFinishChange && r.__onFinishChange.call(r, r.getValue()) })), Sc.bind(n.__input, "keydown", (function (e) { 13 === e.keyCode && this.blur() })), n.updateDisplay(), n.domElement.appendChild(n.__input), n } return gc(t, e), fc(t, [{ key: "updateDisplay", value: function () { return Sc.isActive(this.__input) || (this.__input.value = this.getValue()), mc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(bc); function Pc(e) { var t = e.toString(); return t.indexOf(".") > -1 ? t.length - t.indexOf(".") - 1 : 0 } var Lc = function (e) { function t(e, i, n) { pc(this, t); var r = vc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), a = n || {}; return r.__min = a.min, r.__max = a.max, r.__step = a.step, ac.isUndefined(r.__step) ? 0 === r.initialValue ? r.__impliedStep = 1 : r.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(r.initialValue)) / Math.LN10)) / 10 : r.__impliedStep = r.__step, r.__precision = Pc(r.__impliedStep), r } return gc(t, e), fc(t, [{ key: "setValue", value: function (e) { var i = e; return void 0 !== this.__min && i < this.__min ? i = this.__min : void 0 !== this.__max && i > this.__max && (i = this.__max), void 0 !== this.__step && i % this.__step != 0 && (i = Math.round(i / this.__step) * this.__step), mc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "setValue", this).call(this, i) } }, { key: "min", value: function (e) { return this.__min = e, this } }, { key: "max", value: function (e) { return this.__max = e, this } }, { key: "step", value: function (e) { return this.__step = e, this.__impliedStep = e, this.__precision = Pc(e), this } }]), t }(bc); var Rc = function (e) { function t(e, i, n) { pc(this, t); var r = vc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i, n)); r.__truncationSuspended = !1; var a = r, s = void 0; function o() { a.__onFinishChange && a.__onFinishChange.call(a, a.getValue()) } function l(e) { var t = s - e.clientY; a.setValue(a.getValue() + t * a.__impliedStep), s = e.clientY } function c() { Sc.unbind(window, "mousemove", l), Sc.unbind(window, "mouseup", c), o() } return r.__input = document.createElement("input"), r.__input.setAttribute("type", "text"), Sc.bind(r.__input, "change", (function () { var e = parseFloat(a.__input.value); ac.isNaN(e) || a.setValue(e) })), Sc.bind(r.__input, "blur", (function () { o() })), Sc.bind(r.__input, "mousedown", (function (e) { Sc.bind(window, "mousemove", l), Sc.bind(window, "mouseup", c), s = e.clientY })), Sc.bind(r.__input, "keydown", (function (e) { 13 === e.keyCode && (a.__truncationSuspended = !0, this.blur(), a.__truncationSuspended = !1, o()) })), r.updateDisplay(), r.domElement.appendChild(r.__input), r } return gc(t, e), fc(t, [{ key: "updateDisplay", value: function () { var e, i, n; return this.__input.value = this.__truncationSuspended ? this.getValue() : (e = this.getValue(), i = this.__precision, n = Math.pow(10, i), Math.round(e * n) / n), mc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Lc); function Oc(e, t, i, n, r) { return n + (e - t) / (i - t) * (r - n) } var Ic = function (e) { function t(e, i, n, r, a) { pc(this, t); var s = vc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i, { min: n, max: r, step: a })), o = s; function l(e) { e.preventDefault(); var t = o.__background.getBoundingClientRect(); return o.setValue(Oc(e.clientX, t.left, t.right, o.__min, o.__max)), !1 } function c() { Sc.unbind(window, "mousemove", l), Sc.unbind(window, "mouseup", c), o.__onFinishChange && o.__onFinishChange.call(o, o.getValue()) } function h(e) { var t = e.touches[0].clientX, i = o.__background.getBoundingClientRect(); o.setValue(Oc(t, i.left, i.right, o.__min, o.__max)) } function u() { Sc.unbind(window, "touchmove", h), Sc.unbind(window, "touchend", u), o.__onFinishChange && o.__onFinishChange.call(o, o.getValue()) } return s.__background = document.createElement("div"), s.__foreground = document.createElement("div"), Sc.bind(s.__background, "mousedown", (function (e) { document.activeElement.blur(), Sc.bind(window, "mousemove", l), Sc.bind(window, "mouseup", c), l(e) })), Sc.bind(s.__background, "touchstart", (function (e) { if (1 !== e.touches.length) return; Sc.bind(window, "touchmove", h), Sc.bind(window, "touchend", u), h(e) })), Sc.addClass(s.__background, "slider"), Sc.addClass(s.__foreground, "slider-fg"), s.updateDisplay(), s.__background.appendChild(s.__foreground), s.domElement.appendChild(s.__background), s } return gc(t, e), fc(t, [{ key: "updateDisplay", value: function () { var e = (this.getValue() - this.__min) / (this.__max - this.__min); return this.__foreground.style.width = 100 * e + "%", mc(t.prototype.__proto__ || Object.getPrototypeOf(t.prototype), "updateDisplay", this).call(this) } }]), t }(Lc), kc = function (e) { function t(e, i, n) { pc(this, t); var r = vc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)), a = r; return r.__button = document.createElement("div"), r.__button.innerHTML = void 0 === n ? "Fire" : n, Sc.bind(r.__button, "click", (function (e) { return e.preventDefault(), a.fire(), !1 })), Sc.addClass(r.__button, "button"), r.domElement.appendChild(r.__button), r } return gc(t, e), fc(t, [{ key: "fire", value: function () { this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()) } }]), t }(bc), Dc = function (e) { function t(e, i) { pc(this, t); var n = vc(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, i)); n.__color = new yc(n.getValue()), n.__temp = new yc(0); var r = n; n.domElement = document.createElement("div"), Sc.makeSelectable(n.domElement, !1), n.__selector = document.createElement("div"), n.__selector.className = "selector", n.__saturation_field = document.createElement("div"), n.__saturation_field.className = "saturation-field", n.__field_knob = document.createElement("div"), n.__field_knob.className = "field-knob", n.__field_knob_border = "2px solid ", n.__hue_knob = document.createElement("div"), n.__hue_knob.className = "hue-knob", n.__hue_field = document.createElement("div"), n.__hue_field.className = "hue-field", n.__input = document.createElement("input"), n.__input.type = "text", n.__input_textShadow = "0 1px 1px ", Sc.bind(n.__input, "keydown", (function (e) { 13 === e.keyCode && u.call(this) })), Sc.bind(n.__input, "blur", u), Sc.bind(n.__selector, "mousedown", (function () { Sc.addClass(this, "drag").bind(window, "mouseup", (function () { Sc.removeClass(r.__selector, "drag") })) })), Sc.bind(n.__selector, "touchstart", (function () { Sc.addClass(this, "drag").bind(window, "touchend", (function () { Sc.removeClass(r.__selector, "drag") })) })); var a, s = document.createElement("div"); function o(e) { p(e), Sc.bind(window, "mousemove", p), Sc.bind(window, "touchmove", p), Sc.bind(window, "mouseup", c), Sc.bind(window, "touchend", c) } function l(e) { f(e), Sc.bind(window, "mousemove", f), Sc.bind(window, "touchmove", f), Sc.bind(window, "mouseup", h), Sc.bind(window, "touchend", h) } function c() { Sc.unbind(window, "mousemove", p), Sc.unbind(window, "touchmove", p), Sc.unbind(window, "mouseup", c), Sc.unbind(window, "touchend", c), d() } function h() { Sc.unbind(window, "mousemove", f), Sc.unbind(window, "touchmove", f), Sc.unbind(window, "mouseup", h), Sc.unbind(window, "touchend", h), d() } function u() { var e = cc(this.value); !1 !== e ? (r.__color.__state = e, r.setValue(r.__color.toOriginal())) : this.value = r.__color.toString() } function d() { r.__onFinishChange && r.__onFinishChange.call(r, r.__color.toOriginal()) } function p(e) { -1 === e.type.indexOf("touch") && e.preventDefault(); var t = r.__saturation_field.getBoundingClientRect(), i = e.touches && e.touches[0] || e, n = i.clientX, a = i.clientY, s = (n - t.left) / (t.right - t.left), o = 1 - (a - t.top) / (t.bottom - t.top); return o > 1 ? o = 1 : o < 0 && (o = 0), s > 1 ? s = 1 : s < 0 && (s = 0), r.__color.v = o, r.__color.s = s, r.setValue(r.__color.toOriginal()), !1 } function f(e) { -1 === e.type.indexOf("touch") && e.preventDefault(); var t = r.__hue_field.getBoundingClientRect(), i = 1 - ((e.touches && e.touches[0] || e).clientY - t.top) / (t.bottom - t.top); return i > 1 ? i = 1 : i < 0 && (i = 0), r.__color.h = 360 * i, r.setValue(r.__color.toOriginal()), !1 } return ac.extend(n.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), ac.extend(n.__field_knob.style, { position: "absolute", width: "12px", height: "12px", border: n.__field_knob_border + (n.__color.v < .5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), ac.extend(n.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), ac.extend(n.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), ac.extend(s.style, { width: "100%", height: "100%", background: "none" }), Nc(s, "top", "rgba(0,0,0,0)", "#000"), ac.extend(n.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), (a = n.__hue_field).style.background = "", a.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", a.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", a.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", ac.extend(n.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: n.__input_textShadow + "rgba(0,0,0,0.7)" }), Sc.bind(n.__saturation_field, "mousedown", o), Sc.bind(n.__saturation_field, "touchstart", o), Sc.bind(n.__field_knob, "mousedown", o), Sc.bind(n.__field_knob, "touchstart", o), Sc.bind(n.__hue_field, "mousedown", l), Sc.bind(n.__hue_field, "touchstart", l), n.__saturation_field.appendChild(s), n.__selector.appendChild(n.__field_knob), n.__selector.appendChild(n.__saturation_field), n.__selector.appendChild(n.__hue_field), n.__hue_field.appendChild(n.__hue_knob), n.domElement.appendChild(n.__input), n.domElement.appendChild(n.__selector), n.updateDisplay(), n } return gc(t, e), fc(t, [{ key: "updateDisplay", value: function () { var e = cc(this.getValue()); if (!1 !== e) { var t = !1; ac.each(yc.COMPONENTS, (function (i) { if (!ac.isUndefined(e[i]) && !ac.isUndefined(this.__color.__state[i]) && e[i] !== this.__color.__state[i]) return t = !0, {} }), this), t && ac.extend(this.__color.__state, e) } ac.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1; var i = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0, n = 255 - i; ac.extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + "rgb(" + i + "," + i + "," + i + ")" }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, Nc(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), ac.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + i + "," + i + "," + i + ")", textShadow: this.__input_textShadow + "rgba(" + n + "," + n + "," + n + ",.7)" }) } }]), t }(bc), zc = ["-moz-", "-o-", "-webkit-", "-ms-", ""]; function Nc(e, t, i, n) { e.style.background = "", ac.each(zc, (function (r) { e.style.cssText += "background: " + r + "linear-gradient(" + t + ", " + i + " 0%, " + n + " 100%); " })) } var Bc = function (e, t) { var i = t || document, n = document.createElement("style"); n.type = "text/css", n.innerHTML = e; var r = i.getElementsByTagName("head")[0]; try { r.appendChild(n) } catch (e) { } }, Fc = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>', Gc = function (e, t) { var i = e[t]; return ac.isArray(arguments[2]) || ac.isObject(arguments[2]) ? new Cc(e, t, arguments[2]) : ac.isNumber(i) ? ac.isNumber(arguments[2]) && ac.isNumber(arguments[3]) ? ac.isNumber(arguments[4]) ? new Ic(e, t, arguments[2], arguments[3], arguments[4]) : new Ic(e, t, arguments[2], arguments[3]) : ac.isNumber(arguments[4]) ? new Rc(e, t, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new Rc(e, t, { min: arguments[2], max: arguments[3] }) : ac.isString(i) ? new Ac(e, t) : ac.isFunction(i) ? new kc(e, t, "") : ac.isBoolean(i) ? new Ec(e, t) : null }; var Uc = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (e) { setTimeout(e, 1e3 / 60) }, Hc = function () { function e() { pc(this, e), this.backgroundElement = document.createElement("div"), ac.extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), Sc.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), ac.extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement); var t = this; Sc.bind(this.backgroundElement, "click", (function () { t.hide() })) } return fc(e, [{ key: "show", value: function () { var e = this; this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), ac.defer((function () { e.backgroundElement.style.opacity = 1, e.domElement.style.opacity = 1, e.domElement.style.webkitTransform = "scale(1)" })) } }, { key: "hide", value: function () { var e = this, t = function t() { e.domElement.style.display = "none", e.backgroundElement.style.display = "none", Sc.unbind(e.domElement, "webkitTransitionEnd", t), Sc.unbind(e.domElement, "transitionend", t), Sc.unbind(e.domElement, "oTransitionEnd", t) }; Sc.bind(this.domElement, "webkitTransitionEnd", t), Sc.bind(this.domElement, "transitionend", t), Sc.bind(this.domElement, "oTransitionEnd", t), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)" } }, { key: "layout", value: function () { this.domElement.style.left = window.innerWidth / 2 - Sc.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - Sc.getHeight(this.domElement) / 2 + "px" } }]), e }(); Bc(function (e) { if (e && "undefined" != typeof window) { var t = document.createElement("style"); return t.setAttribute("type", "text/css"), t.innerHTML = e, document.head.appendChild(t), e } }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n")); var Vc = function () { try { return !!window.localStorage } catch (e) { return !1 } }(), jc = void 0, Wc = !0, $c = void 0, Xc = !1, Yc = [], qc = function e(t) { var i = this, n = t || {}; this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), Sc.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], n = ac.defaults(n, { closeOnTop: !1, autoPlace: !0, width: e.DEFAULT_WIDTH }), n = ac.defaults(n, { resizable: n.autoPlace, hideable: n.autoPlace }), ac.isUndefined(n.load) ? n.load = { preset: "Default" } : n.preset && (n.load.preset = n.preset), ac.isUndefined(n.parent) && n.hideable && Yc.push(this), n.resizable = ac.isUndefined(n.parent) && n.resizable, n.autoPlace && ac.isUndefined(n.scrollable) && (n.scrollable = !0); var r, a = Vc && "true" === localStorage.getItem(th(this, "isLocal")), s = void 0, o = void 0; if (Object.defineProperties(this, { parent: { get: function () { return n.parent } }, scrollable: { get: function () { return n.scrollable } }, autoPlace: { get: function () { return n.autoPlace } }, closeOnTop: { get: function () { return n.closeOnTop } }, preset: { get: function () { return i.parent ? i.getRoot().preset : n.load.preset }, set: function (e) { i.parent ? i.getRoot().preset = e : n.load.preset = e, function (e) { for (var t = 0; t < e.__preset_select.length; t++)e.__preset_select[t].value === e.preset && (e.__preset_select.selectedIndex = t) }(this), i.revert() } }, width: { get: function () { return n.width }, set: function (e) { n.width = e, sh(i, e) } }, name: { get: function () { return n.name }, set: function (e) { n.name = e, o && (o.innerHTML = n.name) } }, closed: { get: function () { return n.closed }, set: function (t) { n.closed = t, n.closed ? Sc.addClass(i.__ul, e.CLASS_CLOSED) : Sc.removeClass(i.__ul, e.CLASS_CLOSED), this.onResize(), i.__closeButton && (i.__closeButton.innerHTML = t ? e.TEXT_OPEN : e.TEXT_CLOSED) } }, load: { get: function () { return n.load } }, useLocalStorage: { get: function () { return a }, set: function (e) { Vc && (a = e, e ? Sc.bind(window, "unload", s) : Sc.unbind(window, "unload", s), localStorage.setItem(th(i, "isLocal"), e)) } } }), ac.isUndefined(n.parent)) { if (this.closed = n.closed || !1, Sc.addClass(this.domElement, e.CLASS_MAIN), Sc.makeSelectable(this.domElement, !1), Vc && a) { i.useLocalStorage = !0; var l = localStorage.getItem(th(this, "gui")); l && (n.load = JSON.parse(l)) } this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = e.TEXT_CLOSED, Sc.addClass(this.__closeButton, e.CLASS_CLOSE_BUTTON), n.closeOnTop ? (Sc.addClass(this.__closeButton, e.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (Sc.addClass(this.__closeButton, e.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), Sc.bind(this.__closeButton, "click", (function () { i.closed = !i.closed })) } else { void 0 === n.closed && (n.closed = !0); var c = document.createTextNode(n.name); Sc.addClass(c, "controller-name"), o = Jc(i, c); Sc.addClass(this.__ul, e.CLASS_CLOSED), Sc.addClass(o, "title"), Sc.bind(o, "click", (function (e) { return e.preventDefault(), i.closed = !i.closed, !1 })), n.closed || (this.closed = !1) } n.autoPlace && (ac.isUndefined(n.parent) && (Wc && ($c = document.createElement("div"), Sc.addClass($c, "dg"), Sc.addClass($c, e.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild($c), Wc = !1), $c.appendChild(this.domElement), Sc.addClass(this.domElement, e.CLASS_AUTO_PLACE)), this.parent || sh(i, n.width)), this.__resizeHandler = function () { i.onResizeDebounced() }, Sc.bind(window, "resize", this.__resizeHandler), Sc.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), Sc.bind(this.__ul, "transitionend", this.__resizeHandler), Sc.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), n.resizable && ah(this), s = function () { Vc && "true" === localStorage.getItem(th(i, "isLocal")) && localStorage.setItem(th(i, "gui"), JSON.stringify(i.getSaveObject())) }, this.saveToLocalStorageIfPossible = s, n.parent || ((r = i.getRoot()).width += 1, ac.defer((function () { r.width -= 1 }))) }; function Jc(e, t, i) { var n = document.createElement("li"); return t && n.appendChild(t), i ? e.__ul.insertBefore(n, i) : e.__ul.appendChild(n), e.onResize(), n } function Zc(e) { Sc.unbind(window, "resize", e.__resizeHandler), e.saveToLocalStorageIfPossible && Sc.unbind(window, "unload", e.saveToLocalStorageIfPossible) } function Kc(e, t) { var i = e.__preset_select[e.__preset_select.selectedIndex]; i.innerHTML = t ? i.value + "*" : i.value } function Qc(e, t) { var i = e.getRoot(), n = i.__rememberedObjects.indexOf(t.object); if (-1 !== n) { var r = i.__rememberedObjectIndecesToControllers[n]; if (void 0 === r && (r = {}, i.__rememberedObjectIndecesToControllers[n] = r), r[t.property] = t, i.load && i.load.remembered) { var a = i.load.remembered, s = void 0; if (a[e.preset]) s = a[e.preset]; else { if (!a.Default) return; s = a.Default } if (s[n] && void 0 !== s[n][t.property]) { var o = s[n][t.property]; t.initialValue = o, t.setValue(o) } } } } function eh(e, t, i, n) { if (void 0 === t[i]) throw new Error('Object "' + t + '" has no property "' + i + '"'); var r = void 0; if (n.color) r = new Dc(t, i); else { var a = [t, i].concat(n.factoryArgs); r = Gc.apply(e, a) } n.before instanceof bc && (n.before = n.before.__li), Qc(e, r), Sc.addClass(r.domElement, "c"); var s = document.createElement("span"); Sc.addClass(s, "property-name"), s.innerHTML = r.property; var o = document.createElement("div"); o.appendChild(s), o.appendChild(r.domElement); var l = Jc(e, o, n.before); return Sc.addClass(l, qc.CLASS_CONTROLLER_ROW), r instanceof Dc ? Sc.addClass(l, "color") : Sc.addClass(l, dc(r.getValue())), function (e, t, i) { if (i.__li = t, i.__gui = e, ac.extend(i, { options: function (t) { if (arguments.length > 1) { var n = i.__li.nextElementSibling; return i.remove(), eh(e, i.object, i.property, { before: n, factoryArgs: [ac.toArray(arguments)] }) } if (ac.isArray(t) || ac.isObject(t)) { var r = i.__li.nextElementSibling; return i.remove(), eh(e, i.object, i.property, { before: r, factoryArgs: [t] }) } }, name: function (e) { return i.__li.firstElementChild.firstElementChild.innerHTML = e, i }, listen: function () { return i.__gui.listen(i), i }, remove: function () { return i.__gui.remove(i), i } }), i instanceof Ic) { var n = new Rc(i.object, i.property, { min: i.__min, max: i.__max, step: i.__step }); ac.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], (function (e) { var t = i[e], r = n[e]; i[e] = n[e] = function () { var e = Array.prototype.slice.call(arguments); return r.apply(n, e), t.apply(i, e) } })), Sc.addClass(t, "has-slider"), i.domElement.insertBefore(n.domElement, i.domElement.firstElementChild) } else if (i instanceof Rc) { var r = function (t) { if (ac.isNumber(i.__min) && ac.isNumber(i.__max)) { var n = i.__li.firstElementChild.firstElementChild.innerHTML, r = i.__gui.__listening.indexOf(i) > -1; i.remove(); var a = eh(e, i.object, i.property, { before: i.__li.nextElementSibling, factoryArgs: [i.__min, i.__max, i.__step] }); return a.name(n), r && a.listen(), a } return t }; i.min = ac.compose(r, i.min), i.max = ac.compose(r, i.max) } else i instanceof Ec ? (Sc.bind(t, "click", (function () { Sc.fakeEvent(i.__checkbox, "click") })), Sc.bind(i.__checkbox, "click", (function (e) { e.stopPropagation() }))) : i instanceof kc ? (Sc.bind(t, "click", (function () { Sc.fakeEvent(i.__button, "click") })), Sc.bind(t, "mouseover", (function () { Sc.addClass(i.__button, "hover") })), Sc.bind(t, "mouseout", (function () { Sc.removeClass(i.__button, "hover") }))) : i instanceof Dc && (Sc.addClass(t, "color"), i.updateDisplay = ac.compose((function (e) { return t.style.borderLeftColor = i.__color.toString(), e }), i.updateDisplay), i.updateDisplay()); i.setValue = ac.compose((function (t) { return e.getRoot().__preset_select && i.isModified() && Kc(e.getRoot(), !0), t }), i.setValue) }(e, l, r), e.__controllers.push(r), r } function th(e, t) { return document.location.href + "." + t } function ih(e, t, i) { var n = document.createElement("option"); n.innerHTML = t, n.value = t, e.__preset_select.appendChild(n), i && (e.__preset_select.selectedIndex = e.__preset_select.length - 1) } function nh(e, t) { t.style.display = e.useLocalStorage ? "block" : "none" } function rh(e) { var t = e.__save_row = document.createElement("li"); Sc.addClass(e.domElement, "has-save"), e.__ul.insertBefore(t, e.__ul.firstChild), Sc.addClass(t, "save-row"); var i = document.createElement("span"); i.innerHTML = "&nbsp;", Sc.addClass(i, "button gears"); var n = document.createElement("span"); n.innerHTML = "Save", Sc.addClass(n, "button"), Sc.addClass(n, "save"); var r = document.createElement("span"); r.innerHTML = "New", Sc.addClass(r, "button"), Sc.addClass(r, "save-as"); var a = document.createElement("span"); a.innerHTML = "Revert", Sc.addClass(a, "button"), Sc.addClass(a, "revert"); var s = e.__preset_select = document.createElement("select"); if (e.load && e.load.remembered ? ac.each(e.load.remembered, (function (t, i) { ih(e, i, i === e.preset) })) : ih(e, "Default", !1), Sc.bind(s, "change", (function () { for (var t = 0; t < e.__preset_select.length; t++)e.__preset_select[t].innerHTML = e.__preset_select[t].value; e.preset = this.value })), t.appendChild(s), t.appendChild(i), t.appendChild(n), t.appendChild(r), t.appendChild(a), Vc) { var o = document.getElementById("dg-local-explain"), l = document.getElementById("dg-local-storage"); document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem(th(0, "isLocal")) && l.setAttribute("checked", "checked"), nh(e, o), Sc.bind(l, "change", (function () { e.useLocalStorage = !e.useLocalStorage, nh(e, o) })) } var c = document.getElementById("dg-new-constructor"); Sc.bind(c, "keydown", (function (e) { !e.metaKey || 67 !== e.which && 67 !== e.keyCode || jc.hide() })), Sc.bind(i, "click", (function () { c.innerHTML = JSON.stringify(e.getSaveObject(), void 0, 2), jc.show(), c.focus(), c.select() })), Sc.bind(n, "click", (function () { e.save() })), Sc.bind(r, "click", (function () { var t = prompt("Enter a new preset name."); t && e.saveAs(t) })), Sc.bind(a, "click", (function () { e.revert() })) } function ah(e) { var t = void 0; function i(i) { return i.preventDefault(), e.width += t - i.clientX, e.onResize(), t = i.clientX, !1 } function n() { Sc.removeClass(e.__closeButton, qc.CLASS_DRAG), Sc.unbind(window, "mousemove", i), Sc.unbind(window, "mouseup", n) } function r(r) { return r.preventDefault(), t = r.clientX, Sc.addClass(e.__closeButton, qc.CLASS_DRAG), Sc.bind(window, "mousemove", i), Sc.bind(window, "mouseup", n), !1 } e.__resize_handle = document.createElement("div"), ac.extend(e.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), Sc.bind(e.__resize_handle, "mousedown", r), Sc.bind(e.__closeButton, "mousedown", r), e.domElement.insertBefore(e.__resize_handle, e.domElement.firstElementChild) } function sh(e, t) { e.domElement.style.width = t + "px", e.__save_row && e.autoPlace && (e.__save_row.style.width = t + "px"), e.__closeButton && (e.__closeButton.style.width = t + "px") } function oh(e, t) { var i = {}; return ac.each(e.__rememberedObjects, (function (n, r) { var a = {}, s = e.__rememberedObjectIndecesToControllers[r]; ac.each(s, (function (e, i) { a[i] = t ? e.initialValue : e.getValue() })), i[r] = a })), i } qc.toggleHide = function () { Xc = !Xc, ac.each(Yc, (function (e) { e.domElement.style.display = Xc ? "none" : "" })) }, qc.CLASS_AUTO_PLACE = "a", qc.CLASS_AUTO_PLACE_CONTAINER = "ac", qc.CLASS_MAIN = "main", qc.CLASS_CONTROLLER_ROW = "cr", qc.CLASS_TOO_TALL = "taller-than-window", qc.CLASS_CLOSED = "closed", qc.CLASS_CLOSE_BUTTON = "close-button", qc.CLASS_CLOSE_TOP = "close-top", qc.CLASS_CLOSE_BOTTOM = "close-bottom", qc.CLASS_DRAG = "drag", qc.DEFAULT_WIDTH = 245, qc.TEXT_CLOSED = "Close Controls", qc.TEXT_OPEN = "Open Controls", qc._keydownHandler = function (e) { "text" === document.activeElement.type || 72 !== e.which && 72 !== e.keyCode || qc.toggleHide() }, Sc.bind(window, "keydown", qc._keydownHandler, !1), ac.extend(qc.prototype, { add: function (e, t) { return eh(this, e, t, { factoryArgs: Array.prototype.slice.call(arguments, 2) }) }, addColor: function (e, t) { return eh(this, e, t, { color: !0 }) }, remove: function (e) { this.__ul.removeChild(e.__li), this.__controllers.splice(this.__controllers.indexOf(e), 1); var t = this; ac.defer((function () { t.onResize() })) }, destroy: function () { if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead."); this.autoPlace && $c.removeChild(this.domElement); var e = this; ac.each(this.__folders, (function (t) { e.removeFolder(t) })), Sc.unbind(window, "keydown", qc._keydownHandler, !1), Zc(this) }, addFolder: function (e) { if (void 0 !== this.__folders[e]) throw new Error('You already have a folder in this GUI by the name "' + e + '"'); var t = { name: e, parent: this }; t.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[e] && (t.closed = this.load.folders[e].closed, t.load = this.load.folders[e]); var i = new qc(t); this.__folders[e] = i; var n = Jc(this, i.domElement); return Sc.addClass(n, "folder"), i }, removeFolder: function (e) { this.__ul.removeChild(e.domElement.parentElement), delete this.__folders[e.name], this.load && this.load.folders && this.load.folders[e.name] && delete this.load.folders[e.name], Zc(e); var t = this; ac.each(e.__folders, (function (t) { e.removeFolder(t) })), ac.defer((function () { t.onResize() })) }, open: function () { this.closed = !1 }, close: function () { this.closed = !0 }, hide: function () { this.domElement.style.display = "none" }, show: function () { this.domElement.style.display = "" }, onResize: function () { var e = this.getRoot(); if (e.scrollable) { var t = Sc.getOffset(e.__ul).top, i = 0; ac.each(e.__ul.childNodes, (function (t) { e.autoPlace && t === e.__save_row || (i += Sc.getHeight(t)) })), window.innerHeight - t - 20 < i ? (Sc.addClass(e.domElement, qc.CLASS_TOO_TALL), e.__ul.style.height = window.innerHeight - t - 20 + "px") : (Sc.removeClass(e.domElement, qc.CLASS_TOO_TALL), e.__ul.style.height = "auto") } e.__resize_handle && ac.defer((function () { e.__resize_handle.style.height = e.__ul.offsetHeight + "px" })), e.__closeButton && (e.__closeButton.style.width = e.width + "px") }, onResizeDebounced: ac.debounce((function () { this.onResize() }), 50), remember: function () { if (ac.isUndefined(jc) && ((jc = new Hc).domElement.innerHTML = Fc), this.parent) throw new Error("You can only call remember on a top level GUI."); var e = this; ac.each(Array.prototype.slice.call(arguments), (function (t) { 0 === e.__rememberedObjects.length && rh(e), -1 === e.__rememberedObjects.indexOf(t) && e.__rememberedObjects.push(t) })), this.autoPlace && sh(this, this.width) }, getRoot: function () { for (var e = this; e.parent;)e = e.parent; return e }, getSaveObject: function () { var e = this.load; return e.closed = this.closed, this.__rememberedObjects.length > 0 && (e.preset = this.preset, e.remembered || (e.remembered = {}), e.remembered[this.preset] = oh(this)), e.folders = {}, ac.each(this.__folders, (function (t, i) { e.folders[i] = t.getSaveObject() })), e }, save: function () { this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = oh(this), Kc(this, !1), this.saveToLocalStorageIfPossible() }, saveAs: function (e) { this.load.remembered || (this.load.remembered = {}, this.load.remembered.Default = oh(this, !0)), this.load.remembered[e] = oh(this), this.preset = e, ih(this, e, !0), this.saveToLocalStorageIfPossible() }, revert: function (e) { ac.each(this.__controllers, (function (t) { this.getRoot().load.remembered ? Qc(e || this.getRoot(), t) : t.setValue(t.initialValue), t.__onFinishChange && t.__onFinishChange.call(t, t.getValue()) }), this), ac.each(this.__folders, (function (e) { e.revert(e) })), e || Kc(this.getRoot(), !1) }, listen: function (e) { var t = 0 === this.__listening.length; this.__listening.push(e), t && function e(t) { 0 !== t.length && Uc.call(window, (function () { e(t) })); ac.each(t, (function (e) { e.updateDisplay() })) }(this.__listening) }, updateDisplay: function () { ac.each(this.__controllers, (function (e) { e.updateDisplay() })), ac.each(this.__folders, (function (e) { e.updateDisplay() })) } }); const lh = new go(yo); let ch, hh, uh, dh, ph, fh, mh, gh, vh, yh, _h, xh, bh, wh = 0, Th = !1; const Mh = () => { window.scrollTo(0, 0) }, Sh = (e, t, i) => { let n = setInterval((function () { t >= i ? (clearInterval(n), window.removeEventListener("scroll", Mh)) : (r = t += 2, e.position.y = r); var r }), 2) }, Eh = (e, t, i) => { let n = 0, r = i, a = setInterval((function () { t ? n >= r ? clearInterval(a) : (n += .01, s(n)) : r <= n ? clearInterval(a) : (r -= .01, s(r)) }), 5); function s(t) { e.material.opacity = t, e.matrixAutoUpdate = !1, e.updateMatrix() } }, Ch = e => { (() => { let e = hh.getObjectByName("sky"), t = hh.getObjectByName("nightSky"); Wl.night.progress() > 0 && !Th ? (Eh(e, !1, .4), Eh(t, !0, 1), Th = !0) : Wl.night.progress() <= 0 && Th && (Eh(e, !0, .4), Eh(t, !1, 1), Th = !1) })(), (() => { let e = Wl.morning.duration() + Wl.sunset.duration() + Wl.morning.offset(), t = Wl.sunset.progress(); ph.position.x = 8 * calcScroll(e, !1), ph.position.y = 5 * calcScroll(e, !0), ph.intensity = 1.5 - 1.5 * t, ph.color = t >= 0 ? vo[Math.floor(t / 10)] : vo[0], fh.intensity = .7 * Wl.night.progress(); let i = progNumbers(284.3, 270, Wl.morning.progress()); i > 270 && (ch.position.z = Math.round(i)) })(), setTime(dh, .005 * calcScroll(document.body.scrollHeight / 2, !1)), vh.material.opacity = 2 * Wl.sunset.progress(), _h.position.x = stepNumbers(0, 26, Wl.night.progress()), _h.position.y = stepNumbers(-15, -24, Wl.night.progress()) }, Ah = e => { wh = (e.clientX - window.innerWidth / 2) / 12 }, Ph = e => { uh.setSize(window.innerWidth, window.innerHeight), ch.aspect = window.innerWidth / window.innerHeight, ch.updateProjectionMatrix() }, Lh = e => { wh = 10 * Math.round(e.gamma) }; window.onbeforeunload = function () { window.scrollTo(0, 0) }, window.calcScroll = function (e, t) { return t ? 100 - Math.floor(document.documentElement.scrollTop / (e - document.documentElement.clientHeight) * 100) : Math.floor(document.documentElement.scrollTop / (e - document.documentElement.clientHeight) * 100) }, window.progNumbers = function (e, t, i) { return e - (e - t) * i }, window.stepNumbers = function (e, t, i) { return Math.abs(t - e) * i + Math.min(e, t) }, window.setTime = function (e, t) { e.time = 0; for (var i = 0; i < e._actions.length; i++)e._actions[i].time = 0; return e.update(t) }, window.addEventListener("scroll", Mh); const Rh = () => { if (console.clear(), So()) { let e = new TimelineMax({ delay: 2, ease: Linear.easeNone }); e.to("#loading", .3, { opacity: 0 }), e.to("#logo", .5, { opacity: 1 }, ">1"), e.to("#swipe", .3, { bottom: 45 }, "<"), e.to("#content", .3, { opacity: 1 }, "<"), e.to("#mainObj", .8, { opacity: 1 }, ">") } else { let e = new TimelineMax({ delay: 1, ease: Linear.easeNone }); e.to("#loading", .3, { opacity: 0 }), e.to("#logo", .5, { opacity: 1 }, ">1"), e.to("#dots", .3, { right: 0 }, "<"), e.to("#scroll", .3, { left: 0 }, "<"), e.to("#mainObj", .8, { opacity: 1 }, ">0.9"), e.add((function () { Sh(mh, -90, 8) })) } }, Oh = (e, t) => { const i = document.getElementById("mainObj"); if (t) { const e = bo(null, "SLF-badAss", !0); hh = e.mainScene, uh = e.renderer, ch = e.camera, ch.aspect = window.innerWidth / window.innerHeight, i.appendChild(uh.domElement), uh.setPixelRatio(window.devicePixelRatio), uh.setSize(window.innerWidth, window.innerHeight), window.addEventListener("deviceorientation", Lh, !1), kh() } else { const t = bo(e, yh, "SLF-badAss"); hh = t.mainScene, uh = t.renderer, dh = t.animation, xh = t.wormDance, bh = t.clock, ph = hh.getObjectByName("Sun"), fh = hh.getObjectByName("Moon"), gh = hh.getObjectByName("Picciolo"); const n = hh.getObjectByName("MelaBackup"); vh = hh.getObjectByName("MelaRotten"), mh = hh.getObjectByName("AppleGroup"), n.material.flatShading = !0, n.material.metalness = 0, n.material.roughness = .6, vh.material.opacity = 0, vh.material.metalness = 0, vh.material.roughness = .7, gh.children[0].material.metalness = 0, vh.material.transparent = !0, _h = hh.getObjectByName("Worm"), _h.material.metalness = 0, _h.material.roughness = .5, mh.position.y = -100, ch = hh.getObjectByName("CameraC4D"), ch.aspect = window.innerWidth / window.innerHeight, ch.updateProjectionMatrix(), i.appendChild(uh.domElement), uh.setPixelRatio(window.devicePixelRatio), uh.setSize(window.innerWidth, window.innerHeight), document.addEventListener("scroll", Ch, !1), document.addEventListener("mousemove", Ah, !1), Ih() } window.addEventListener("resize", Ph, !1) }, Ih = () => { requestAnimationFrame(Ih), ch.position.x += .05 * (wh - ch.position.x), ch.lookAt(3, 15, 0), gh.rotation.z = 6, xh.update(bh.getDelta()), uh.render(hh, ch) }, kh = () => { requestAnimationFrame(kh), ch.position.x += .1 * (wh - ch.position.x), uh.render(hh, ch) }; So() ? (Oh(null, !0), Rh()) : (yo.onProgress = function (e, t, i) { t / i == 1 && Rh() }, lh.load("assets/3D/WormGL.gltf", (function (e) { yh = e })), lh.load("assets/3D/MelaGL.gltf", (function (e) { Oh(e, !1) })))
}, function (e, t, i) {
    "use strict"; i.r(t); var n = i(0), r = i(2), a = i(3), s = i(4);
    /*!
     * VERSION: 2.1.3
     * DATE: 2019-05-17
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     */
    n.k._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], (function () { var e, t, i, r, a = function () { n.j.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = a.prototype.setRatio }, s = n.k._gsDefine.globals, o = {}, l = a.prototype = new n.j("css"); l.constructor = a, a.version = "2.1.3", a.API = 2, a.defaultTransformPerspective = 0, a.defaultSkewType = "compensated", a.defaultSmoothOrigin = !0, l = "px", a.suffixMap = { top: l, right: l, bottom: l, left: l, width: l, height: l, fontSize: l, padding: l, margin: l, perspective: l, lineHeight: "" }; var c, h, u, d, p, f, m, g, v = /(?:\-|\.|\b)(\d|\.|e\-)+/g, y = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g, _ = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, x = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b),?/gi, b = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g, w = /(?:\d|\-|\+|=|#|\.)*/g, T = /opacity *= *([^)]*)/i, M = /opacity:([^;]*)/i, S = /alpha\(opacity *=.+?\)/i, E = /^(rgb|hsl)/, C = /([A-Z])/g, A = /-([a-z])/gi, P = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, L = function (e, t) { return t.toUpperCase() }, R = /(?:Left|Right|Width)/i, O = /(M11|M12|M21|M22)=[\d\-\.e]+/gi, I = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, k = /,(?=[^\)]*(?:\(|$))/gi, D = /[\s,\(]/i, z = Math.PI / 180, N = 180 / Math.PI, B = {}, F = { style: {} }, G = n.k.document || { createElement: function () { return F } }, U = function (e, t) { var i = G.createElementNS ? G.createElementNS(t || "http://www.w3.org/1999/xhtml", e) : G.createElement(e); return i.style ? i : G.createElement(e) }, H = U("div"), V = U("img"), j = a._internals = { _specialProps: o }, W = (n.k.navigator || {}).userAgent || "", $ = function () { var e = W.indexOf("Android"), t = U("a"); return u = -1 !== W.indexOf("Safari") && -1 === W.indexOf("Chrome") && (-1 === e || parseFloat(W.substr(e + 8, 2)) > 3), p = u && parseFloat(W.substr(W.indexOf("Version/") + 8, 2)) < 6, d = -1 !== W.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(W) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(W)) && (f = parseFloat(RegExp.$1)), !!t && (t.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(t.style.opacity)) }(), X = function (e) { return T.test("string" == typeof e ? e : (e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1 }, Y = function (e) { n.k.console && console.log(e) }, q = "", J = "", Z = function (e, t) { var i, n, r = (t = t || H).style; if (void 0 !== r[e]) return e; for (e = e.charAt(0).toUpperCase() + e.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; --n > -1 && void 0 === r[i[n] + e];); return n >= 0 ? (q = "-" + (J = 3 === n ? "ms" : i[n]).toLowerCase() + "-", J + e) : null }, K = "undefined" != typeof window ? window : G.defaultView || { getComputedStyle: function () { } }, Q = function (e) { return K.getComputedStyle(e) }, ee = a.getStyle = function (e, t, i, n, r) { var a; return $ || "opacity" !== t ? (!n && e.style[t] ? a = e.style[t] : (i = i || Q(e)) ? a = i[t] || i.getPropertyValue(t) || i.getPropertyValue(t.replace(C, "-$1").toLowerCase()) : e.currentStyle && (a = e.currentStyle[t]), null == r || a && "none" !== a && "auto" !== a && "auto auto" !== a ? a : r) : X(e) }, te = j.convertToPixels = function (e, t, i, r, s) { if ("px" === r || !r && "lineHeight" !== t) return i; if ("auto" === r || !i) return 0; var o, l, c, h = R.test(t), u = e, d = H.style, p = i < 0, f = 1 === i; if (p && (i = -i), f && (i *= 100), "lineHeight" !== t || r) if ("%" === r && -1 !== t.indexOf("border")) o = i / 100 * (h ? e.clientWidth : e.clientHeight); else { if (d.cssText = "border:0 solid red;position:" + ee(e, "position") + ";line-height:0;", "%" !== r && u.appendChild && "v" !== r.charAt(0) && "rem" !== r) d[h ? "borderLeftWidth" : "borderTopWidth"] = i + r; else { if (u = e.parentNode || G.body, -1 !== ee(u, "display").indexOf("flex") && (d.position = "absolute"), l = u._gsCache, c = n.l.ticker.frame, l && h && l.time === c) return l.width * i / 100; d[h ? "width" : "height"] = i + r } u.appendChild(H), o = parseFloat(H[h ? "offsetWidth" : "offsetHeight"]), u.removeChild(H), h && "%" === r && !1 !== a.cacheWidths && ((l = u._gsCache = u._gsCache || {}).time = c, l.width = o / i * 100), 0 !== o || s || (o = te(e, t, i, r, !0)) } else l = Q(e).lineHeight, e.style.lineHeight = i, o = parseFloat(Q(e).lineHeight), e.style.lineHeight = l; return f && (o /= 100), p ? -o : o }, ie = j.calculateOffset = function (e, t, i) { if ("absolute" !== ee(e, "position", i)) return 0; var n = "left" === t ? "Left" : "Top", r = ee(e, "margin" + n, i); return e["offset" + n] - (te(e, t, parseFloat(r), r.replace(w, "")) || 0) }, ne = function (e, t) { var i, n, r, a = {}; if (t = t || Q(e)) if (i = t.length) for (; --i > -1;)-1 !== (r = t[i]).indexOf("-transform") && ke !== r || (a[r.replace(A, L)] = t.getPropertyValue(r)); else for (i in t) -1 !== i.indexOf("Transform") && Ie !== i || (a[i] = t[i]); else if (t = e.currentStyle || e.style) for (i in t) "string" == typeof i && void 0 === a[i] && (a[i.replace(A, L)] = t[i]); return $ || (a.opacity = X(e)), n = Xe(e, t, !1), a.rotation = n.rotation, a.skewX = n.skewX, a.scaleX = n.scaleX, a.scaleY = n.scaleY, a.x = n.x, a.y = n.y, ze && (a.z = n.z, a.rotationX = n.rotationX, a.rotationY = n.rotationY, a.scaleZ = n.scaleZ), a.filters && delete a.filters, a }, re = function (e, t, i, n, r) { var a, s, o, l = {}, c = e.style; for (s in i) "cssText" !== s && "length" !== s && isNaN(s) && (t[s] !== (a = i[s]) || r && r[s]) && -1 === s.indexOf("Origin") && ("number" != typeof a && "string" != typeof a || (l[s] = "auto" !== a || "left" !== s && "top" !== s ? "" !== a && "auto" !== a && "none" !== a || "string" != typeof t[s] || "" === t[s].replace(b, "") ? a : 0 : ie(e, s), void 0 !== c[s] && (o = new _e(c, s, c[s], o)))); if (n) for (s in n) "className" !== s && (l[s] = n[s]); return { difs: l, firstMPT: o } }, ae = { width: ["Left", "Right"], height: ["Top", "Bottom"] }, se = ["marginLeft", "marginRight", "marginTop", "marginBottom"], oe = function (e, t, i) { if ("svg" === (e.nodeName + "").toLowerCase()) return (i || Q(e))[t] || 0; if (e.getCTM && je(e)) return e.getBBox()[t] || 0; var n = parseFloat("width" === t ? e.offsetWidth : e.offsetHeight), r = ae[t], a = r.length; for (i = i || Q(e); --a > -1;)n -= parseFloat(ee(e, "padding" + r[a], i, !0)) || 0, n -= parseFloat(ee(e, "border" + r[a] + "Width", i, !0)) || 0; return n }, le = function (e, t) { if ("contain" === e || "auto" === e || "auto auto" === e) return e + " "; null != e && "" !== e || (e = "0 0"); var i, n = e.split(" "), r = -1 !== e.indexOf("left") ? "0%" : -1 !== e.indexOf("right") ? "100%" : n[0], a = -1 !== e.indexOf("top") ? "0%" : -1 !== e.indexOf("bottom") ? "100%" : n[1]; if (n.length > 3 && !t) { for (n = e.split(", ").join(",").split(","), e = [], i = 0; i < n.length; i++)e.push(le(n[i])); return e.join(",") } return null == a ? a = "center" === r ? "50%" : "0" : "center" === a && (a = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), e = r + " " + a + (n.length > 2 ? " " + n[2] : ""), t && (t.oxp = -1 !== r.indexOf("%"), t.oyp = -1 !== a.indexOf("%"), t.oxr = "=" === r.charAt(1), t.oyr = "=" === a.charAt(1), t.ox = parseFloat(r.replace(b, "")), t.oy = parseFloat(a.replace(b, "")), t.v = e), t || e }, ce = function (e, t) { return "function" == typeof e && (e = e(g, m)), "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(t) || 0 }, he = function (e, t) { "function" == typeof e && (e = e(g, m)); var i = "string" == typeof e && "=" === e.charAt(1); return "string" == typeof e && "v" === e.charAt(e.length - 2) && (e = (i ? e.substr(0, 2) : 0) + window["inner" + ("vh" === e.substr(-2) ? "Height" : "Width")] * (parseFloat(i ? e.substr(2) : e) / 100)), null == e ? t : i ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) + t : parseFloat(e) || 0 }, ue = function (e, t, i, n) { var r, a, s, o; return "function" == typeof e && (e = e(g, m)), null == e ? s = t : "number" == typeof e ? s = e : (360, r = e.split("_"), a = ((o = "=" === e.charAt(1)) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(r[0].substr(2)) : parseFloat(r[0])) * (-1 === e.indexOf("rad") ? 1 : N) - (o ? 0 : t), r.length && (n && (n[i] = t + a), -1 !== e.indexOf("short") && (a %= 360) !== a % 180 && (a = a < 0 ? a + 360 : a - 360), -1 !== e.indexOf("_cw") && a < 0 ? a = (a + 3599999999640) % 360 - 360 * (a / 360 | 0) : -1 !== e.indexOf("ccw") && a > 0 && (a = (a - 3599999999640) % 360 - 360 * (a / 360 | 0))), s = t + a), s < 1e-6 && s > -1e-6 && (s = 0), s }, de = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], fuchsia: [255, 0, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] }, pe = function (e, t, i) { return 255 * (6 * (e = e < 0 ? e + 1 : e > 1 ? e - 1 : e) < 1 ? t + (i - t) * e * 6 : e < .5 ? i : 3 * e < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) + .5 | 0 }, fe = a.parseColor = function (e, t) { var i, n, r, a, s, o, l, c, h, u, d; if (e) if ("number" == typeof e) i = [e >> 16, e >> 8 & 255, 255 & e]; else { if ("," === e.charAt(e.length - 1) && (e = e.substr(0, e.length - 1)), de[e]) i = de[e]; else if ("#" === e.charAt(0)) 4 === e.length && (n = e.charAt(1), r = e.charAt(2), a = e.charAt(3), e = "#" + n + n + r + r + a + a), i = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & 255, 255 & e]; else if ("hsl" === e.substr(0, 3)) if (i = d = e.match(v), t) { if (-1 !== e.indexOf("=")) return e.match(y) } else s = Number(i[0]) % 360 / 360, o = Number(i[1]) / 100, n = 2 * (l = Number(i[2]) / 100) - (r = l <= .5 ? l * (o + 1) : l + o - l * o), i.length > 3 && (i[3] = Number(i[3])), i[0] = pe(s + 1 / 3, n, r), i[1] = pe(s, n, r), i[2] = pe(s - 1 / 3, n, r); else i = e.match(v) || de.transparent; i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3])) } else i = de.black; return t && !d && (n = i[0] / 255, r = i[1] / 255, a = i[2] / 255, l = ((c = Math.max(n, r, a)) + (h = Math.min(n, r, a))) / 2, c === h ? s = o = 0 : (u = c - h, o = l > .5 ? u / (2 - c - h) : u / (c + h), s = c === n ? (r - a) / u + (r < a ? 6 : 0) : c === r ? (a - n) / u + 2 : (n - r) / u + 4, s *= 60), i[0] = s + .5 | 0, i[1] = 100 * o + .5 | 0, i[2] = 100 * l + .5 | 0), i }, me = function (e, t) { var i, n, r, a = e.match(ge) || [], s = 0, o = ""; if (!a.length) return e; for (i = 0; i < a.length; i++)n = a[i], s += (r = e.substr(s, e.indexOf(n, s) - s)).length + n.length, 3 === (n = fe(n, t)).length && n.push(1), o += r + (t ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")"; return o + e.substr(s) }, ge = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; for (l in de) ge += "|" + l + "\\b"; ge = new RegExp(ge + ")", "gi"), a.colorStringFilter = function (e) { var t, i = e[0] + " " + e[1]; ge.test(i) && (t = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), e[0] = me(e[0], t), e[1] = me(e[1], t)), ge.lastIndex = 0 }, n.l.defaultStringFilter || (n.l.defaultStringFilter = a.colorStringFilter); var ve = function (e, t, i, n) { if (null == e) return function (e) { return e }; var r, a = t ? (e.match(ge) || [""])[0] : "", s = e.split(a).join("").match(_) || [], o = e.substr(0, e.indexOf(s[0])), l = ")" === e.charAt(e.length - 1) ? ")" : "", c = -1 !== e.indexOf(" ") ? " " : ",", h = s.length, u = h > 0 ? s[0].replace(v, "") : ""; return h ? r = t ? function (e) { var t, d, p, f; if ("number" == typeof e) e += u; else if (n && k.test(e)) { for (f = e.replace(k, "|").split("|"), p = 0; p < f.length; p++)f[p] = r(f[p]); return f.join(",") } if (t = (e.match(ge) || [a])[0], p = (d = e.split(t).join("").match(_) || []).length, h > p--) for (; ++p < h;)d[p] = i ? d[(p - 1) / 2 | 0] : s[p]; return o + d.join(c) + c + t + l + (-1 !== e.indexOf("inset") ? " inset" : "") } : function (e) { var t, a, d; if ("number" == typeof e) e += u; else if (n && k.test(e)) { for (a = e.replace(k, "|").split("|"), d = 0; d < a.length; d++)a[d] = r(a[d]); return a.join(",") } if (d = (t = e.match("," === c ? _ : x) || []).length, h > d--) for (; ++d < h;)t[d] = i ? t[(d - 1) / 2 | 0] : s[d]; return (o && "none" !== e && e.substr(0, e.indexOf(t[0])) || o) + t.join(c) + l } : function (e) { return e } }, ye = function (e) { return e = e.split(","), function (t, i, n, r, a, s, o) { var l, c = (i + "").split(" "); for (o = {}, l = 0; l < 4; l++)o[e[l]] = c[l] = c[l] || c[(l - 1) / 2 >> 0]; return r.parse(t, o, a, s) } }, _e = (j._setPluginRatio = function (e) { this.plugin.setRatio(e); for (var t, i, n, r, a, s = this.data, o = s.proxy, l = s.firstMPT; l;)t = o[l.v], l.r ? t = l.r(t) : t < 1e-6 && t > -1e-6 && (t = 0), l.t[l.p] = t, l = l._next; if (s.autoRotate && (s.autoRotate.rotation = s.mod ? s.mod.call(this._tween, o.rotation, this.t, this._tween) : o.rotation), 1 === e || 0 === e) for (l = s.firstMPT, a = 1 === e ? "e" : "b"; l;) { if ((i = l.t).type) { if (1 === i.type) { for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++)r += i["xn" + n] + i["xs" + (n + 1)]; i[a] = r } } else i[a] = i.s + i.xs0; l = l._next } }, function (e, t, i, n, r) { this.t = e, this.p = t, this.v = i, this.r = r, n && (n._prev = this, this._next = n) }), xe = (j._parseToProxy = function (e, t, i, n, r, a) { var s, o, l, c, h, u = n, d = {}, p = {}, f = i._transform, m = B; for (i._transform = null, B = t, n = h = i.parse(e, t, n, r), B = m, a && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); n && n !== u;) { if (n.type <= 1 && (p[o = n.p] = n.s + n.c, d[o] = n.s, a || (c = new _e(n, "s", o, c, n.r), n.c = 0), 1 === n.type)) for (s = n.l; --s > 0;)l = "xn" + s, p[o = n.p + "_" + l] = n.data[l], d[o] = n[l], a || (c = new _e(n, l, o, c, n.rxp[l])); n = n._next } return { proxy: d, end: p, firstMPT: c, pt: h } }, j.CSSPropTween = function (t, i, n, a, s, o, l, c, h, u, d) { this.t = t, this.p = i, this.s = n, this.c = a, this.n = l || i, t instanceof xe || r.push(this.n), this.r = c ? "function" == typeof c ? c : Math.round : c, this.type = o || 0, h && (this.pr = h, e = !0), this.b = void 0 === u ? n : u, this.e = void 0 === d ? n + a : d, s && (this._next = s, s._prev = this) }), be = function (e, t, i, n, r, a) { var s = new xe(e, t, i, n - i, r, -1, a); return s.b = i, s.e = s.xs0 = n, s }, we = a.parseComplex = function (e, t, i, n, r, s, o, l, h, u) { i = i || s || "", "function" == typeof n && (n = n(g, m)), o = new xe(e, t, 0, 0, o, u ? 2 : 1, null, !1, l, i, n), n += "", r && ge.test(n + i) && (n = [i, n], a.colorStringFilter(n), i = n[0], n = n[1]); var d, p, f, _, x, b, w, T, M, S, E, C, A, P = i.split(", ").join(",").split(" "), L = n.split(", ").join(",").split(" "), R = P.length, O = !1 !== c; for (-1 === n.indexOf(",") && -1 === i.indexOf(",") || (-1 !== (n + i).indexOf("rgb") || -1 !== (n + i).indexOf("hsl") ? (P = P.join(" ").replace(k, ", ").split(" "), L = L.join(" ").replace(k, ", ").split(" ")) : (P = P.join(" ").split(",").join(", ").split(" "), L = L.join(" ").split(",").join(", ").split(" ")), R = P.length), R !== L.length && (R = (P = (s || "").split(" ")).length), o.plugin = h, o.setRatio = u, ge.lastIndex = 0, d = 0; d < R; d++)if (_ = P[d], x = L[d] + "", (T = parseFloat(_)) || 0 === T) o.appendXtra("", T, ce(x, T), x.replace(y, ""), !(!O || -1 === x.indexOf("px")) && Math.round, !0); else if (r && ge.test(_)) C = ")" + ((C = x.indexOf(")") + 1) ? x.substr(C) : ""), A = -1 !== x.indexOf("hsl") && $, S = x, _ = fe(_, A), x = fe(x, A), (M = _.length + x.length > 6) && !$ && 0 === x[3] ? (o["xs" + o.l] += o.l ? " transparent" : "transparent", o.e = o.e.split(L[d]).join("transparent")) : ($ || (M = !1), A ? o.appendXtra(S.substr(0, S.indexOf("hsl")) + (M ? "hsla(" : "hsl("), _[0], ce(x[0], _[0]), ",", !1, !0).appendXtra("", _[1], ce(x[1], _[1]), "%,", !1).appendXtra("", _[2], ce(x[2], _[2]), M ? "%," : "%" + C, !1) : o.appendXtra(S.substr(0, S.indexOf("rgb")) + (M ? "rgba(" : "rgb("), _[0], x[0] - _[0], ",", Math.round, !0).appendXtra("", _[1], x[1] - _[1], ",", Math.round).appendXtra("", _[2], x[2] - _[2], M ? "," : C, Math.round), M && (_ = _.length < 4 ? 1 : _[3], o.appendXtra("", _, (x.length < 4 ? 1 : x[3]) - _, C, !1))), ge.lastIndex = 0; else if (b = _.match(v)) { if (!(w = x.match(y)) || w.length !== b.length) return o; for (f = 0, p = 0; p < b.length; p++)E = b[p], S = _.indexOf(E, f), o.appendXtra(_.substr(f, S - f), Number(E), ce(w[p], E), "", !(!O || "px" !== _.substr(S + E.length, 2)) && Math.round, 0 === p), f = S + E.length; o["xs" + o.l] += _.substr(f) } else o["xs" + o.l] += o.l || o["xs" + o.l] ? " " + x : x; if (-1 !== n.indexOf("=") && o.data) { for (C = o.xs0 + o.data.s, d = 1; d < o.l; d++)C += o["xs" + d] + o.data["xn" + d]; o.e = C + o["xs" + d] } return o.l || (o.type = -1, o.xs0 = o.e), o.xfirst || o }, Te = 9; for ((l = xe.prototype).l = l.pr = 0; --Te > 0;)l["xn" + Te] = 0, l["xs" + Te] = ""; l.xs0 = "", l._next = l._prev = l.xfirst = l.data = l.plugin = l.setRatio = l.rxp = null, l.appendXtra = function (e, t, i, n, r, a) { var s = this, o = s.l; return s["xs" + o] += a && (o || s["xs" + o]) ? " " + e : e || "", i || 0 === o || s.plugin ? (s.l++, s.type = s.setRatio ? 2 : 1, s["xs" + s.l] = n || "", o > 0 ? (s.data["xn" + o] = t + i, s.rxp["xn" + o] = r, s["xn" + o] = t, s.plugin || (s.xfirst = new xe(s, "xn" + o, t, i, s.xfirst || s, 0, s.n, r, s.pr), s.xfirst.xs0 = 0), s) : (s.data = { s: t + i }, s.rxp = {}, s.s = t, s.c = i, s.r = r, s)) : (s["xs" + o] += t + (n || ""), s) }; var Me = function (e, t) { t = t || {}, this.p = t.prefix && Z(e) || e, o[e] = o[this.p] = this, this.format = t.formatter || ve(t.defaultValue, t.color, t.collapsible, t.multi), t.parser && (this.parse = t.parser), this.clrs = t.color, this.multi = t.multi, this.keyword = t.keyword, this.dflt = t.defaultValue, this.allowFunc = t.allowFunc, this.pr = t.priority || 0 }, Se = j._registerComplexSpecialProp = function (e, t, i) { "object" != typeof t && (t = { parser: i }); var n, r = e.split(","), a = t.defaultValue; for (i = i || [a], n = 0; n < r.length; n++)t.prefix = 0 === n && t.prefix, t.defaultValue = i[n] || a, new Me(r[n], t) }, Ee = j._registerPluginProp = function (e) { if (!o[e]) { var t = e.charAt(0).toUpperCase() + e.substr(1) + "Plugin"; Se(e, { parser: function (e, i, n, r, a, l, c) { var h = s.com.greensock.plugins[t]; return h ? (h._cssRegister(), o[n].parse(e, i, n, r, a, l, c)) : (Y("Error: " + t + " js file not loaded."), a) } }) } }; (l = Me.prototype).parseComplex = function (e, t, i, n, r, a) { var s, o, l, c, h, u, d = this.keyword; if (this.multi && (k.test(i) || k.test(t) ? (o = t.replace(k, "|").split("|"), l = i.replace(k, "|").split("|")) : d && (o = [t], l = [i])), l) { for (c = l.length > o.length ? l.length : o.length, s = 0; s < c; s++)t = o[s] = o[s] || this.dflt, i = l[s] = l[s] || this.dflt, d && (h = t.indexOf(d)) !== (u = i.indexOf(d)) && (-1 === u ? o[s] = o[s].split(d).join("") : -1 === h && (o[s] += " " + d)); t = o.join(", "), i = l.join(", ") } return we(e, this.p, t, i, this.clrs, this.dflt, n, this.pr, r, a) }, l.parse = function (e, t, n, r, a, s, o) { return this.parseComplex(e.style, this.format(ee(e, this.p, i, !1, this.dflt)), this.format(t), a, s) }, a.registerSpecialProp = function (e, t, i) { Se(e, { parser: function (e, n, r, a, s, o, l) { var c = new xe(e, r, 0, 0, s, 2, r, !1, i); return c.plugin = o, c.setRatio = t(e, n, a._tween, r), c }, priority: i }) }, a.useSVGTransformAttr = !0; var Ce, Ae, Pe, Le, Re, Oe = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","), Ie = Z("transform"), ke = q + "transform", De = Z("transformOrigin"), ze = null !== Z("perspective"), Ne = j.Transform = function () { this.perspective = parseFloat(a.defaultTransformPerspective) || 0, this.force3D = !(!1 === a.defaultForce3D || !ze) && (a.defaultForce3D || "auto") }, Be = n.k.SVGElement, Fe = function (e, t, i) { var n, r = G.createElementNS("http://www.w3.org/2000/svg", e), a = /([a-z])([A-Z])/g; for (n in i) r.setAttributeNS(null, n.replace(a, "$1-$2").toLowerCase(), i[n]); return t.appendChild(r), r }, Ge = G.documentElement || {}, Ue = (Re = f || /Android/i.test(W) && !n.k.chrome, G.createElementNS && Ge.appendChild && !Re && (Ae = Fe("svg", Ge), Le = (Pe = Fe("rect", Ae, { width: 100, height: 50, x: 100 })).getBoundingClientRect().width, Pe.style[De] = "50% 50%", Pe.style[Ie] = "scaleX(0.5)", Re = Le === Pe.getBoundingClientRect().width && !(d && ze), Ge.removeChild(Ae)), Re), He = function (e, t, i, n, r, s) { var o, l, c, h, u, d, p, f, m, g, v, y, _, x, b = e._gsTransform, w = $e(e, !0); b && (_ = b.xOrigin, x = b.yOrigin), (!n || (o = n.split(" ")).length < 2) && (0 === (p = e.getBBox()).x && 0 === p.y && p.width + p.height === 0 && (p = { x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0, y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0, width: 0, height: 0 }), o = [(-1 !== (t = le(t).split(" "))[0].indexOf("%") ? parseFloat(t[0]) / 100 * p.width : parseFloat(t[0])) + p.x, (-1 !== t[1].indexOf("%") ? parseFloat(t[1]) / 100 * p.height : parseFloat(t[1])) + p.y]), i.xOrigin = h = parseFloat(o[0]), i.yOrigin = u = parseFloat(o[1]), n && w !== We && (d = w[0], p = w[1], f = w[2], m = w[3], g = w[4], v = w[5], (y = d * m - p * f) && (l = h * (m / y) + u * (-f / y) + (f * v - m * g) / y, c = h * (-p / y) + u * (d / y) - (d * v - p * g) / y, h = i.xOrigin = o[0] = l, u = i.yOrigin = o[1] = c)), b && (s && (i.xOffset = b.xOffset, i.yOffset = b.yOffset, b = i), r || !1 !== r && !1 !== a.defaultSmoothOrigin ? (l = h - _, c = u - x, b.xOffset += l * w[0] + c * w[2] - l, b.yOffset += l * w[1] + c * w[3] - c) : b.xOffset = b.yOffset = 0), s || e.setAttribute("data-svg-origin", o.join(" ")) }, Ve = function (e) { var t, i = U("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), n = this.parentNode, r = this.nextSibling, a = this.style.cssText; if (Ge.appendChild(i), i.appendChild(this), this.style.display = "block", e) try { t = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Ve } catch (e) { } else this._originalGetBBox && (t = this._originalGetBBox()); return r ? n.insertBefore(this, r) : n.appendChild(this), Ge.removeChild(i), this.style.cssText = a, t }, je = function (e) { return !(!Be || !e.getCTM || e.parentNode && !e.ownerSVGElement || !function (e) { try { return e.getBBox() } catch (t) { return Ve.call(e, !0) } }(e)) }, We = [1, 0, 0, 1, 0, 0], $e = function (e, t) { var i, n, r, a, s, o, l, c = e._gsTransform || new Ne, h = e.style; if (Ie ? n = ee(e, ke, null, !0) : e.currentStyle && (n = (n = e.currentStyle.filter.match(O)) && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), c.x || 0, c.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, Ie && i && !e.offsetParent && e !== Ge && (a = h.display, h.display = "block", (l = e.parentNode) && e.offsetParent || (s = 1, o = e.nextSibling, Ge.appendChild(e)), i = !(n = ee(e, ke, null, !0)) || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, a ? h.display = a : Ze(h, "display"), s && (o ? l.insertBefore(e, o) : l ? l.appendChild(e) : Ge.removeChild(e))), (c.svg || e.getCTM && je(e)) && (i && -1 !== (h[Ie] + "").indexOf("matrix") && (n = h[Ie], i = 0), r = e.getAttribute("transform"), i && r && (n = "matrix(" + (r = e.transform.baseVal.consolidate().matrix).a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", i = 0)), i) return We; for (r = (n || "").match(v) || [], Te = r.length; --Te > -1;)a = Number(r[Te]), r[Te] = (s = a - (a |= 0)) ? (1e5 * s + (s < 0 ? -.5 : .5) | 0) / 1e5 + a : a; return t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r }, Xe = j.getTransform = function (e, t, i, r) { if (e._gsTransform && i && !r) return e._gsTransform; var s, o, l, c, h, u, d = i && e._gsTransform || new Ne, p = d.scaleX < 0, f = 1e5, m = ze && (parseFloat(ee(e, De, t, !1, "0 0 0").split(" ")[2]) || d.zOrigin) || 0, g = parseFloat(a.defaultTransformPerspective) || 0; if (d.svg = !(!e.getCTM || !je(e)), d.svg && (He(e, ee(e, De, t, !1, "50% 50%") + "", d, e.getAttribute("data-svg-origin")), Ce = a.useSVGTransformAttr || Ue), (s = $e(e)) !== We) { if (16 === s.length) { var v, y, _, x, b, w = s[0], T = s[1], M = s[2], S = s[3], E = s[4], C = s[5], A = s[6], P = s[7], L = s[8], R = s[9], O = s[10], I = s[12], k = s[13], D = s[14], z = s[11], B = Math.atan2(A, O); d.zOrigin && (I = L * (D = -d.zOrigin) - s[12], k = R * D - s[13], D = O * D + d.zOrigin - s[14]), d.rotationX = B * N, B && (v = E * (x = Math.cos(-B)) + L * (b = Math.sin(-B)), y = C * x + R * b, _ = A * x + O * b, L = E * -b + L * x, R = C * -b + R * x, O = A * -b + O * x, z = P * -b + z * x, E = v, C = y, A = _), B = Math.atan2(-M, O), d.rotationY = B * N, B && (y = T * (x = Math.cos(-B)) - R * (b = Math.sin(-B)), _ = M * x - O * b, R = T * b + R * x, O = M * b + O * x, z = S * b + z * x, w = v = w * x - L * b, T = y, M = _), B = Math.atan2(T, w), d.rotation = B * N, B && (v = w * (x = Math.cos(B)) + T * (b = Math.sin(B)), y = E * x + C * b, _ = L * x + R * b, T = T * x - w * b, C = C * x - E * b, R = R * x - L * b, w = v, E = y, L = _), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY = 180 - d.rotationY), B = Math.atan2(E, C), d.scaleX = (Math.sqrt(w * w + T * T + M * M) * f + .5 | 0) / f, d.scaleY = (Math.sqrt(C * C + A * A) * f + .5 | 0) / f, d.scaleZ = (Math.sqrt(L * L + R * R + O * O) * f + .5 | 0) / f, w /= d.scaleX, E /= d.scaleY, T /= d.scaleX, C /= d.scaleY, Math.abs(B) > 2e-5 ? (d.skewX = B * N, E = 0, "simple" !== d.skewType && (d.scaleY *= 1 / Math.cos(B))) : d.skewX = 0, d.perspective = z ? 1 / (z < 0 ? -z : z) : 0, d.x = I, d.y = k, d.z = D, d.svg && (d.x -= d.xOrigin - (d.xOrigin * w - d.yOrigin * E), d.y -= d.yOrigin - (d.yOrigin * T - d.xOrigin * C)) } else if (!ze || r || !s.length || d.x !== s[4] || d.y !== s[5] || !d.rotationX && !d.rotationY) { var F = s.length >= 6, G = F ? s[0] : 1, U = s[1] || 0, H = s[2] || 0, V = F ? s[3] : 1; d.x = s[4] || 0, d.y = s[5] || 0, l = Math.sqrt(G * G + U * U), c = Math.sqrt(V * V + H * H), h = G || U ? Math.atan2(U, G) * N : d.rotation || 0, u = H || V ? Math.atan2(H, V) * N + h : d.skewX || 0, d.scaleX = l, d.scaleY = c, d.rotation = h, d.skewX = u, ze && (d.rotationX = d.rotationY = d.z = 0, d.perspective = g, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * G + d.yOrigin * H), d.y -= d.yOrigin - (d.xOrigin * U + d.yOrigin * V)) } for (o in Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (p ? (d.scaleX *= -1, d.skewX += d.rotation <= 0 ? 180 : -180, d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1, d.skewX += d.skewX <= 0 ? 180 : -180)), d.zOrigin = m, d) d[o] < 2e-5 && d[o] > -2e-5 && (d[o] = 0) } return i && (e._gsTransform = d, d.svg && (Ce && e.style[Ie] ? n.l.delayedCall(.001, (function () { Ze(e.style, Ie) })) : !Ce && e.getAttribute("transform") && n.l.delayedCall(.001, (function () { e.removeAttribute("transform") })))), d }, Ye = function (e) { var t, i, n = this.data, r = -n.rotation * z, a = r + n.skewX * z, s = 1e5, o = (Math.cos(r) * n.scaleX * s | 0) / s, l = (Math.sin(r) * n.scaleX * s | 0) / s, c = (Math.sin(a) * -n.scaleY * s | 0) / s, h = (Math.cos(a) * n.scaleY * s | 0) / s, u = this.t.style, d = this.t.currentStyle; if (d) { i = l, l = -c, c = -i, t = d.filter, u.filter = ""; var p, m, g = this.t.offsetWidth, v = this.t.offsetHeight, y = "absolute" !== d.position, _ = "progid:DXImageTransform.Microsoft.Matrix(M11=" + o + ", M12=" + l + ", M21=" + c + ", M22=" + h, x = n.x + g * n.xPercent / 100, b = n.y + v * n.yPercent / 100; if (null != n.ox && (x += (p = (n.oxp ? g * n.ox * .01 : n.ox) - g / 2) - (p * o + (m = (n.oyp ? v * n.oy * .01 : n.oy) - v / 2) * l), b += m - (p * c + m * h)), _ += y ? ", Dx=" + ((p = g / 2) - (p * o + (m = v / 2) * l) + x) + ", Dy=" + (m - (p * c + m * h) + b) + ")" : ", sizingMethod='auto expand')", -1 !== t.indexOf("DXImageTransform.Microsoft.Matrix(") ? u.filter = t.replace(I, _) : u.filter = _ + " " + t, 0 !== e && 1 !== e || 1 === o && 0 === l && 0 === c && 1 === h && (y && -1 === _.indexOf("Dx=0, Dy=0") || T.test(t) && 100 !== parseFloat(RegExp.$1) || -1 === t.indexOf(t.indexOf("Alpha")) && u.removeAttribute("filter")), !y) { var M, S, E, C = f < 8 ? 1 : -1; for (p = n.ieOffsetX || 0, m = n.ieOffsetY || 0, n.ieOffsetX = Math.round((g - ((o < 0 ? -o : o) * g + (l < 0 ? -l : l) * v)) / 2 + x), n.ieOffsetY = Math.round((v - ((h < 0 ? -h : h) * v + (c < 0 ? -c : c) * g)) / 2 + b), Te = 0; Te < 4; Te++)E = (i = -1 !== (M = d[S = se[Te]]).indexOf("px") ? parseFloat(M) : te(this.t, S, parseFloat(M), M.replace(w, "")) || 0) !== n[S] ? Te < 2 ? -n.ieOffsetX : -n.ieOffsetY : Te < 2 ? p - n.ieOffsetX : m - n.ieOffsetY, u[S] = (n[S] = Math.round(i - E * (0 === Te || 2 === Te ? 1 : C))) + "px" } } }, qe = j.set3DTransformRatio = j.setTransformRatio = function (e) { var t, i, n, r, a, s, o, l, c, h, u, p, f, m, g, v, y, _, x, b, w, T = this.data, M = this.t.style, S = T.rotation, E = T.rotationX, C = T.rotationY, A = T.scaleX, P = T.scaleY, L = T.scaleZ, R = T.x, O = T.y, I = T.z, k = T.svg, D = T.perspective, N = T.force3D, B = T.skewY, F = T.skewX; if (B && (F += B, S += B), !((1 !== e && 0 !== e || "auto" !== N || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && N || I || D || C || E || 1 !== L) || Ce && k || !ze) S || F || k ? (S *= z, b = F * z, w = 1e5, i = Math.cos(S) * A, a = Math.sin(S) * A, n = Math.sin(S - b) * -P, s = Math.cos(S - b) * P, b && "simple" === T.skewType && (t = Math.tan(b - B * z), n *= t = Math.sqrt(1 + t * t), s *= t, B && (t = Math.tan(B * z), i *= t = Math.sqrt(1 + t * t), a *= t)), k && (R += T.xOrigin - (T.xOrigin * i + T.yOrigin * n) + T.xOffset, O += T.yOrigin - (T.xOrigin * a + T.yOrigin * s) + T.yOffset, Ce && (T.xPercent || T.yPercent) && (g = this.t.getBBox(), R += .01 * T.xPercent * g.width, O += .01 * T.yPercent * g.height), R < (g = 1e-6) && R > -g && (R = 0), O < g && O > -g && (O = 0)), x = (i * w | 0) / w + "," + (a * w | 0) / w + "," + (n * w | 0) / w + "," + (s * w | 0) / w + "," + R + "," + O + ")", k && Ce ? this.t.setAttribute("transform", "matrix(" + x) : M[Ie] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix(" : "matrix(") + x) : M[Ie] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix(" : "matrix(") + A + ",0,0," + P + "," + R + "," + O + ")"; else { if (d && (A < (g = 1e-4) && A > -g && (A = L = 2e-5), P < g && P > -g && (P = L = 2e-5), !D || T.z || T.rotationX || T.rotationY || (D = 0)), S || F) S *= z, v = i = Math.cos(S), y = a = Math.sin(S), F && (S -= F * z, v = Math.cos(S), y = Math.sin(S), "simple" === T.skewType && (t = Math.tan((F - B) * z), v *= t = Math.sqrt(1 + t * t), y *= t, T.skewY && (t = Math.tan(B * z), i *= t = Math.sqrt(1 + t * t), a *= t))), n = -y, s = v; else { if (!(C || E || 1 !== L || D || k)) return void (M[Ie] = (T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) translate3d(" : "translate3d(") + R + "px," + O + "px," + I + "px)" + (1 !== A || 1 !== P ? " scale(" + A + "," + P + ")" : "")); i = s = 1, n = a = 0 } h = 1, r = o = l = c = u = p = 0, f = D ? -1 / D : 0, m = T.zOrigin, g = 1e-6, ",", "0", (S = C * z) && (v = Math.cos(S), l = -(y = Math.sin(S)), u = f * -y, r = i * y, o = a * y, h = v, f *= v, i *= v, a *= v), (S = E * z) && (t = n * (v = Math.cos(S)) + r * (y = Math.sin(S)), _ = s * v + o * y, c = h * y, p = f * y, r = n * -y + r * v, o = s * -y + o * v, h *= v, f *= v, n = t, s = _), 1 !== L && (r *= L, o *= L, h *= L, f *= L), 1 !== P && (n *= P, s *= P, c *= P, p *= P), 1 !== A && (i *= A, a *= A, l *= A, u *= A), (m || k) && (m && (R += r * -m, O += o * -m, I += h * -m + m), k && (R += T.xOrigin - (T.xOrigin * i + T.yOrigin * n) + T.xOffset, O += T.yOrigin - (T.xOrigin * a + T.yOrigin * s) + T.yOffset), R < g && R > -g && (R = "0"), O < g && O > -g && (O = "0"), I < g && I > -g && (I = 0)), x = T.xPercent || T.yPercent ? "translate(" + T.xPercent + "%," + T.yPercent + "%) matrix3d(" : "matrix3d(", x += (i < g && i > -g ? "0" : i) + "," + (a < g && a > -g ? "0" : a) + "," + (l < g && l > -g ? "0" : l), x += "," + (u < g && u > -g ? "0" : u) + "," + (n < g && n > -g ? "0" : n) + "," + (s < g && s > -g ? "0" : s), E || C || 1 !== L ? (x += "," + (c < g && c > -g ? "0" : c) + "," + (p < g && p > -g ? "0" : p) + "," + (r < g && r > -g ? "0" : r), x += "," + (o < g && o > -g ? "0" : o) + "," + (h < g && h > -g ? "0" : h) + "," + (f < g && f > -g ? "0" : f) + ",") : x += ",0,0,0,0,1,0,", x += R + "," + O + "," + I + "," + (D ? 1 + -I / D : 1) + ")", M[Ie] = x } }; (l = Ne.prototype).x = l.y = l.z = l.skewX = l.skewY = l.rotation = l.rotationX = l.rotationY = l.zOrigin = l.xPercent = l.yPercent = l.xOffset = l.yOffset = 0, l.scaleX = l.scaleY = l.scaleZ = 1, Se("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", { parser: function (e, t, n, r, s, o, l) { if (r._lastParsedTransform === l) return s; r._lastParsedTransform = l; var c = l.scale && "function" == typeof l.scale ? l.scale : 0; c && (l.scale = c(g, e)); var h, u, d, p, f, v, y, _, x, b = e._gsTransform, w = e.style, T = Oe.length, M = l, S = {}, E = Xe(e, i, !0, M.parseTransform), C = M.transform && ("function" == typeof M.transform ? M.transform(g, m) : M.transform); if (E.skewType = M.skewType || E.skewType || a.defaultSkewType, r._transform = E, "rotationZ" in M && (M.rotation = M.rotationZ), C && "string" == typeof C && Ie) (u = H.style)[Ie] = C, u.display = "block", u.position = "absolute", -1 !== C.indexOf("%") && (u.width = ee(e, "width"), u.height = ee(e, "height")), G.body.appendChild(H), h = Xe(H, null, !1), "simple" === E.skewType && (h.scaleY *= Math.cos(h.skewX * z)), E.svg && (v = E.xOrigin, y = E.yOrigin, h.x -= E.xOffset, h.y -= E.yOffset, (M.transformOrigin || M.svgOrigin) && (C = {}, He(e, le(M.transformOrigin), C, M.svgOrigin, M.smoothOrigin, !0), v = C.xOrigin, y = C.yOrigin, h.x -= C.xOffset - E.xOffset, h.y -= C.yOffset - E.yOffset), (v || y) && (_ = $e(H, !0), h.x -= v - (v * _[0] + y * _[2]), h.y -= y - (v * _[1] + y * _[3]))), G.body.removeChild(H), h.perspective || (h.perspective = E.perspective), null != M.xPercent && (h.xPercent = he(M.xPercent, E.xPercent)), null != M.yPercent && (h.yPercent = he(M.yPercent, E.yPercent)); else if ("object" == typeof M) { if (h = { scaleX: he(null != M.scaleX ? M.scaleX : M.scale, E.scaleX), scaleY: he(null != M.scaleY ? M.scaleY : M.scale, E.scaleY), scaleZ: he(M.scaleZ, E.scaleZ), x: he(M.x, E.x), y: he(M.y, E.y), z: he(M.z, E.z), xPercent: he(M.xPercent, E.xPercent), yPercent: he(M.yPercent, E.yPercent), perspective: he(M.transformPerspective, E.perspective) }, null != (f = M.directionalRotation)) if ("object" == typeof f) for (u in f) M[u] = f[u]; else M.rotation = f; "string" == typeof M.x && -1 !== M.x.indexOf("%") && (h.x = 0, h.xPercent = he(M.x, E.xPercent)), "string" == typeof M.y && -1 !== M.y.indexOf("%") && (h.y = 0, h.yPercent = he(M.y, E.yPercent)), h.rotation = ue("rotation" in M ? M.rotation : "shortRotation" in M ? M.shortRotation + "_short" : E.rotation, E.rotation, "rotation", S), ze && (h.rotationX = ue("rotationX" in M ? M.rotationX : "shortRotationX" in M ? M.shortRotationX + "_short" : E.rotationX || 0, E.rotationX, "rotationX", S), h.rotationY = ue("rotationY" in M ? M.rotationY : "shortRotationY" in M ? M.shortRotationY + "_short" : E.rotationY || 0, E.rotationY, "rotationY", S)), h.skewX = ue(M.skewX, E.skewX), h.skewY = ue(M.skewY, E.skewY) } for (ze && null != M.force3D && (E.force3D = M.force3D, p = !0), (d = E.force3D || E.z || E.rotationX || E.rotationY || h.z || h.rotationX || h.rotationY || h.perspective) || null == M.scale || (h.scaleZ = 1); --T > -1;)((C = h[x = Oe[T]] - E[x]) > 1e-6 || C < -1e-6 || null != M[x] || null != B[x]) && (p = !0, s = new xe(E, x, E[x], C, s), x in S && (s.e = S[x]), s.xs0 = 0, s.plugin = o, r._overwriteProps.push(s.n)); return C = "function" == typeof M.transformOrigin ? M.transformOrigin(g, m) : M.transformOrigin, E.svg && (C || M.svgOrigin) && (v = E.xOffset, y = E.yOffset, He(e, le(C), h, M.svgOrigin, M.smoothOrigin), s = be(E, "xOrigin", (b ? E : h).xOrigin, h.xOrigin, s, "transformOrigin"), s = be(E, "yOrigin", (b ? E : h).yOrigin, h.yOrigin, s, "transformOrigin"), v === E.xOffset && y === E.yOffset || (s = be(E, "xOffset", b ? v : E.xOffset, E.xOffset, s, "transformOrigin"), s = be(E, "yOffset", b ? y : E.yOffset, E.yOffset, s, "transformOrigin")), C = "0px 0px"), (C || ze && d && E.zOrigin) && (Ie ? (p = !0, x = De, C || (C = (C = (ee(e, x, i, !1, "50% 50%") + "").split(" "))[0] + " " + C[1] + " " + E.zOrigin + "px"), C += "", (s = new xe(w, x, 0, 0, s, -1, "transformOrigin")).b = w[x], s.plugin = o, ze ? (u = E.zOrigin, C = C.split(" "), E.zOrigin = (C.length > 2 ? parseFloat(C[2]) : u) || 0, s.xs0 = s.e = C[0] + " " + (C[1] || "50%") + " 0px", (s = new xe(E, "zOrigin", 0, 0, s, -1, s.n)).b = u, s.xs0 = s.e = E.zOrigin) : s.xs0 = s.e = C) : le(C + "", E)), p && (r._transformType = E.svg && Ce || !d && 3 !== this._transformType ? 2 : 3), c && (l.scale = c), s }, allowFunc: !0, prefix: !0 }), Se("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: !0, color: !0, multi: !0, keyword: "inset" }), Se("clipPath", { defaultValue: "inset(0%)", prefix: !0, multi: !0, formatter: ve("inset(0% 0% 0% 0%)", !1, !0) }), Se("borderRadius", { defaultValue: "0px", parser: function (e, n, r, a, s, o) { n = this.format(n); var l, c, h, u, d, p, f, m, g, v, y, _, x, b, w, T, M = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"], S = e.style; for (g = parseFloat(e.offsetWidth), v = parseFloat(e.offsetHeight), l = n.split(" "), c = 0; c < M.length; c++)this.p.indexOf("border") && (M[c] = Z(M[c])), -1 !== (d = u = ee(e, M[c], i, !1, "0px")).indexOf(" ") && (u = d.split(" "), d = u[0], u = u[1]), p = h = l[c], f = parseFloat(d), _ = d.substr((f + "").length), (x = "=" === p.charAt(1)) ? (m = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), m *= parseFloat(p), y = p.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(p), y = p.substr((m + "").length)), "" === y && (y = t[r] || _), y !== _ && (b = te(e, "borderLeft", f, _), w = te(e, "borderTop", f, _), "%" === y ? (d = b / g * 100 + "%", u = w / v * 100 + "%") : "em" === y ? (d = b / (T = te(e, "borderLeft", 1, "em")) + "em", u = w / T + "em") : (d = b + "px", u = w + "px"), x && (p = parseFloat(d) + m + y, h = parseFloat(u) + m + y)), s = we(S, M[c], d + " " + u, p + " " + h, !1, "0px", s); return s }, prefix: !0, formatter: ve("0px 0px 0px 0px", !1, !0) }), Se("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", { defaultValue: "0px", parser: function (e, t, n, r, a, s) { return we(e.style, n, this.format(ee(e, n, i, !1, "0px 0px")), this.format(t), !1, "0px", a) }, prefix: !0, formatter: ve("0px 0px", !1, !0) }), Se("backgroundPosition", { defaultValue: "0 0", parser: function (e, t, n, r, a, s) { var o, l, c, h, u, d, p = "background-position", m = i || Q(e), g = this.format((m ? f ? m.getPropertyValue(p + "-x") + " " + m.getPropertyValue(p + "-y") : m.getPropertyValue(p) : e.currentStyle.backgroundPositionX + " " + e.currentStyle.backgroundPositionY) || "0 0"), v = this.format(t); if (-1 !== g.indexOf("%") != (-1 !== v.indexOf("%")) && v.split(",").length < 2 && (d = ee(e, "backgroundImage").replace(P, "")) && "none" !== d) { for (o = g.split(" "), l = v.split(" "), V.setAttribute("src", d), c = 2; --c > -1;)(h = -1 !== (g = o[c]).indexOf("%")) !== (-1 !== l[c].indexOf("%")) && (u = 0 === c ? e.offsetWidth - V.width : e.offsetHeight - V.height, o[c] = h ? parseFloat(g) / 100 * u + "px" : parseFloat(g) / u * 100 + "%"); g = o.join(" ") } return this.parseComplex(e.style, g, v, a, s) }, formatter: le }), Se("backgroundSize", { defaultValue: "0 0", formatter: function (e) { return "co" === (e += "").substr(0, 2) ? e : le(-1 === e.indexOf(" ") ? e + " " + e : e) } }), Se("perspective", { defaultValue: "0px", prefix: !0 }), Se("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), Se("transformStyle", { prefix: !0 }), Se("backfaceVisibility", { prefix: !0 }), Se("userSelect", { prefix: !0 }), Se("margin", { parser: ye("marginTop,marginRight,marginBottom,marginLeft") }), Se("padding", { parser: ye("paddingTop,paddingRight,paddingBottom,paddingLeft") }), Se("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function (e, t, n, r, a, s) { var o, l, c; return f < 9 ? (l = e.currentStyle, c = f < 8 ? " " : ",", o = "rect(" + l.clipTop + c + l.clipRight + c + l.clipBottom + c + l.clipLeft + ")", t = this.format(t).split(",").join(c)) : (o = this.format(ee(e, this.p, i, !1, this.dflt)), t = this.format(t)), this.parseComplex(e.style, o, t, a, s) } }), Se("textShadow", { defaultValue: "0px 0px 0px #999", color: !0, multi: !0 }), Se("autoRound,strictUnits", { parser: function (e, t, i, n, r) { return r } }), Se("border", { defaultValue: "0px solid #000", parser: function (e, t, n, r, a, s) { var o = ee(e, "borderTopWidth", i, !1, "0px"), l = this.format(t).split(" "), c = l[0].replace(w, ""); return "px" !== c && (o = parseFloat(o) / te(e, "borderTopWidth", 1, c) + c), this.parseComplex(e.style, this.format(o + " " + ee(e, "borderTopStyle", i, !1, "solid") + " " + ee(e, "borderTopColor", i, !1, "#000")), l.join(" "), a, s) }, color: !0, formatter: function (e) { var t = e.split(" "); return t[0] + " " + (t[1] || "solid") + " " + (e.match(ge) || ["#000"])[0] } }), Se("borderWidth", { parser: ye("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }), Se("float,cssFloat,styleFloat", { parser: function (e, t, i, n, r, a) { var s = e.style, o = "cssFloat" in s ? "cssFloat" : "styleFloat"; return new xe(s, o, 0, 0, r, -1, i, !1, 0, s[o], t) } }); var Je = function (e) { var t, i = this.t, n = i.filter || ee(this.data, "filter") || "", r = this.s + this.c * e | 0; 100 === r && (-1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), t = !ee(this.data, "filter")) : (i.filter = n.replace(S, ""), t = !0)), t || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"), -1 === n.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(T, "opacity=" + r)) }; Se("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function (e, t, n, r, a, s) { var o = parseFloat(ee(e, "opacity", i, !1, "1")), l = e.style, c = "autoAlpha" === n; return "string" == typeof t && "=" === t.charAt(1) && (t = ("-" === t.charAt(0) ? -1 : 1) * parseFloat(t.substr(2)) + o), c && 1 === o && "hidden" === ee(e, "visibility", i) && 0 !== t && (o = 0), $ ? a = new xe(l, "opacity", o, t - o, a) : ((a = new xe(l, "opacity", 100 * o, 100 * (t - o), a)).xn1 = c ? 1 : 0, l.zoom = 1, a.type = 2, a.b = "alpha(opacity=" + a.s + ")", a.e = "alpha(opacity=" + (a.s + a.c) + ")", a.data = e, a.plugin = s, a.setRatio = Je), c && ((a = new xe(l, "visibility", 0, 0, a, -1, null, !1, 0, 0 !== o ? "inherit" : "hidden", 0 === t ? "hidden" : "inherit")).xs0 = "inherit", r._overwriteProps.push(a.n), r._overwriteProps.push(n)), a } }); var Ze = function (e, t) { t && (e.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), e.removeProperty(t.replace(C, "-$1").toLowerCase())) : e.removeAttribute(t)) }, Ke = function (e) { if (this.t._gsClassPT = this, 1 === e || 0 === e) { this.t.setAttribute("class", 0 === e ? this.b : this.e); for (var t = this.data, i = this.t.style; t;)t.v ? i[t.p] = t.v : Ze(i, t.p), t = t._next; 1 === e && this.t._gsClassPT === this && (this.t._gsClassPT = null) } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e) }; Se("className", { parser: function (t, n, r, a, s, o, l) { var c, h, u, d, p, f = t.getAttribute("class") || "", m = t.style.cssText; if ((s = a._classNamePT = new xe(t, r, 0, 0, s, 2)).setRatio = Ke, s.pr = -11, e = !0, s.b = f, h = ne(t, i), u = t._gsClassPT) { for (d = {}, p = u.data; p;)d[p.p] = 1, p = p._next; u.setRatio(1) } return t._gsClassPT = s, s.e = "=" !== n.charAt(1) ? n : f.replace(new RegExp("(?:\\s|^)" + n.substr(2) + "(?![\\w-])"), "") + ("+" === n.charAt(0) ? " " + n.substr(2) : ""), t.setAttribute("class", s.e), c = re(t, h, ne(t), l, d), t.setAttribute("class", f), s.data = c.firstMPT, t.style.cssText !== m && (t.style.cssText = m), s = s.xfirst = a.parse(t, c.difs, s, o) } }); var Qe = function (e) { if ((1 === e || 0 === e) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) { var t, i, n, r, a, s = this.t.style, l = o.transform.parse; if ("all" === this.e) s.cssText = "", r = !0; else for (n = (t = this.e.split(" ").join("").split(",")).length; --n > -1;)i = t[n], o[i] && (o[i].parse === l ? r = !0 : i = "transformOrigin" === i ? De : o[i].p), Ze(s, i); r && (Ze(s, Ie), (a = this.t._gsTransform) && (a.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform)) } }; for (Se("clearProps", { parser: function (t, i, n, r, a) { return (a = new xe(t, n, 0, 0, a, 2)).setRatio = Qe, a.e = i, a.pr = -10, a.data = r._tween, e = !0, a } }), l = "bezier,throwProps,physicsProps,physics2D".split(","), Te = l.length; Te--;)Ee(l[Te]); (l = a.prototype)._firstPT = l._lastParsedTransform = l._transform = null, l._onInitTween = function (n, s, l, d) { if (!n.nodeType) return !1; this._target = m = n, this._tween = l, this._vars = s, g = d, c = s.autoRound, e = !1, t = s.suffixMap || a.suffixMap, i = Q(n), r = this._overwriteProps; var f, v, y, _, x, b, w, T, S, E = n.style; if (h && "" === E.zIndex && ("auto" !== (f = ee(n, "zIndex", i)) && "" !== f || this._addLazySet(E, "zIndex", 0)), "string" == typeof s && (_ = E.cssText, f = ne(n, i), E.cssText = _ + ";" + s, f = re(n, f, ne(n)).difs, !$ && M.test(s) && (f.opacity = parseFloat(RegExp.$1)), s = f, E.cssText = _), s.className ? this._firstPT = v = o.className.parse(n, s.className, "className", this, null, null, s) : this._firstPT = v = this.parse(n, s, null), this._transformType) { for (S = 3 === this._transformType, Ie ? u && (h = !0, "" === E.zIndex && ("auto" !== (w = ee(n, "zIndex", i)) && "" !== w || this._addLazySet(E, "zIndex", 0)), p && this._addLazySet(E, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (S ? "visible" : "hidden"))) : E.zoom = 1, y = v; y && y._next;)y = y._next; T = new xe(n, "transform", 0, 0, null, 2), this._linkCSSP(T, null, y), T.setRatio = Ie ? qe : Ye, T.data = this._transform || Xe(n, i, !0), T.tween = l, T.pr = -1, r.pop() } if (e) { for (; v;) { for (b = v._next, y = _; y && y.pr > v.pr;)y = y._next; (v._prev = y ? y._prev : x) ? v._prev._next = v : _ = v, (v._next = y) ? y._prev = v : x = v, v = b } this._firstPT = _ } return !0 }, l.parse = function (e, n, r, a) { var s, l, h, u, d, p, f, v, y, _, x = e.style; for (s in n) { if (p = n[s], l = o[s], "function" != typeof p || l && l.allowFunc || (p = p(g, m)), l) r = l.parse(e, p, s, this, r, a, n); else { if ("--" === s.substr(0, 2)) { this._tween._propLookup[s] = this._addTween.call(this._tween, e.style, "setProperty", Q(e).getPropertyValue(s) + "", p + "", s, !1, s); continue } d = ee(e, s, i) + "", y = "string" == typeof p, "color" === s || "fill" === s || "stroke" === s || -1 !== s.indexOf("Color") || y && E.test(p) ? (y || (p = ((p = fe(p)).length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), r = we(x, s, d, p, !0, "transparent", r, 0, a)) : y && D.test(p) ? r = we(x, s, d, p, !0, null, r, 0, a) : (f = (h = parseFloat(d)) || 0 === h ? d.substr((h + "").length) : "", "" !== d && "auto" !== d || ("width" === s || "height" === s ? (h = oe(e, s, i), f = "px") : "left" === s || "top" === s ? (h = ie(e, s, i), f = "px") : (h = "opacity" !== s ? 0 : 1, f = "")), (_ = y && "=" === p.charAt(1)) ? (u = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), u *= parseFloat(p), v = p.replace(w, "")) : (u = parseFloat(p), v = y ? p.replace(w, "") : ""), "" === v && (v = s in t ? t[s] : f), p = u || 0 === u ? (_ ? u + h : u) + v : n[s], f !== v && ("" === v && "lineHeight" !== s || (u || 0 === u) && h && (h = te(e, s, h, f), "%" === v ? (h /= te(e, s, 100, "%") / 100, !0 !== n.strictUnits && (d = h + "%")) : "em" === v || "rem" === v || "vw" === v || "vh" === v ? h /= te(e, s, 1, v) : "px" !== v && (u = te(e, s, u, v), v = "px"), _ && (u || 0 === u) && (p = u + h + v))), _ && (u += h), !h && 0 !== h || !u && 0 !== u ? void 0 !== x[s] && (p || p + "" != "NaN" && null != p) ? (r = new xe(x, s, u || h || 0, 0, r, -1, s, !1, 0, d, p)).xs0 = "none" !== p || "display" !== s && -1 === s.indexOf("Style") ? p : d : Y("invalid " + s + " tween value: " + n[s]) : (r = new xe(x, s, h, u - h, r, 0, s, !1 !== c && ("px" === v || "zIndex" === s), 0, d, p)).xs0 = v) } a && r && !r.plugin && (r.plugin = a) } return r }, l.setRatio = function (e) { var t, i, n, r = this._firstPT; if (1 !== e || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (e || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime) for (; r;) { if (t = r.c * e + r.s, r.r ? t = r.r(t) : t < 1e-6 && t > -1e-6 && (t = 0), r.type) if (1 === r.type) if (2 === (n = r.l)) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2; else if (3 === n) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3; else if (4 === n) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4; else if (5 === n) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5; else { for (i = r.xs0 + t + r.xs1, n = 1; n < r.l; n++)i += r["xn" + n] + r["xs" + (n + 1)]; r.t[r.p] = i } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(e); else r.t[r.p] = t + r.xs0; r = r._next } else for (; r;)2 !== r.type ? r.t[r.p] = r.b : r.setRatio(e), r = r._next; else for (; r;) { if (2 !== r.type) if (r.r && -1 !== r.type) if (t = r.r(r.s + r.c), r.type) { if (1 === r.type) { for (n = r.l, i = r.xs0 + t + r.xs1, n = 1; n < r.l; n++)i += r["xn" + n] + r["xs" + (n + 1)]; r.t[r.p] = i } } else r.t[r.p] = t + r.xs0; else r.t[r.p] = r.e; else r.setRatio(e); r = r._next } }, l._enableTransforms = function (e) { this._transform = this._transform || Xe(this._target, i, !0), this._transformType = this._transform.svg && Ce || !e && 3 !== this._transformType ? 2 : 3 }; var et = function (e) { this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0) }; l._addLazySet = function (e, t, i) { var n = this._firstPT = new xe(e, t, 0, 0, this._firstPT, 2); n.e = i, n.setRatio = et, n.data = this }, l._linkCSSP = function (e, t, i, n) { return e && (t && (t._prev = e), e._next && (e._next._prev = e._prev), e._prev ? e._prev._next = e._next : this._firstPT === e && (this._firstPT = e._next, n = !0), i ? i._next = e : n || null !== this._firstPT || (this._firstPT = e), e._next = t, e._prev = i), e }, l._mod = function (e) { for (var t = this._firstPT; t;)"function" == typeof e[t.p] && (t.r = e[t.p]), t = t._next }, l._kill = function (e) { var t, i, r, a = e; if (e.autoAlpha || e.alpha) { for (i in a = {}, e) a[i] = e[i]; a.opacity = 1, a.autoAlpha && (a.visibility = 1) } for (e.className && (t = this._classNamePT) && ((r = t.xfirst) && r._prev ? this._linkCSSP(r._prev, t._next, r._prev._prev) : r === this._firstPT && (this._firstPT = t._next), t._next && this._linkCSSP(t._next, t._next._next, r._prev), this._classNamePT = null), t = this._firstPT; t;)t.plugin && t.plugin !== i && t.plugin._kill && (t.plugin._kill(e), i = t.plugin), t = t._next; return n.j.prototype._kill.call(this, a) }; var tt = function (e, t, i) { var n, r, a, s; if (e.slice) for (r = e.length; --r > -1;)tt(e[r], t, i); else for (r = (n = e.childNodes).length; --r > -1;)s = (a = n[r]).type, a.style && (t.push(ne(a)), i && i.push(a)), 1 !== s && 9 !== s && 11 !== s || !a.childNodes.length || tt(a, t, i) }; return a.cascadeTo = function (e, t, i) { var r, a, s, o, l = n.l.to(e, t, i), c = [l], h = [], u = [], d = [], p = n.l._internals.reservedProps; for (e = l._targets || l.target, tt(e, h, d), l.render(t, !0, !0), tt(e, u), l.render(0, !0, !0), l._enabled(!0), r = d.length; --r > -1;)if ((a = re(d[r], h[r], u[r])).firstMPT) { for (s in a = a.difs, i) p[s] && (a[s] = i[s]); for (s in o = {}, a) o[s] = h[r][s]; c.push(n.l.fromTo(d[r], t, o, a)) } return c }, n.j.activate([a]), a }), !0); var o = n.m.CSSPlugin, l = n.k._gsDefine.plugin({ propName: "attr", API: 2, version: "0.6.1", init: function (e, t, i, n) { var r, a; if ("function" != typeof e.setAttribute) return !1; for (r in t) "function" == typeof (a = t[r]) && (a = a(n, e)), this._addTween(e, "setAttribute", e.getAttribute(r) + "", a + "", r, !1, r), this._overwriteProps.push(r); return !0 } }), c = n.k._gsDefine.plugin({ propName: "roundProps", version: "1.7.0", priority: -1, API: 2, init: function (e, t, i) { return this._tween = i, !0 } }), h = function (e) { var t = e < 1 ? Math.pow(10, (e + "").length - 2) : 1; return function (i) { return (Math.round(i / e) * e * t | 0) / t } }, u = function (e, t) { for (; e;)e.f || e.blob || (e.m = t || Math.round), e = e._next }, d = c.prototype;
/*!
 * VERSION: 0.6.1
 * DATE: 2018-08-27
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */d._onInitAllProps = function () { var e, t, i, n, r = this._tween, a = r.vars.roundProps, s = {}, o = r._propLookup.roundProps; if ("object" != typeof a || a.push) for ("string" == typeof a && (a = a.split(",")), i = a.length; --i > -1;)s[a[i]] = Math.round; else for (n in a) s[n] = h(a[n]); for (n in s) for (e = r._firstPT; e;)t = e._next, e.pg ? e.t._mod(s) : e.n === n && (2 === e.f && e.t ? u(e.t._firstPT, s[n]) : (this._add(e.t, n, e.s, e.c, s[n]), t && (t._prev = e._prev), e._prev ? e._prev._next = t : r._firstPT === e && (r._firstPT = t), e._next = e._prev = null, r._propLookup[n] = o)), e = t; return !1 }, d._add = function (e, t, i, n, r) { this._addTween(e, t, i, i + n, t, r || Math.round), this._overwriteProps.push(t) };
    /*!
     * VERSION: 0.3.1
     * DATE: 2018-08-27
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     **/
    var p = n.k._gsDefine.plugin({ propName: "directionalRotation", version: "0.3.1", API: 2, init: function (e, t, i, n) { "object" != typeof t && (t = { rotation: t }), this.finals = {}; var r, a, s, o, l, c, h = !0 === t.useRadians ? 2 * Math.PI : 360; for (r in t) "useRadians" !== r && ("function" == typeof (o = t[r]) && (o = o(n, e)), a = (c = (o + "").split("_"))[0], s = parseFloat("function" != typeof e[r] ? e[r] : e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), l = (o = this.finals[r] = "string" == typeof a && "=" === a.charAt(1) ? s + parseInt(a.charAt(0) + "1", 10) * Number(a.substr(2)) : Number(a) || 0) - s, c.length && (-1 !== (a = c.join("_")).indexOf("short") && (l %= h) !== l % (h / 2) && (l = l < 0 ? l + h : l - h), -1 !== a.indexOf("_cw") && l < 0 ? l = (l + 9999999999 * h) % h - (l / h | 0) * h : -1 !== a.indexOf("ccw") && l > 0 && (l = (l - 9999999999 * h) % h - (l / h | 0) * h)), (l > 1e-6 || l < -1e-6) && (this._addTween(e, r, s, s + l, r), this._overwriteProps.push(r))); return !0 }, set: function (e) { var t; if (1 !== e) this._super.setRatio.call(this, e); else for (t = this._firstPT; t;)t.f ? t.t[t.p](this.finals[t.p]) : t.t[t.p] = this.finals[t.p], t = t._next } }); p._autoCSS = !0;
    /*!
     * VERSION: 1.3.9
     * DATE: 2019-05-17
     * UPDATES AND DOCS AT: http://greensock.com
     *
     * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
     * This work is subject to the terms at http://greensock.com/standard-license or for
     * Club GreenSock members, the software agreement that was issued with your membership.
     * 
     * @author: Jack Doyle, jack@greensock.com
     **/
    var f = 180 / Math.PI, m = [], g = [], v = [], y = {}, _ = n.k._gsDefine.globals, x = function (e, t, i, n) { i === n && (i = n - (n - t) / 1e6), e === t && (t = e + (i - e) / 1e6), this.a = e, this.b = t, this.c = i, this.d = n, this.da = n - e, this.ca = i - e, this.ba = t - e }, b = function (e, t, i, n) { var r = { a: e }, a = {}, s = {}, o = { c: n }, l = (e + t) / 2, c = (t + i) / 2, h = (i + n) / 2, u = (l + c) / 2, d = (c + h) / 2, p = (d - u) / 8; return r.b = l + (e - l) / 4, a.b = u + p, r.c = a.a = (r.b + a.b) / 2, a.c = s.a = (u + d) / 2, s.b = d - p, o.b = h + (n - h) / 4, s.c = o.a = (s.b + o.b) / 2, [r, a, s, o] }, w = function (e, t, i, n, r) { var a, s, o, l, c, h, u, d, p, f, y, _, x, w = e.length - 1, T = 0, M = e[0].a; for (a = 0; a < w; a++)s = (c = e[T]).a, o = c.d, l = e[T + 1].d, r ? (y = m[a], x = ((_ = g[a]) + y) * t * .25 / (n ? .5 : v[a] || .5), d = o - ((h = o - (o - s) * (n ? .5 * t : 0 !== y ? x / y : 0)) + (((u = o + (l - o) * (n ? .5 * t : 0 !== _ ? x / _ : 0)) - h) * (3 * y / (y + _) + .5) / 4 || 0))) : d = o - ((h = o - (o - s) * t * .5) + (u = o + (l - o) * t * .5)) / 2, h += d, u += d, c.c = p = h, c.b = 0 !== a ? M : M = c.a + .6 * (c.c - c.a), c.da = o - s, c.ca = p - s, c.ba = M - s, i ? (f = b(s, M, p, o), e.splice(T, 1, f[0], f[1], f[2], f[3]), T += 4) : T++, M = u; (c = e[T]).b = M, c.c = M + .4 * (c.d - M), c.da = c.d - c.a, c.ca = c.c - c.a, c.ba = M - c.a, i && (f = b(c.a, M, c.c, c.d), e.splice(T, 1, f[0], f[1], f[2], f[3])) }, T = function (e, t, i, n) { var r, a, s, o, l, c, h = []; if (n) for (a = (e = [n].concat(e)).length; --a > -1;)"string" == typeof (c = e[a][t]) && "=" === c.charAt(1) && (e[a][t] = n[t] + Number(c.charAt(0) + c.substr(2))); if ((r = e.length - 2) < 0) return h[0] = new x(e[0][t], 0, 0, e[0][t]), h; for (a = 0; a < r; a++)s = e[a][t], o = e[a + 1][t], h[a] = new x(s, 0, 0, o), i && (l = e[a + 2][t], m[a] = (m[a] || 0) + (o - s) * (o - s), g[a] = (g[a] || 0) + (l - o) * (l - o)); return h[a] = new x(e[a][t], 0, 0, e[a + 1][t]), h }, M = function (e, t, i, n, r, a) { var s, o, l, c, h, u, d, p, f = {}, _ = [], x = a || e[0]; for (o in r = "string" == typeof r ? "," + r + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == t && (t = 1), e[0]) _.push(o); if (e.length > 1) { for (p = e[e.length - 1], d = !0, s = _.length; --s > -1;)if (o = _[s], Math.abs(x[o] - p[o]) > .05) { d = !1; break } d && (e = e.concat(), a && e.unshift(a), e.push(e[1]), a = e[e.length - 3]) } for (m.length = g.length = v.length = 0, s = _.length; --s > -1;)o = _[s], y[o] = -1 !== r.indexOf("," + o + ","), f[o] = T(e, o, y[o], a); for (s = m.length; --s > -1;)m[s] = Math.sqrt(m[s]), g[s] = Math.sqrt(g[s]); if (!n) { for (s = _.length; --s > -1;)if (y[o]) for (u = (l = f[_[s]]).length - 1, c = 0; c < u; c++)h = l[c + 1].da / g[c] + l[c].da / m[c] || 0, v[c] = (v[c] || 0) + h * h; for (s = v.length; --s > -1;)v[s] = Math.sqrt(v[s]) } for (s = _.length, c = i ? 4 : 1; --s > -1;)l = f[o = _[s]], w(l, t, i, n, y[o]), d && (l.splice(0, c), l.splice(l.length - c, c)); return f }, S = function (e, t, i) { for (var n, r, a, s, o, l, c, h, u, d, p, f = 1 / i, m = e.length; --m > -1;)for (a = (d = e[m]).a, s = d.d - a, o = d.c - a, l = d.b - a, n = r = 0, h = 1; h <= i; h++)n = r - (r = ((c = f * h) * c * s + 3 * (u = 1 - c) * (c * o + u * l)) * c), t[p = m * i + h - 1] = (t[p] || 0) + n * n }, E = n.k._gsDefine.plugin({ propName: "bezier", priority: -1, version: "1.3.9", API: 2, global: !0, init: function (e, t, i) { this._target = e, t instanceof Array && (t = { values: t }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == t.timeResolution ? 6 : parseInt(t.timeResolution, 10); var n, r, a, s, o, l = t.values || [], c = {}, h = l[0], u = t.autoRotate || i.vars.orientToBezier; for (n in this._autoRotate = u ? u instanceof Array ? u : [["x", "y", "rotation", !0 === u ? 0 : Number(u) || 0]] : null, h) this._props.push(n); for (a = this._props.length; --a > -1;)n = this._props[a], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof e[n], c[n] = r ? e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(e[n]), o || c[n] !== l[0][n] && (o = c); if (this._beziers = "cubic" !== t.type && "quadratic" !== t.type && "soft" !== t.type ? M(l, isNaN(t.curviness) ? 1 : t.curviness, !1, "thruBasic" === t.type, t.correlate, o) : function (e, t, i) { var n, r, a, s, o, l, c, h, u, d, p, f = {}, m = "cubic" === (t = t || "soft") ? 3 : 2, g = "soft" === t, v = []; if (g && i && (e = [i].concat(e)), null == e || e.length < m + 1) throw "invalid Bezier data"; for (u in e[0]) v.push(u); for (l = v.length; --l > -1;) { for (f[u = v[l]] = o = [], d = 0, h = e.length, c = 0; c < h; c++)n = null == i ? e[c][u] : "string" == typeof (p = e[c][u]) && "=" === p.charAt(1) ? i[u] + Number(p.charAt(0) + p.substr(2)) : Number(p), g && c > 1 && c < h - 1 && (o[d++] = (n + o[d - 2]) / 2), o[d++] = n; for (h = d - m + 1, d = 0, c = 0; c < h; c += m)n = o[c], r = o[c + 1], a = o[c + 2], s = 2 === m ? 0 : o[c + 3], o[d++] = p = 3 === m ? new x(n, r, a, s) : new x(n, (2 * r + n) / 3, (2 * r + a) / 3, a); o.length = d } return f }(l, t.type, c), this._segCount = this._beziers[n].length, this._timeRes) { var d = function (e, t) { var i, n, r, a, s = [], o = [], l = 0, c = 0, h = (t = t >> 0 || 6) - 1, u = [], d = []; for (i in e) S(e[i], s, t); for (r = s.length, n = 0; n < r; n++)l += Math.sqrt(s[n]), d[a = n % t] = l, a === h && (c += l, u[a = n / t >> 0] = d, o[a] = c, l = 0, d = []); return { length: c, lengths: o, segments: u } }(this._beziers, this._timeRes); this._length = d.length, this._lengths = d.lengths, this._segments = d.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length } if (u = this._autoRotate) for (this._initialRotations = [], u[0] instanceof Array || (this._autoRotate = u = [u]), a = u.length; --a > -1;) { for (s = 0; s < 3; s++)n = u[a][s], this._func[n] = "function" == typeof e[n] && e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)]; n = u[a][2], this._initialRotations[a] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0, this._overwriteProps.push(n) } return this._startRatio = i.vars.runBackwards ? 1 : 0, !0 }, set: function (e) { var t, i, n, r, a, s, o, l, c, h, u, d = this._segCount, p = this._func, m = this._target, g = e !== this._startRatio; if (this._timeRes) { if (c = this._lengths, h = this._curSeg, u = e * this._length, n = this._li, u > this._l2 && n < d - 1) { for (l = d - 1; n < l && (this._l2 = c[++n]) <= u;); this._l1 = c[n - 1], this._li = n, this._curSeg = h = this._segments[n], this._s2 = h[this._s1 = this._si = 0] } else if (u < this._l1 && n > 0) { for (; n > 0 && (this._l1 = c[--n]) >= u;); 0 === n && u < this._l1 ? this._l1 = 0 : n++, this._l2 = c[n], this._li = n, this._curSeg = h = this._segments[n], this._s1 = h[(this._si = h.length - 1) - 1] || 0, this._s2 = h[this._si] } if (t = n, u -= this._l1, n = this._si, u > this._s2 && n < h.length - 1) { for (l = h.length - 1; n < l && (this._s2 = h[++n]) <= u;); this._s1 = h[n - 1], this._si = n } else if (u < this._s1 && n > 0) { for (; n > 0 && (this._s1 = h[--n]) >= u;); 0 === n && u < this._s1 ? this._s1 = 0 : n++, this._s2 = h[n], this._si = n } s = 1 === e ? 1 : (n + (u - this._s1) / (this._s2 - this._s1)) * this._prec || 0 } else s = (e - (t = e < 0 ? 0 : e >= 1 ? d - 1 : d * e >> 0) * (1 / d)) * d; for (i = 1 - s, n = this._props.length; --n > -1;)r = this._props[n], o = (s * s * (a = this._beziers[r][t]).da + 3 * i * (s * a.ca + i * a.ba)) * s + a.a, this._mod[r] && (o = this._mod[r](o, m)), p[r] ? m[r](o) : m[r] = o; if (this._autoRotate) { var v, y, _, x, b, w, T, M = this._autoRotate; for (n = M.length; --n > -1;)r = M[n][2], w = M[n][3] || 0, T = !0 === M[n][4] ? 1 : f, a = this._beziers[M[n][0]], v = this._beziers[M[n][1]], a && v && (a = a[t], v = v[t], y = a.a + (a.b - a.a) * s, y += ((x = a.b + (a.c - a.b) * s) - y) * s, x += (a.c + (a.d - a.c) * s - x) * s, _ = v.a + (v.b - v.a) * s, _ += ((b = v.b + (v.c - v.b) * s) - _) * s, b += (v.c + (v.d - v.c) * s - b) * s, o = g ? Math.atan2(b - _, x - y) * T + w : this._initialRotations[n], this._mod[r] && (o = this._mod[r](o, m)), p[r] ? m[r](o) : m[r] = o) } } }), C = E.prototype; E.bezierThrough = M, E.cubicToQuadratic = b, E._autoCSS = !0, E.quadraticToCubic = function (e, t, i) { return new x(e, (2 * t + e) / 3, (2 * t + i) / 3, i) }, E._cssRegister = function () { var e = _.CSSPlugin; if (e) { var t = e._internals, i = t._parseToProxy, n = t._setPluginRatio, r = t.CSSPropTween; t._registerComplexSpecialProp("bezier", { parser: function (e, t, a, s, o, l) { t instanceof Array && (t = { values: t }), l = new E; var c, h, u, d = t.values, p = d.length - 1, f = [], m = {}; if (p < 0) return o; for (c = 0; c <= p; c++)u = i(e, d[c], s, o, l, p !== c), f[c] = u.end; for (h in t) m[h] = t[h]; return m.values = f, (o = new r(e, "bezier", 0, 0, u.pt, 2)).data = u, o.plugin = l, o.setRatio = n, 0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (c = !0 === m.autoRotate ? 0 : Number(m.autoRotate), m.autoRotate = null != u.end.left ? [["left", "top", "rotation", c, !1]] : null != u.end.x && [["x", "y", "rotation", c, !1]]), m.autoRotate && (s._transform || s._enableTransforms(!1), u.autoRotate = s._target._gsTransform, u.proxy.rotation = u.autoRotate.rotation || 0, s._overwriteProps.push("rotation")), l._onInitTween(u.proxy, m, s._tween), o } }) } }, C._mod = function (e) { for (var t, i = this._overwriteProps, n = i.length; --n > -1;)(t = e[i[n]]) && "function" == typeof t && (this._mod[i[n]] = t) }, C._kill = function (e) { var t, i, n = this._props; for (t in this._beziers) if (t in e) for (delete this._beziers[t], delete this._func[t], i = n.length; --i > -1;)n[i] === t && n.splice(i, 1); if (n = this._autoRotate) for (i = n.length; --i > -1;)e[n[i][2]] && n.splice(i, 1); return this._super._kill.call(this, e) },
        /*!
         * VERSION: 1.16.1
         * DATE: 2018-08-27
         * UPDATES AND DOCS AT: http://greensock.com
         *
         * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
         * This work is subject to the terms at http://greensock.com/standard-license or for
         * Club GreenSock members, the software agreement that was issued with your membership.
         * 
         * @author: Jack Doyle, jack@greensock.com
         **/
        n.k._gsDefine("easing.Back", ["easing.Ease"], (function () { var e, t, i, r, a = n.k.GreenSockGlobals || n.k, s = a.com.greensock, o = 2 * Math.PI, l = Math.PI / 2, c = s._class, h = function (e, t) { var i = c("easing." + e, (function () { }), !0), r = i.prototype = new n.b; return r.constructor = i, r.getRatio = t, i }, u = n.b.register || function () { }, d = function (e, t, i, n, r) { var a = c("easing." + e, { easeOut: new t, easeIn: new i, easeInOut: new n }, !0); return u(a, e), a }, p = function (e, t, i) { this.t = e, this.v = t, i && (this.next = i, i.prev = this, this.c = i.v - t, this.gap = i.t - e) }, f = function (e, t) { var i = c("easing." + e, (function (e) { this._p1 = e || 0 === e ? e : 1.70158, this._p2 = 1.525 * this._p1 }), !0), r = i.prototype = new n.b; return r.constructor = i, r.getRatio = t, r.config = function (e) { return new i(e) }, i }, m = d("Back", f("BackOut", (function (e) { return (e -= 1) * e * ((this._p1 + 1) * e + this._p1) + 1 })), f("BackIn", (function (e) { return e * e * ((this._p1 + 1) * e - this._p1) })), f("BackInOut", (function (e) { return (e *= 2) < 1 ? .5 * e * e * ((this._p2 + 1) * e - this._p2) : .5 * ((e -= 2) * e * ((this._p2 + 1) * e + this._p2) + 2) }))), g = c("easing.SlowMo", (function (e, t, i) { t = t || 0 === t ? t : .7, null == e ? e = .7 : e > 1 && (e = 1), this._p = 1 !== e ? t : 0, this._p1 = (1 - e) / 2, this._p2 = e, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i }), !0), v = g.prototype = new n.b; return v.constructor = g, v.getRatio = function (e) { var t = e + (.5 - e) * this._p; return e < this._p1 ? this._calcEnd ? 1 - (e = 1 - e / this._p1) * e : t - (e = 1 - e / this._p1) * e * e * e * t : e > this._p3 ? this._calcEnd ? 1 === e ? 0 : 1 - (e = (e - this._p3) / this._p1) * e : t + (e - t) * (e = (e - this._p3) / this._p1) * e * e * e : this._calcEnd ? 1 : t }, g.ease = new g(.7, .7), v.config = g.config = function (e, t, i) { return new g(e, t, i) }, (v = (e = c("easing.SteppedEase", (function (e, t) { e = e || 1, this._p1 = 1 / e, this._p2 = e + (t ? 0 : 1), this._p3 = t ? 1 : 0 }), !0)).prototype = new n.b).constructor = e, v.getRatio = function (e) { return e < 0 ? e = 0 : e >= 1 && (e = .999999999), ((this._p2 * e | 0) + this._p3) * this._p1 }, v.config = e.config = function (t, i) { return new e(t, i) }, (v = (t = c("easing.ExpoScaleEase", (function (e, t, i) { this._p1 = Math.log(t / e), this._p2 = t - e, this._p3 = e, this._ease = i }), !0)).prototype = new n.b).constructor = t, v.getRatio = function (e) { return this._ease && (e = this._ease.getRatio(e)), (this._p3 * Math.exp(this._p1 * e) - this._p3) / this._p2 }, v.config = t.config = function (e, i, n) { return new t(e, i, n) }, (v = (i = c("easing.RoughEase", (function (e) { for (var t, i, r, a, s, o, l = (e = e || {}).taper || "none", c = [], h = 0, u = 0 | (e.points || 20), d = u, f = !1 !== e.randomize, m = !0 === e.clamp, g = e.template instanceof n.b ? e.template : null, v = "number" == typeof e.strength ? .4 * e.strength : .4; --d > -1;)t = f ? Math.random() : 1 / u * d, i = g ? g.getRatio(t) : t, r = "none" === l ? v : "out" === l ? (a = 1 - t) * a * v : "in" === l ? t * t * v : t < .5 ? (a = 2 * t) * a * .5 * v : (a = 2 * (1 - t)) * a * .5 * v, f ? i += Math.random() * r - .5 * r : d % 2 ? i += .5 * r : i -= .5 * r, m && (i > 1 ? i = 1 : i < 0 && (i = 0)), c[h++] = { x: t, y: i }; for (c.sort((function (e, t) { return e.x - t.x })), o = new p(1, 1, null), d = u; --d > -1;)s = c[d], o = new p(s.x, s.y, o); this._prev = new p(0, 0, 0 !== o.t ? o : o.next) }), !0)).prototype = new n.b).constructor = i, v.getRatio = function (e) { var t = this._prev; if (e > t.t) { for (; t.next && e >= t.t;)t = t.next; t = t.prev } else for (; t.prev && e <= t.t;)t = t.prev; return this._prev = t, t.v + (e - t.t) / t.gap * t.c }, v.config = function (e) { return new i(e) }, i.ease = new i, d("Bounce", h("BounceOut", (function (e) { return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375 })), h("BounceIn", (function (e) { return (e = 1 - e) < 1 / 2.75 ? 1 - 7.5625 * e * e : e < 2 / 2.75 ? 1 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : e < 2.5 / 2.75 ? 1 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 1 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375) })), h("BounceInOut", (function (e) { var t = e < .5; return (e = t ? 1 - 2 * e : 2 * e - 1) < 1 / 2.75 ? e *= 7.5625 * e : e = e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375, t ? .5 * (1 - e) : .5 * e + .5 }))), d("Circ", h("CircOut", (function (e) { return Math.sqrt(1 - (e -= 1) * e) })), h("CircIn", (function (e) { return -(Math.sqrt(1 - e * e) - 1) })), h("CircInOut", (function (e) { return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1) }))), d("Elastic", (r = function (e, t, i) { var r = c("easing." + e, (function (e, t) { this._p1 = e >= 1 ? e : 1, this._p2 = (t || i) / (e < 1 ? e : 1), this._p3 = this._p2 / o * (Math.asin(1 / this._p1) || 0), this._p2 = o / this._p2 }), !0), a = r.prototype = new n.b; return a.constructor = r, a.getRatio = t, a.config = function (e, t) { return new r(e, t) }, r })("ElasticOut", (function (e) { return this._p1 * Math.pow(2, -10 * e) * Math.sin((e - this._p3) * this._p2) + 1 }), .3), r("ElasticIn", (function (e) { return -this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) }), .3), r("ElasticInOut", (function (e) { return (e *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) * .5 + 1 }), .45)), d("Expo", h("ExpoOut", (function (e) { return 1 - Math.pow(2, -10 * e) })), h("ExpoIn", (function (e) { return Math.pow(2, 10 * (e - 1)) - .001 })), h("ExpoInOut", (function (e) { return (e *= 2) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * (e - 1))) }))), d("Sine", h("SineOut", (function (e) { return Math.sin(e * l) })), h("SineIn", (function (e) { return 1 - Math.cos(e * l) })), h("SineInOut", (function (e) { return -.5 * (Math.cos(Math.PI * e) - 1) }))), c("easing.EaseLookup", { find: function (e) { return n.b.map[e] } }, !0), u(a.SlowMo, "SlowMo", "ease,"), u(i, "RoughEase", "ease,"), u(e, "SteppedEase", "ease,"), m }), !0); var A = n.m.Back, P = n.m.Elastic, L = n.m.Bounce, R = n.m.RoughEase, O = n.m.SlowMo, I = n.m.SteppedEase, k = n.m.Circ, D = n.m.Expo, z = n.m.Sine, N = n.m.ExpoScaleEase, B = s.a; B._autoActivated = [r.a, a.a, o, l, E, c, p, A, P, L, R, O, I, k, D, z, N], i.d(t, "default", (function () { return B })), i.d(t, "TweenLite", (function () { return n.l })), i.d(t, "TweenMax", (function () { return B })), i.d(t, "TimelineLite", (function () { return r.a })), i.d(t, "TimelineMax", (function () { return a.a })), i.d(t, "CSSPlugin", (function () { return o })), i.d(t, "AttrPlugin", (function () { return l })), i.d(t, "BezierPlugin", (function () { return E })), i.d(t, "RoundPropsPlugin", (function () { return c })), i.d(t, "DirectionalRotationPlugin", (function () { return p })), i.d(t, "TweenPlugin", (function () { return n.j })), i.d(t, "Ease", (function () { return n.b })), i.d(t, "Power0", (function () { return n.d })), i.d(t, "Power1", (function () { return n.e })), i.d(t, "Power2", (function () { return n.f })), i.d(t, "Power3", (function () { return n.g })), i.d(t, "Power4", (function () { return n.h })), i.d(t, "Linear", (function () { return n.c })), i.d(t, "Back", (function () { return A })), i.d(t, "Elastic", (function () { return P })), i.d(t, "Bounce", (function () { return L })), i.d(t, "RoughEase", (function () { return R })), i.d(t, "SlowMo", (function () { return O })), i.d(t, "SteppedEase", (function () { return I })), i.d(t, "Circ", (function () { return k })), i.d(t, "Expo", (function () { return D })), i.d(t, "Sine", (function () { return z })), i.d(t, "ExpoScaleEase", (function () { return N })), i.d(t, "_gsScope", (function () { return n.k }))
}]);